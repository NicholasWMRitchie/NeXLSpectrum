var documenterSearchIndex = {"docs":
[{"location":"errorbars/#How-good-are-the-fit-uncertainty-estimates?","page":"Lovely Error Bars","title":"How good are the fit uncertainty estimates?","text":"","category":"section"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"This document looks at two different sets of measured spectra to evaluate how well, the estimated fit uncertainties match the observed uncertainties.  We are using two materials known to be highly homogeneous - K412 and ADM-6006a glasses.  To produce a set of spectra that differ only in count statistics, we will subdivide a spectrum into 100 spectra with an effective live-time of 0.01 of the original spectrum livetime.  We expect that we should be able to compare the \"fit-predicted\" uncertainties with the \"observed distribution\" of measured values.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"To be clear:","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"\"fit-predicted\" - Comes from the covariance matrix output from the linear least squares fit\n\"observed distribution\" - Calculated as the standard-deviation of the 100 fit values.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"We want the ratio of the (observed distribution) / (fit predicted) to be unity or close.  We will call this ratio the \"heterogeneity\" (or \"hetero\" in the fourth column of the describe(....) table.)","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"We then repeat the process on the multiple measured unknown spectra. (4 for K412 and 15 for ADM-6005a)  We expect the heterogeneity to be one or larger - larger than unity when the sample is not perfectly homogeneous.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"using NeXLSpectrum              # Provides spectrum reading and fitting tools\nusing NeXLMatrixCorrection      # Provides `quant` to convert k-ratios to mass fraction.\nusing DataFrames                # Tables\nusing BenchmarkTools","category":"page"},{"location":"errorbars/#K412","page":"Lovely Error Bars","title":"K412","text":"","category":"section"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Load the spectra, define the fit model and apply it.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"path = \"K412 spectra\"\nfe = loadspectrum(joinpath(path, \"Fe std.msa\"))\ndet = matching(fe, 132.0, 10)\nunks = (i->loadspectrum(joinpath(path, \"III-E K412[$i][4].msa\"),det)).(0:4)\nal2o3 = loadspectrum(joinpath(path, \"Al2O3 std.msa\"),det)\ncaf2 = loadspectrum(joinpath(path, \"CaF2 std.msa\"),det)\nfe = loadspectrum(joinpath(path, \"Fe std.msa\"),det)\nmgo = loadspectrum(joinpath(path, \"MgO std.msa\"),det)\nsio2 = loadspectrum(joinpath(path, \"SiO2 std.msa\"),det)\n\nrefs = (\n  # spectrum, element, composition\n  ( al2o3, n\"Al\", mat\"Al2O3\" ), #\n  ( mgo,   n\"Mg\", mat\"MgO\" ),   #\n  ( fe,    n\"Fe\", mat\"Fe\" ),    #\n  ( sio2,  n\"Si\", mat\"SiO2\" ),  #\n  ( sio2,  n\"O\",  mat\"SiO2\" ),  #\n  ( caf2,  n\"Ca\", mat\"CaF2\" ), )\n\nfilt = buildfilter(det)\nfrs = mapreduce(ref->filterreference(filt, ref..., withEsc=true), append!, refs)\n# frs is now a FilteredReference[] used to fit the unknowns.\n\nss = subdivide(unks[1], 100)\nres= map(s->fit(s,filt,frs,false), ss)\ndisplay(asa(DataFrame, res[1:10], withUnc=true))","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"10×17 DataFrame. Omitted printing of 15 columns\n│ Row │ Spectra                           │ O K-L3 + 1 other │\n│     │ String                            │ Float64          │\n├─────┼───────────────────────────────────┼──────────────────┤\n│ 1   │ Sub[III-E K412[0][all],1 of 100]  │ 0.651685         │\n│ 2   │ Sub[III-E K412[0][all],2 of 100]  │ 0.637457         │\n│ 3   │ Sub[III-E K412[0][all],3 of 100]  │ 0.662229         │\n│ 4   │ Sub[III-E K412[0][all],4 of 100]  │ 0.652349         │\n│ 5   │ Sub[III-E K412[0][all],5 of 100]  │ 0.657323         │\n│ 6   │ Sub[III-E K412[0][all],6 of 100]  │ 0.666922         │\n│ 7   │ Sub[III-E K412[0][all],7 of 100]  │ 0.652375         │\n│ 8   │ Sub[III-E K412[0][all],8 of 100]  │ 0.653504         │\n│ 9   │ Sub[III-E K412[0][all],9 of 100]  │ 0.659833         │\n│ 10  │ Sub[III-E K412[0][all],10 of 100] │ 0.650065         │","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"display(describe(res))","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"8×9 DataFrame. Omitted printing of 4 columns\n│ Row │ variable             │ mean      │ std        │ hetero   │ min     \n  │\n│     │ Symbol               │ Float64   │ Float64    │ Float64  │ Float64 \n  │\n├─────┼──────────────────────┼───────────┼────────────┼──────────┼─────────\n──┤\n│ 1   │ O K-L3 + 1 other     │ 0.655611  │ 0.00849501 │ 1.04449  │ 0.634151\n  │\n│ 2   │ Fe L3-M5 + 11 others │ 0.0419351 │ 0.00326518 │ 0.745405 │ 0.034163\n4 │\n│ 3   │ Mg K-L3 + 1 other    │ 0.147582  │ 0.00180057 │ 0.981789 │ 0.143343\n  │\n│ 4   │ Al K-L3 + 1 other    │ 0.0670228 │ 0.00141903 │ 0.892641 │ 0.062834\n  │\n│ 5   │ Si K-L3 + 2 others   │ 0.351032  │ 0.00302546 │ 1.0463   │ 0.343734\n  │\n│ 6   │ Ca K-L3 + 3 others   │ 0.192186  │ 0.00256265 │ 1.10189  │ 0.185293\n  │\n│ 7   │ Fe K-L3 + 1 other    │ 0.0668352 │ 0.00179242 │ 1.12552  │ 0.062555\n1 │\n│ 8   │ Fe K-M3 + 3 others   │ 0.0668979 │ 0.00624409 │ 0.929343 │ 0.049915\n6 │","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Repeat the fit for the 4 measured unknowns.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"res= map(s->fit(s,filt,frs,false),unks)\ndisplay(asa(DataFrame, res, withUnc=true))","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"5×17 DataFrame. Omitted printing of 14 columns\n│ Row │ Spectra            │ O K-L3 + 1 other │ ΔO K-L3 + 1 other │\n│     │ String             │ Float64          │ Float64           │\n├─────┼────────────────────┼──────────────────┼───────────────────┤\n│ 1   │ III-E K412[0][all] │ 0.655621         │ 0.000813387       │\n│ 2   │ III-E K412[1][all] │ 0.657418         │ 0.000814094       │\n│ 3   │ III-E K412[2][all] │ 0.65798          │ 0.000815687       │\n│ 4   │ III-E K412[3][all] │ 0.662417         │ 0.000818765       │\n│ 5   │ III-E K412[4][all] │ 0.660782         │ 0.000818176       │","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"display(describe(res))","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"8×9 DataFrame. Omitted printing of 4 columns\n│ Row │ variable             │ mean      │ std         │ hetero   │ min    \n   │\n│     │ Symbol               │ Float64   │ Float64     │ Float64  │ Float64\n   │\n├─────┼──────────────────────┼───────────┼─────────────┼──────────┼────────\n───┤\n│ 1   │ O K-L3 + 1 other     │ 0.658843  │ 0.00272421  │ 3.33841  │ 0.65562\n1  │\n│ 2   │ Fe L3-M5 + 11 others │ 0.0415344 │ 0.000449559 │ 1.02657  │ 0.04081\n74 │\n│ 3   │ Mg K-L3 + 1 other    │ 0.147843  │ 0.000302691 │ 1.647    │ 0.14748\n5  │\n│ 4   │ Al K-L3 + 1 other    │ 0.0670897 │ 0.000201863 │ 1.26691  │ 0.06678\n42 │\n│ 5   │ Si K-L3 + 2 others   │ 0.35141   │ 0.000835142 │ 2.88271  │ 0.35019\n8  │\n│ 6   │ Ca K-L3 + 3 others   │ 0.192142  │ 0.000317952 │ 1.36515  │ 0.19163\n   │\n│ 7   │ Fe K-L3 + 1 other    │ 0.0669106 │ 0.000106305 │ 0.666072 │ 0.06682\n3  │\n│ 8   │ Fe K-M3 + 3 others   │ 0.0671086 │ 0.000507064 │ 0.753089 │ 0.06648\n15 │","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"@btime fit(unks[1], filt, frs, false)","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"2.200 ms (30372 allocations: 13.07 MiB)\nIII-E K412[0][all]","category":"page"},{"location":"errorbars/#AMM-6005a","page":"Lovely Error Bars","title":"AMM-6005a","text":"","category":"section"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Repeat using the ADM glass.  Fe is not present in ADM-6005a but we fit it to see what a null result looks like.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"path = normpath(joinpath(\"..\",\"test\",\"ADM6005a spectra\"))\nunks = map(i->loadspectrum(joinpath(path,\"ADM-6005a_$i.msa\")),1:15)\nal, caf2, fe, ge, si, sio2, ti, zn = map(f->loadspectrum(joinpath(path,\"$f.msa\")), (\"Al std\", \"CaF2 std\", \"Fe std\", \"Ge std\", \"Si std\", \"SiO2 std\", \"Ti trimmed\",\"Zn std\"))\n\nrefs = (\n  # spectrum, element, composition\n  ( al,   n\"Al\", mat\"Al\" ), #\n  ( caf2, n\"Ca\", mat\"CaF2\" ),   #\n  ( fe,   n\"Fe\", mat\"Fe\" ),    #\n  ( ge,   n\"Ge\", mat\"Ge\" ),    #\n  ( si,   n\"Si\", mat\"Si\" ),  #\n  ( sio2, n\"O\",  mat\"SiO2\" ),  #\n  ( ti,   n\"Ti\", mat\"Ti\" ),\n  ( zn,   n\"Zn\", mat\"Zn\" ),\n)\n\ndet = matching(unks[1], 132.0, 10)\nfilt = buildfilter(det)\nfrs = mapreduce(ref->filterreference(filt, ref..., withEsc=true), append!, refs)\n# frs is now a FilteredReference[] used to fit the unknowns.\nss = subdivide(unks[1], 100)\nres= map(s->fit(s,filt,frs,false), ss)\ndisplay(asa(DataFrame, res[1:10], withUnc=true))","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"10×31 DataFrame. Omitted printing of 29 columns\n│ Row │ Spectra                    │ Ti L3-M1 + 6 others │\n│     │ String                     │ Float64             │\n├─────┼────────────────────────────┼─────────────────────┤\n│ 1   │ Sub[ADM-6005a_1,1 of 100]  │ 0.0182253           │\n│ 2   │ Sub[ADM-6005a_1,2 of 100]  │ 0.0281973           │\n│ 3   │ Sub[ADM-6005a_1,3 of 100]  │ 0.0294104           │\n│ 4   │ Sub[ADM-6005a_1,4 of 100]  │ 0.0441845           │\n│ 5   │ Sub[ADM-6005a_1,5 of 100]  │ 0.0157988           │\n│ 6   │ Sub[ADM-6005a_1,6 of 100]  │ 0.0361226           │\n│ 7   │ Sub[ADM-6005a_1,7 of 100]  │ 0.0120712           │\n│ 8   │ Sub[ADM-6005a_1,8 of 100]  │ 0.0184761           │\n│ 9   │ Sub[ADM-6005a_1,9 of 100]  │ 0.00438704          │\n│ 10  │ Sub[ADM-6005a_1,10 of 100] │ 0.0317397           │","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"display(describe(res))","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"15×9 DataFrame. Omitted printing of 5 columns\n│ Row │ variable             │ mean        │ std         │ hetero  │\n│     │ Symbol               │ Float64     │ Float64     │ Float64 │\n├─────┼──────────────────────┼─────────────┼─────────────┼─────────┤\n│ 1   │ Ti L3-M1 + 6 others  │ 0.0198879   │ 0.0198207   │ 1.09848 │\n│ 2   │ O K-L3 + 1 other     │ 0.487604    │ 0.0108249   │ 1.60845 │\n│ 3   │ Fe L3-M5 + 11 others │ 0.000108498 │ 0.00332882  │ 1.18967 │\n│ 4   │ Zn L3-M5 + 11 others │ 0.0681498   │ 0.00163788  │ 1.11024 │\n│ 5   │ Ge L3-M5 + 11 others │ 0.179276    │ 0.00215881  │ 1.22199 │\n│ 6   │ Al K-L3 + 1 other    │ 0.028042    │ 0.000662935 │ 1.32494 │\n│ 7   │ Si K-L3 + 2 others   │ 0.021385    │ 0.000779885 │ 1.52041 │\n│ 8   │ Ca K-L3 + 3 others   │ 0.121388    │ 0.00245005  │ 1.45269 │\n│ 9   │ Ti K-L3 + 3 others   │ 0.0643558   │ 0.00145958  │ 1.31191 │\n│ 10  │ Fe K-L3 + 1 other    │ 0.000211471 │ 0.000985644 │ 1.38669 │\n│ 11  │ Fe K-M3 + 3 others   │ 0.00135368  │ 0.00704875  │ 1.38524 │\n│ 12  │ Zn K-L3 + 1 other    │ 0.111538    │ 0.0043262   │ 1.53091 │\n│ 13  │ Zn K-M3 + 3 others   │ 0.12435     │ 0.0159864   │ 1.0181  │\n│ 14  │ Ge K-L3 + 1 other    │ 0.263421    │ 0.00674357  │ 1.28345 │\n│ 15  │ Ge K-M3 + 3 others   │ 0.271331    │ 0.024383    │ 1.27734 │","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Repeat for the 15 measured spectra.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"res= map(s->fit(s,filt,frs,false),unks)\ndisplay(asa(DataFrame, res, withUnc=true))","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"15×31 DataFrame. Omitted printing of 28 columns\n│ Row │ Spectra      │ Ti L3-M1 + 6 others │ ΔTi L3-M1 + 6 others │\n│     │ String       │ Float64             │ Float64              │\n├─────┼──────────────┼─────────────────────┼──────────────────────┤\n│ 1   │ ADM-6005a_1  │ 0.0196054           │ 0.00180556           │\n│ 2   │ ADM-6005a_2  │ 0.0205038           │ 0.00180706           │\n│ 3   │ ADM-6005a_3  │ 0.0210448           │ 0.00180574           │\n│ 4   │ ADM-6005a_4  │ 0.0192692           │ 0.00180754           │\n│ 5   │ ADM-6005a_5  │ 0.0198068           │ 0.00180735           │\n│ 6   │ ADM-6005a_6  │ 0.02261             │ 0.00180528           │\n│ 7   │ ADM-6005a_7  │ 0.0216214           │ 0.00181203           │\n│ 8   │ ADM-6005a_8  │ 0.0196484           │ 0.00180842           │\n│ 9   │ ADM-6005a_9  │ 0.0207842           │ 0.00181029           │\n│ 10  │ ADM-6005a_10 │ 0.0246116           │ 0.00180559           │\n│ 11  │ ADM-6005a_11 │ 0.0200949           │ 0.00180473           │\n│ 12  │ ADM-6005a_12 │ 0.0203895           │ 0.00181218           │\n│ 13  │ ADM-6005a_13 │ 0.0166997           │ 0.00181286           │\n│ 14  │ ADM-6005a_14 │ 0.0185332           │ 0.00180978           │\n│ 15  │ ADM-6005a_15 │ 0.0190233           │ 0.0018089            │","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"display(describe(res))","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"15×9 DataFrame. Omitted printing of 5 columns\n│ Row │ variable             │ mean        │ std         │ hetero   │\n│     │ Symbol               │ Float64     │ Float64     │ Float64  │\n├─────┼──────────────────────┼─────────────┼─────────────┼──────────┤\n│ 1   │ Ti L3-M1 + 6 others  │ 0.0202831   │ 0.001822    │ 1.00762  │\n│ 2   │ O K-L3 + 1 other     │ 0.488676    │ 0.00107014  │ 1.58799  │\n│ 3   │ Fe L3-M5 + 11 others │ -3.47302e-5 │ 0.000195397 │ 0.70211  │\n│ 4   │ Zn L3-M5 + 11 others │ 0.0680583   │ 0.000195188 │ 1.3214   │\n│ 5   │ Ge L3-M5 + 11 others │ 0.17952     │ 0.000233079 │ 1.31832  │\n│ 6   │ Al K-L3 + 1 other    │ 0.028089    │ 7.81106e-5  │ 1.5598   │\n│ 7   │ Si K-L3 + 2 others   │ 0.021408    │ 6.05531e-5  │ 1.18048  │\n│ 8   │ Ca K-L3 + 3 others   │ 0.121378    │ 0.000211966 │ 1.25601  │\n│ 9   │ Ti K-L3 + 3 others   │ 0.0640056   │ 0.000138698 │ 1.24712  │\n│ 10  │ Fe K-L3 + 1 other    │ 0.000304368 │ 7.49407e-5  │ 1.05494  │\n│ 11  │ Fe K-M3 + 3 others   │ 0.000862063 │ 0.000872152 │ 1.7128   │\n│ 12  │ Zn K-L3 + 1 other    │ 0.111292    │ 0.000275447 │ 0.974508 │\n│ 13  │ Zn K-M3 + 3 others   │ 0.12257     │ 0.00254018  │ 1.61918  │\n│ 14  │ Ge K-L3 + 1 other    │ 0.262915    │ 0.000743333 │ 1.41475  │\n│ 15  │ Ge K-M3 + 3 others   │ 0.27565     │ 0.00295048  │ 1.54978  │","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"@btime fit(unks[1], filt, frs, false)","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"4.730 ms (34714 allocations: 19.08 MiB)\nADM-6005a_1","category":"page"},{"location":"K412quick/#Quick-Quantifying-K412-using-NeXLSpectrum-VectorQuant","page":"Fitting K412 (quick fit)","title":"Quick Quantifying K412 using NeXLSpectrum VectorQuant","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Fred Schamber taught me this trick for quantifying spectrum extremely quickly.  If you are willing to overlook the fact that","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Use the NeXLSpectrum to load, plot, fit and report the quantification of a set of K412 spectra.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Loading NeXLSpectrum also automatically makes NeXLCore and NeXLUncertainties available.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Loading the Gadfly library adds plotting support to NeXLSpectrum.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"using NeXLSpectrum              # Provides spectrum reading and fitting tools\nusing NeXLMatrixCorrection      # Provides `quant` to convert k-ratios to mass fraction.\nusing Gadfly                    # Plotting\nusing DataFrames                # Tables","category":"page"},{"location":"K412quick/#Read-in-the-Spectra","page":"Fitting K412 (quick fit)","title":"Read in the Spectra","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"path = \"K412 spectra\"\n# Load a single spectrum\nfe = loadspectrum(joinpath(\"$(path)\", \"Fe std.msa\"))\n# Create a detector model to match it\ndet = matching(fe, 132.0, 10)\n# Now load all the spectra using this detector\nunks = (i->loadspectrum(joinpath(\"$(path)\", \"III-E K412[$i][4].msa\"),det)).(0:4)\nal2o3 = loadspectrum(joinpath(\"$(path)\", \"Al2O3 std.msa\"),det)\ncaf2 = loadspectrum(joinpath(\"$(path)\", \"CaF2 std.msa\"),det)\nfe = loadspectrum(joinpath(\"$(path)\", \"Fe std.msa\"),det)\nmgo = loadspectrum(joinpath(\"$(path)\", \"MgO std.msa\"),det)\nsio2 = loadspectrum(joinpath(\"$(path)\", \"SiO2 std.msa\"),det)\nasa(DataFrame, Spectrum[unks..., al2o3, caf2, fe, mgo, sio2])","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"10×8 DataFrame. Omitted printing of 3 columns\n│ Row │ Name               │ BeamEnergy │ ProbeCurrent │ LiveTime │ RealTim\ne │\n│     │ String             │ Float64?   │ Float64?     │ Float64? │ Float64\n? │\n├─────┼────────────────────┼────────────┼──────────────┼──────────┼────────\n──┤\n│ 1   │ III-E K412[0][all] │ 20000.0    │ 1.11355      │ 235.484  │ 286.279\n  │\n│ 2   │ III-E K412[1][all] │ 20000.0    │ 1.11355      │ 235.433  │ 286.218\n  │\n│ 3   │ III-E K412[2][all] │ 20000.0    │ 1.11172      │ 235.45   │ 286.278\n  │\n│ 4   │ III-E K412[3][all] │ 20000.0    │ 1.10989      │ 235.441  │ 286.281\n  │\n│ 5   │ III-E K412[4][all] │ 20000.0    │ 1.10989      │ 235.399  │ 286.214\n  │\n│ 6   │ Al2O3 std          │ 20000.0    │ 1.10989      │ 1172.19  │ 1491.48\n  │\n│ 7   │ CaF2 std           │ 20000.0    │ 1.10989      │ 1176.1   │ 1456.12\n  │\n│ 8   │ Fe std             │ 20000.0    │ 1.10989      │ 1171.48  │ 1528.75\n  │\n│ 9   │ MgO std            │ 20000.0    │ 1.10637      │ 1175.78  │ 1496.02\n  │\n│ 10  │ SiO2 std           │ 20000.0    │ 1.10989      │ 1173.16  │ 1470.35\n  │","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Notice that the spectra all have 1) live-time (:LiveTime); 2) probe-current (:ProbeCurrent); 3) take-off angle (:TakeOffAngle); 4) beam energy (:BeamEnergy); and detector (:Detector) properties defined.  These properties are necessary for extracting the k-ratios and estimating the composition.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"sio2[:LiveTime], sio2[:ProbeCurrent], sio2[:TakeOffAngle], sio2[:BeamEnergy], sio2[:Detector]","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(1173.1648, 1.10989, 0.6108652381980153, 20000.0, BasicEDS(4096, E[ch] = 1.\n63032 + 9.99856⋅ch, 132.0 eV @ Mn K-L3, 10, Dict{Shell,Element}(Shell[M] =>\n Element(Barium),Shell[N] => Element(Plutonium),Shell[K] => Element(Berylli\num),Shell[L] => Element(Scandium))))","category":"page"},{"location":"K412quick/#The-Unknowns","page":"Fitting K412 (quick fit)","title":"The Unknowns","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"display(plot(unks..., klms=[n\"O\",n\"Mg\",n\"Al\",n\"Si\",n\"Ca\",n\"Fe\"], xmax=8.0e3))","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(Image: )","category":"page"},{"location":"K412quick/#The-Reference-Spectra","page":"Fitting K412 (quick fit)","title":"The Reference Spectra","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Build a convenient structure so it is easy to appreciate the necessary information and to splat it into filteredReference.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"refs = (\n  # spectrum, element, composition\n  ( al2o3, n\"Al\", mat\"Al2O3\" ), #\n  ( mgo,   n\"Mg\", mat\"MgO\" ),   #\n  ( fe,    n\"Fe\", mat\"Fe\" ),    #\n  ( sio2,  n\"Si\", mat\"SiO2\" ),  #\n  ( sio2,  n\"O\",  mat\"SiO2\" ),  #\n  ( caf2,  n\"Ca\", mat\"CaF2\" ), )\ndisplay(plot(al2o3, caf2, fe, mgo, sio2, klms=collect( ref[2] for ref in refs), xmax=8.0e3))","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(Image: )","category":"page"},{"location":"K412quick/#Filter-the-Reference-Spectra-and-Compute-the-VectorQuant-Structure","page":"Fitting K412 (quick fit)","title":"Filter the Reference Spectra and Compute the VectorQuant Structure","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"# Build a top-hat filter\nfilt = buildfilter(det)\n# Filter all the reference spectra\nfrs = mapreduce(ref->filterreference(filt, ref..., withEsc=false), append!, refs)\n# Build the VectorQuant structure from the fitered references and the filter\nvq = VectorQuant(frs, filt)\nplot(vq,1:800)","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(Image: )","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Let's take a look at a residual spectrum by plotting one of the FilterFitResult objects. Perform the fit and look at the residual","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"res = map(unk->fit(vq, unk),unks)\nplot(res[1])","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(Image: )","category":"page"},{"location":"K412quick/#Compare-this-with-the-weighted-fit","page":"Fitting K412 (quick fit)","title":"Compare this with the weighted fit","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"resfull = map(unk->fit(unk,filt,frs,false), unks)\nplot(resfull[1])","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(Image: )","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Now the full data set...","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"display(asa(DataFrame, res, withUnc=true))","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"5×17 DataFrame. Omitted printing of 14 columns\n│ Row │ Spectra            │ O K-L3 + 1 other │ ΔO K-L3 + 1 other │\n│     │ String             │ Float64          │ Float64           │\n├─────┼────────────────────┼──────────────────┼───────────────────┤\n│ 1   │ III-E K412[0][all] │ 0.646724         │ 0.000739683       │\n│ 2   │ III-E K412[1][all] │ 0.648762         │ 0.000740482       │\n│ 3   │ III-E K412[2][all] │ 0.649221         │ 0.000741769       │\n│ 4   │ III-E K412[3][all] │ 0.653725         │ 0.000744853       │\n│ 5   │ III-E K412[4][all] │ 0.652158         │ 0.000744328       │","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"display(asa(DataFrame, resfull, withUnc=true))","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"5×17 DataFrame. Omitted printing of 14 columns\n│ Row │ Spectra            │ O K-L3 + 1 other │ ΔO K-L3 + 1 other │\n│     │ String             │ Float64          │ Float64           │\n├─────┼────────────────────┼──────────────────┼───────────────────┤\n│ 1   │ III-E K412[0][all] │ 0.655621         │ 0.000813387       │\n│ 2   │ III-E K412[1][all] │ 0.657418         │ 0.000814094       │\n│ 3   │ III-E K412[2][all] │ 0.65798          │ 0.000815687       │\n│ 4   │ III-E K412[3][all] │ 0.662417         │ 0.000818765       │\n│ 5   │ III-E K412[4][all] │ 0.660782         │ 0.000818176       │","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Compare the timings (full then fast)","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"using BenchmarkTools\n@btime map(unk->fit(unk,filt,frs,false), unks)","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"15.332 ms (148232 allocations: 64.77 MiB)","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"@btime map(unk->fit(vq, unk),unks)","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"1.685 ms (21417 allocations: 741.55 KiB)\n5-element Array{FilterFitResult,1}:\n III-E K412[0][all]\n III-E K412[1][all]\n III-E K412[2][all]\n III-E K412[3][all]\n III-E K412[4][all]","category":"page"},{"location":"XRFspectra/#Fitting-a-Stainless-Steel-XRF-Spectrum","page":"Fitting XRF Spectra","title":"Fitting a Stainless Steel XRF Spectrum","text":"","category":"section"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"Load the necessary libraries.","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"using NeXLSpectrum\nusing Gadfly           # For plotting. I've added spectrum support.\nusing DataFrames       # For tables.","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"Load the spectra from EMSA files.","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"path = \"XRF Stainless\"\n# We use map to apply `readEMSA` to each of the files\nspecs = steel, fe, ni, cr, ti, si, s, sn = map(fn->loadspectrum(joinpath(path, fn)), (\n  \"Steel_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Fe_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Ni_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Cr_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Ti_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Si_50kv_50_ma_Rh_vac_D1.msa\",\n  \"S_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Sn_50kv_50_ma_Rh_vac_D1.msa\",));\n\nasa(DataFrame, Spectrum[ specs... ])","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"8×8 DataFrame. Omitted printing of 4 columns\n│ Row │ Name                       │ BeamEnergy │ ProbeCurrent │ LiveTime │\n│     │ String                     │ Float64?   │ Float64?     │ Float64? │\n├─────┼────────────────────────────┼────────────┼──────────────┼──────────┤\n│ 1   │ Steel_50kv_50_ma_Rh_vac_D1 │ missing    │ missing      │ 119.973  │\n│ 2   │ Fe_50kv_50_ma_Rh_vac_D1    │ missing    │ missing      │ 120.005  │\n│ 3   │ Ni_50kv_50_ma_Rh_vac_D1    │ missing    │ missing      │ 120.027  │\n│ 4   │ Cr_50kv_50_ma_Rh_vac_D1    │ missing    │ missing      │ 119.994  │\n│ 5   │ Ti_50kv_50_ma_Rh_vac_D1    │ missing    │ missing      │ 120.012  │\n│ 6   │ Si_50kv_50_ma_Rh_vac_D1    │ missing    │ missing      │ 119.986  │\n│ 7   │ S_50kv_50_ma_Rh_vac_D1     │ missing    │ missing      │ 120.013  │\n│ 8   │ Sn_50kv_50_ma_Rh_vac_D1    │ missing    │ missing      │ 119.974  │","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"plot(specs..., xmax=25.0e3,klms=[n\"Fe\",n\"Cr\",n\"Ni\",n\"Ti\", n\"Si\",n\"S\", n\"Mo\", n\"Rh\"])","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"(Image: )","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"display(plot(steel,xmax=25.0e3, yscale=1.1,klms=[n\"Fe\",n\"Cr\",n\"Ni\",n\"Ti\", n\"Si\",n\"S\", n\"Mo\", n\"Rh\"]))","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"(Image: )","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"display(plot(steel,xmax=25.0e3, yscale=0.01,klms=[n\"Fe\",n\"Cr\",n\"Ni\",n\"Ti\", n\"Si\",n\"S\", n\"Mo\", n\"Rh\"]))","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"(Image: )","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"Build the filtered references which will be fit to the steel unknown.","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"# This Dict defines which is the lowest z element which can be measured for the K, L, M, N shells\nfirstelm = Dict(KShell=>n\"Na\", LShell=>n\"Zn\", MShell=>n\"Sm\", NShell=>n\"Og\")\n# Build a detector to match the steel spectrum\ndet = matching(steel, steel[:FWHMMnKa], 120, firstelm)\n# Build a 'VariableWidthFilter' top-hat filter to suit the detector\nfilt = buildfilter(VariableWidthFilter,det)\nrefdata = (\n  # ( spectrum, element, material ), # The ordering of `refdata` allows us to splat it into `filterreference(...)`\n  ( fe, n\"Fe\", mat\"Fe\" ),\n  ( cr, n\"Cr\", mat\"Cr\" ),\n  ( ni, n\"Ni\", mat\"Ni\" ),\n  ( ti, n\"Ti\", mat\"Ti\" ),\n  ( si, n\"Si\", mat\"Si\" ),\n  ( s, n\"S\", mat\"S\" ),\n  ( sn, n\"Sn\", mat\"Sn\" ),\n)\n# Some necessary properties are missing from the spectra so provide them.\nxtra = Dict{Symbol,Any}(:BeamEnergy=>40.0e3, :ProbeCurrent=>1.0, :Detector=>det)\nrefs = FilteredReference[]\nfor rd in refdata\n  append!(refs, filterreference(filt, rd..., props=xtra))\nend\n# Merge the missing properties into the unknown too.\nmerge!(steel, xtra)\nres = fit(steel, filt, refs, false)\n# Tabulate the results\nasa(DataFrame, res)","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"11×10 DataFrame. Omitted printing of 8 columns\n│ Row │ Spectrum                   │ Feature              │\n│     │ UnknownLabel               │ ReferenceLabel       │\n├─────┼────────────────────────────┼──────────────────────┤\n│ 1   │ Steel_50kv_50_ma_Rh_vac_D1 │ Cr K-L3 + 5 others   │\n│ 2   │ Steel_50kv_50_ma_Rh_vac_D1 │ Fe K-L3 + 1 other    │\n│ 3   │ Steel_50kv_50_ma_Rh_vac_D1 │ Fe K-M3 + 3 others   │\n│ 4   │ Steel_50kv_50_ma_Rh_vac_D1 │ Ni K-L3 + 1 other    │\n│ 5   │ Steel_50kv_50_ma_Rh_vac_D1 │ Ni K-M3 + 3 others   │\n│ 6   │ Steel_50kv_50_ma_Rh_vac_D1 │ S K-L3 + 3 others    │\n│ 7   │ Steel_50kv_50_ma_Rh_vac_D1 │ Si K-L3 + 2 others   │\n│ 8   │ Steel_50kv_50_ma_Rh_vac_D1 │ Sn K-L3 + 1 other    │\n│ 9   │ Steel_50kv_50_ma_Rh_vac_D1 │ Sn K-M3 + 7 others   │\n│ 10  │ Steel_50kv_50_ma_Rh_vac_D1 │ Sn L3-M5 + 23 others │\n│ 11  │ Steel_50kv_50_ma_Rh_vac_D1 │ Ti K-L3 + 3 others   │","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"Plot the residual spectrum.  Note that Mo and Rh were not fit and so there remain significant peaks between 16 and 20 keV.","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"plot(res)","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"(Image: )","category":"page"},{"location":"K412fit/#Quantifying-K412-using-NeXLSpectrum-and-NeXLMatrixCorrection","page":"Fitting K412","title":"Quantifying K412 using NeXLSpectrum and NeXLMatrixCorrection","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"Use the NeXLSpectrum to load, plot, fit and report the quantification of a set of K412 spectra.","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"Loading NeXLSpectrum also automatically makes NeXLCore and NeXLUncertainties available.","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"Loading the Gadfly library adds plotting support to NeXLSpectrum.","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"using NeXLSpectrum              # Provides spectrum reading and fitting tools\nusing NeXLMatrixCorrection      # Provides `quant` to convert k-ratios to mass fraction.\nusing Gadfly                    # Plotting\nusing DataFrames                # Tables","category":"page"},{"location":"K412fit/#Read-in-the-Spectra","page":"Fitting K412","title":"Read in the Spectra","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"path = \"K412 spectra\"\n# Load a single spectrum\nfe = loadspectrum(joinpath(path, \"Fe std.msa\"))\n# Create a detector model to match it\ndet = matching(fe, 132.0, 10)\n# Now load all the spectra using this detector\nunks = (i->loadspectrum(joinpath(path, \"III-E K412[$i][4].msa\"),det)).(0:4)\nal2o3 = loadspectrum(joinpath(path, \"Al2O3 std.msa\"),det)\ncaf2 = loadspectrum(joinpath(path, \"CaF2 std.msa\"),det)\nfe = loadspectrum(joinpath(path, \"Fe std.msa\"),det)\nmgo = loadspectrum(joinpath(path, \"MgO std.msa\"),det)\nsio2 = loadspectrum(joinpath(path, \"SiO2 std.msa\"),det)\n# Add carbon coating\nmap(s->s[:Coating]=Film(pure(n\"C\"), 30.0e-7), unks)\nmap(s->s[:Coating]=Film(pure(n\"C\"), 10.0e-7), (al2o3, caf2, mgo, sio2))\nasa(DataFrame, Spectrum[unks..., al2o3, caf2, fe, mgo, sio2])","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"10×8 DataFrame. Omitted printing of 3 columns\n│ Row │ Name               │ BeamEnergy │ ProbeCurrent │ LiveTime │ RealTim\ne │\n│     │ String             │ Float64?   │ Float64?     │ Float64? │ Float64\n? │\n├─────┼────────────────────┼────────────┼──────────────┼──────────┼────────\n──┤\n│ 1   │ III-E K412[0][all] │ 20000.0    │ 1.11355      │ 235.484  │ 286.279\n  │\n│ 2   │ III-E K412[1][all] │ 20000.0    │ 1.11355      │ 235.433  │ 286.218\n  │\n│ 3   │ III-E K412[2][all] │ 20000.0    │ 1.11172      │ 235.45   │ 286.278\n  │\n│ 4   │ III-E K412[3][all] │ 20000.0    │ 1.10989      │ 235.441  │ 286.281\n  │\n│ 5   │ III-E K412[4][all] │ 20000.0    │ 1.10989      │ 235.399  │ 286.214\n  │\n│ 6   │ Al2O3 std          │ 20000.0    │ 1.10989      │ 1172.19  │ 1491.48\n  │\n│ 7   │ CaF2 std           │ 20000.0    │ 1.10989      │ 1176.1   │ 1456.12\n  │\n│ 8   │ Fe std             │ 20000.0    │ 1.10989      │ 1171.48  │ 1528.75\n  │\n│ 9   │ MgO std            │ 20000.0    │ 1.10637      │ 1175.78  │ 1496.02\n  │\n│ 10  │ SiO2 std           │ 20000.0    │ 1.10989      │ 1173.16  │ 1470.35\n  │","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"Notice that the spectra all have 1) live-time (:LiveTime); 2) probe-current (:ProbeCurrent); 3) take-off angle (:TakeOffAngle); 4) beam energy (:BeamEnergy); and detector (:Detector) properties defined.  These properties are necessary for extracting the k-ratios and estimating the composition.","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"sio2[:LiveTime], sio2[:ProbeCurrent], sio2[:TakeOffAngle], sio2[:BeamEnergy], sio2[:Detector]","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"(1173.1648, 1.10989, 0.6108652381980153, 20000.0, BasicEDS(4096, E[ch] = 1.\n63032 + 9.99856⋅ch, 132.0 eV @ Mn K-L3, 10, Dict{Shell,Element}(Shell[M] =>\n Element(Barium),Shell[N] => Element(Plutonium),Shell[K] => Element(Berylli\num),Shell[L] => Element(Scandium))))","category":"page"},{"location":"K412fit/#The-Unknowns","page":"Fitting K412","title":"The Unknowns","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"display(plot(unks..., klms=[n\"O\",n\"Mg\",n\"Al\",n\"Si\",n\"Ca\",n\"Fe\"], xmax=8.0e3))","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"(Image: )","category":"page"},{"location":"K412fit/#The-Reference-Spectra","page":"Fitting K412","title":"The Reference Spectra","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"Build a convenient structure so it is easy to appreciate the necessary information and to splat it into filteredReference.","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"refs = (\n  # spectrum, element, composition\n  ( al2o3, n\"Al\", mat\"Al2O3\" ), #\n  ( mgo,   n\"Mg\", mat\"MgO\" ),   #\n  ( fe,    n\"Fe\", mat\"Fe\" ),    #\n  ( sio2,  n\"Si\", mat\"SiO2\" ),  #\n  ( sio2,  n\"O\",  mat\"SiO2\" ),  #\n  ( caf2,  n\"Ca\", mat\"CaF2\" ), )\ndisplay(plot(al2o3, caf2, fe, mgo, sio2, klms=collect( ref[2] for ref in refs), xmax=8.0e3))","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"(Image: )","category":"page"},{"location":"K412fit/#Pre-filter-the-Reference-Spectra","page":"Fitting K412","title":"Pre-filter the Reference Spectra","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"# Build a top-hat filter\nfilt = buildfilter(NeXLSpectrum.GaussianFilter,det)\n# Filter all the reference spectra\nfrs = mapreduce(ref->filterreference(filt, ref..., withEsc=true), append!, refs)\n# frs is now a FilteredReference[] used to fit the unknowns.","category":"page"},{"location":"K412fit/#Fit-the-Pre-Filtered-References-to-the-Unknowns","page":"Fitting K412","title":"Fit the Pre-Filtered References to the Unknowns","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"res= [ fit(unk,filt,frs,false) for unk in unks ]\nasa(DataFrame, res)","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"5×9 DataFrame. Omitted printing of 6 columns\n│ Row │ Spectra            │ O K-L3 + 1 other │ Fe L3-M5 + 11 others │\n│     │ String             │ Float64          │ Float64              │\n├─────┼────────────────────┼──────────────────┼──────────────────────┤\n│ 1   │ III-E K412[0][all] │ 0.652023         │ 0.0424457            │\n│ 2   │ III-E K412[1][all] │ 0.653953         │ 0.0420769            │\n│ 3   │ III-E K412[2][all] │ 0.654476         │ 0.0424492            │\n│ 4   │ III-E K412[3][all] │ 0.658893         │ 0.0419923            │\n│ 5   │ III-E K412[4][all] │ 0.657297         │ 0.04136              │","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"Let's take a look at a residual spectrum by plotting one of the FilterFitResult objects.","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"plot(res[1])","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"(Image: )","category":"page"},{"location":"K412fit/#Quantify-the-k-ratios-by-Matrix-Correction","page":"Fitting K412","title":"Quantify the k-ratios by Matrix Correction","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"quant = quantify.(res)\nasa(DataFrame, quant)","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"5×8 DataFrame. Omitted printing of 3 columns\n│ Row │ Material           │ O        │ Mg       │ Al        │ Si       │\n│     │ String             │ Abstrac… │ Abstrac… │ Abstract… │ Abstrac… │\n├─────┼────────────────────┼──────────┼──────────┼───────────┼──────────┤\n│ 1   │ III-E K412[0][all] │ 0.429722 │ 0.114789 │ 0.048185  │ 0.207347 │\n│ 2   │ III-E K412[1][all] │ 0.430204 │ 0.114803 │ 0.0480109 │ 0.20688  │\n│ 3   │ III-E K412[2][all] │ 0.430941 │ 0.115058 │ 0.0482529 │ 0.207572 │\n│ 4   │ III-E K412[3][all] │ 0.433338 │ 0.115228 │ 0.0483    │ 0.207982 │\n│ 5   │ III-E K412[4][all] │ 0.432318 │ 0.115281 │ 0.0483845 │ 0.208002 │","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"Finally plot the results as mass fractions.","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"plot(quant, known=unks[1][:Composition])","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"(Image: )","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"Plot the difference from the SRM value.","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"plot(quant, known=unks[1][:Composition], delta=true)","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"(Image: )","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"Plot the difference from the mean value for each element.","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"plot(quant, delta=true)","category":"page"},{"location":"K412fit/","page":"Fitting K412","title":"Fitting K412","text":"(Image: )","category":"page"},{"location":"continuummodel/#Modeling-the-Continuum","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"","category":"section"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"Nicholas W. M. Ritchie 9-Jun-2020","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"Modeling the continuum (Bremsstrahlung) is a necessary component of being able to perform an straight (unfiltered) spectrum fit.  These models can either be used to handle the continuum for linear or non-linear spectrum fits.","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"using NeXLSpectrum\nusing NeXLMatrixCorrection\nusing Gadfly\nusing Colors","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"The ContinuumModel handles the generation of Bremsstrahlung within the sample, the absorption of the generated X-rays as they exit the sample and the efficiency of the detector collecting the X-rays.","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"e0 = 15.0e3\neff = SDDEfficiency(AP33Tabulation(); thickness=0.0370, deadlayer=30.0e-7, entrance=Film(pure(n\"Al\"), 10.0e-7))\n#eff = SDDEfficiency(NoWindow(); thickness=100.0, deadlayer=0.0e-7, entrance=Film(pure(n\"Al\"), 0.0e-7))\ncmod = ContinuumModel(mat\"0.8*Fe+0.15*Cr+0.05*Ni\", e0, deg2rad(40.0))\nplot([ea->emitted(cmod, ea),ea->generated(cmod, ea)],100.0,e0)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"e0 = 5.0e3\ncmod = ContinuumModel(mat\"SiO2\", e0, deg2rad(40.0))\nplot([ea->emitted(cmod, ea),ea->generated(cmod, ea)],100.0,e0)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"det = simpleEDS(4096, 5.0, 0.0, 132.0, 10)\ne0 = 5.0e3\ncmod = ContinuumModel(mat\"0.8*Fe+0.15*Cr+0.05*Ni\", e0, deg2rad(40.0))\nresp = NeXLSpectrum.detectorresponse(det, eff)\nemt = map(ch->ch>=lld(det) ? emitted(cmod,energy(ch,det)) : 0.0,1:channelcount(det))\nmeas =  resp*emt\nlyrs = [ layer(x=energyscale(det), y=emt, Geom.line, Theme(default_color=\"red\")), layer(x=energyscale(det), y=meas, Geom.line) ]\nplot(lyrs..., Coord.cartesian(xmin=0, xmax=e0))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/#Models!!!","page":"Modeling the Continuum","title":"Models!!!","text":"","category":"section"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"model, mc = Castellano2004a, Riveros1993\neff = SDDEfficiency(AP33Tabulation(); thickness=0.0370, deadlayer=30.0e-7, entrance=Film(pure(n\"Al\"), 10.0e-7))\n\nspec = loadspectrum(joinpath(\"K412 spectra\",\"III-E K412[0][4].msa\"))\ndet=matching(spec, 132.0, 10)\nroi = channel(4.5e3,det):channel(6.0e3,det)\n\nspec = loadspectrum(joinpath(\"K412 spectra\",\"III-E K412[0][4].msa\"))\ncmod = ContinuumModel(spec[:Composition], spec[:BeamEnergy], spec[:TakeOffAngle], bremsstrahlung=model)\nemt = map(ch->ch>=lld(det) ? emitted(cmod,energy(ch,det)) : 0.0,1:channelcount(det))\nresp = NeXLSpectrum.detectorresponse(det, eff)\nmeas = resp*emt\n\nplot(layer(x=eachindex(emt),y=emt, Geom.line),layer(x=eachindex(meas),y=meas, Geom.point))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(\"K412 spectra\",\"III-E K412[0][4].msa\"))\nbrem = fitcontinuum(spec, resp, [roi], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 0.0003623235657382984","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nplot(spec, brem, yscale=0.05, xmax=12.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(\"K412 spectra\",\"Al2O3 std.msa\"))\nbrem = fitcontinuum(spec, resp, [roi], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 1.5898069774856187e-5","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"plot(spec, brem, yscale=0.01, xmax=8.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(\"K412 spectra\",\"SiO2 std.msa\"))\nbrem = fitcontinuum(spec, resp, [roi], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 1.5971662200794155e-5","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"plot(spec, brem, yscale=0.01, xmax=8.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(\"K412 spectra\",\"MgO std.msa\"))\nbrem = fitcontinuum(spec, resp, [roi], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 1.583130100441223e-5","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"plot(spec, brem, yscale=0.01, xmax=8.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(\"K412 spectra\",\"CaF2 std.msa\"))\nbrem = fitcontinuum(spec, resp, [roi], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 1.5134094286348814e-5","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"plot(spec, brem, yscale=0.05, xmax=8.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(\"K412 spectra\",\"Fe std.msa\"))\nbrem = fitcontinuum(spec, resp, [ channel(2.0e3,det):channel(4.0e3,det)], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 1.797044940058196e-5","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"plot(spec, brem, yscale=0.05, xmax=8.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(\"K412 spectra\",\"III-E K412[0][4].msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"K412 spectra\",\"Al2O3 std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"K412 spectra\",\"SiO2 std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"K412 spectra\",\"MgO std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"K412 spectra\",\"CaF2 std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"K412 spectra\",\"Fe std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"K412 spectra\",\"Fe std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"spectra\",\"Ag std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.05))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"spectra\",\"Au std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.05))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"spectra\",\"B std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.5))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"spectra\",\"Bi std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.05))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"spectra\",\"BN std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.20))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"\nspec = loadspectrum(joinpath(\"spectra\",\"C std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.05))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#NeXLSpectrum-Microanalytical-X-ray-Spectrum-Analysis","page":"Home","title":"NeXLSpectrum - Microanalytical X-ray Spectrum Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NeXLSpectrum is a set of tools for EDS spectrum processing within the NeXL toolset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [NeXLSpectrum]","category":"page"},{"location":"#NeXLSpectrum.SpectrumFeature","page":"Home","title":"NeXLSpectrum.SpectrumFeature","text":"SpectrumFeature\n\nA union representing the different type of peak-like features (helpful and harmful) that can appear in a spectrum.\n\n\n\n\n\n","category":"constant"},{"location":"#NeXLSpectrum.CharXRayLabel","page":"Home","title":"NeXLSpectrum.CharXRayLabel","text":"CharXRayLabel\n\nA ReferenceLabel<:FilteredLabel  that Represents a reference spectrum associated with a set of characteristic x-rays (CharXRay) objects over a contiguous range of spectrum channels.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.ConstantWidthFilter","page":"Home","title":"NeXLSpectrum.ConstantWidthFilter","text":"ConstantWidthFilter\n\nA top-hat filter that has constant width determined by FWHM at Mn Kα for all channels.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.Detector","page":"Home","title":"NeXLSpectrum.Detector","text":"Detector\n\nAn abstract type defining the characteristics of an X-ray detector.\n\nImplements:\n\nchannelcount(det::Detector)::Int\nscale(det::Detector)::EnergyScale\nresolution(eV::Float64, det::Detector)::Float64 # FWHM at eV\nenergy(ch::Int, det::Detector)::Float64\nchannel(eV::Float64, det::Detector)::Int\nprofile(energy::Float64, xrayE::Float64, det::Detector)\nlld(det::Detector)::Int\nvisible(sf::SpectrumFeature, det::Detector)\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.EDSDetector","page":"Home","title":"NeXLSpectrum.EDSDetector","text":"EDSDetector\n\nTypes extending EDSDetector must have member variables\n\nchannelcount::Int # Number of channels\nscale::EnergyScale # Detector calibration funtion\nresolution::Resolution # Detector lineshape function\nlld::Int # low level discriminator\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.EnergyScale","page":"Home","title":"NeXLSpectrum.EnergyScale","text":"EnergyScale\n\nAn EnergyScale is a way of representing the energy axis associated with X-ray data. The scale may be linear, polynomial or ??? to handle the various different non-linearities that happen with EDS detectors plus we can also handle WDS wavescans.\n\nImplements:\n\nchannel(eV::AbstractFloat, sc::EnergyScale)::Int\nenergy(ch::Int, sc::EnergyScale)::Float64\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.EscapeLabel","page":"Home","title":"NeXLSpectrum.EscapeLabel","text":"EscapeLabel\n\nA ReferenceLabel<:FilteredLabel that Represents a reference spectrum associated with an escape peak from a set of characteristic x-rays (CharXRay) objects over a contiguous range of spectrum channels.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.FilterFitResult","page":"Home","title":"NeXLSpectrum.FilterFitResult","text":"FilterFitResult\n\nRepresents the result of fitting either FilteredUnknownG or FilteredUnknownW to a FilteredUnknown.\n\nStruct elements\n\nlabel::UnknownLabel  # Identifies the unknown\nkratios::UncertainValues # Labeled with ReferenceLabel objects\nroi::UnitRange{Int} # Range of channels fit\nraw::Vector{Float64} # Raw spectrum data\nresidual::Vector{Float64} # Residual spectrum\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.FilteredLabel","page":"Home","title":"NeXLSpectrum.FilteredLabel","text":"FilteredLabel\n\nAn abstract type associated with labels of filtered spectrum data objects.  structs that extend FilteredLabel should have .spec members.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.FilteredReference","page":"Home","title":"NeXLSpectrum.FilteredReference","text":"FilteredReference\n\nRepresents the filtered reference spectrum over an ROI. Carries the minimal data necessary to support filter-fitting a single region-of-interest (continguous range of channles) and computing useful output statistics.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.FilteredUnknown","page":"Home","title":"NeXLSpectrum.FilteredUnknown","text":"FilteredUnknown\n\nA FilteredDatum representing the unknown.  There are two types of FilteredUnknown - FilteredUnknownG and FilteredUnknownW for \"generalized\" and \"weighted\" model unknowns.  The distinction is desirable since the full covariance calculation for the generalized model is so expensive relative to the weighted approximation.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.FilteredUnknownG","page":"Home","title":"NeXLSpectrum.FilteredUnknownG","text":"FilteredUnknownG\n\nRepresents the unknown in a filter fit using the full generalized fitting model.  This model is expensive to calculate but uses the full generalized linear fitting model which produces the correct fit covariances.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.FilteredUnknownW","page":"Home","title":"NeXLSpectrum.FilteredUnknownW","text":"FilteredUnknownW\n\nRepresents the unknown in a filter fit using the weighted fitting model.  This is an approximation that produces over optimistic resulting covariance matrix.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.GaussianFilter","page":"Home","title":"NeXLSpectrum.GaussianFilter","text":"GaussianFilter\n\nA Gaussian-shaped filter that varies in width with the FWHM of the detector.  The Gaussian is offset to ensure the sum of the filter elements is zero.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.HyperSpectrum","page":"Home","title":"NeXLSpectrum.HyperSpectrum","text":"HyperSpectrum\n\nHyperSpectrum is a wrapper around Signal to facilitate access to the the data as Spectrum objects.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.HyperSpectrumLabel","page":"Home","title":"NeXLSpectrum.HyperSpectrumLabel","text":"HyperSpectrumLabel\n\nA Label that represents a single spectrum with a HyperSpectrum.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.HyperspectrumQuant","page":"Home","title":"NeXLSpectrum.HyperspectrumQuant","text":"HyperspectrumQuant\n\nRepresents the result from a fit(...) of a HyperSpectrum object.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.LinearEnergyScale","page":"Home","title":"NeXLSpectrum.LinearEnergyScale","text":"LinearEnergyScale\n\nAn EnergyScale implementation parameterized by channel width and offset.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.NoScaling","page":"Home","title":"NeXLSpectrum.NoScaling","text":"Don't scale the spectrum data.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.PolyEnergyScale","page":"Home","title":"NeXLSpectrum.PolyEnergyScale","text":"PolyEnergyScale\n\nAn energy scale based on a polynomial function of the channel index.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.ReferenceLabel","page":"Home","title":"NeXLSpectrum.ReferenceLabel","text":"ReferenceLabel\n\nA label associated with reference spectra.  The label encapsulates the original spectrum and the range of channels represented by this reference object.  structs that extend ReferenceLabel should have .roi and .spec members.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.Resolution","page":"Home","title":"NeXLSpectrum.Resolution","text":"Resolution\n\nAn abstract type describing the channel dependence of the resolution of an EDS detector.\n\nImplements:\n\nresolution(eV::Float64, res::Resolution)::Float # Resolution at specified energy\nprofile(energy::Float64, xrayE::Float64, res::Resolution) # Amplitude for a signal at the specified energy at the specified energy\nextent(xrayE::Float64, res::Resolution, ampl::Float64)::Tuple{2,Float} # The range of channels over which the signal exceeds ampl\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.ScaleDose","page":"Home","title":"NeXLSpectrum.ScaleDose","text":"Scale to a constant dose (Counts/(nA⋅s)).   Requires a spectrum has both :ProbeCurrent & :LiveTime.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.ScaleDoseWidth","page":"Home","title":"NeXLSpectrum.ScaleDoseWidth","text":"Scale to a constant dose⋅width (Counts/(nA⋅s/eV))  Requires a spectrum has both :ProbeCurrent & :LiveTime.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.ScalePeak","page":"Home","title":"NeXLSpectrum.ScalePeak","text":"Scale to a fixed peak intensity\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.ScaleROISum","page":"Home","title":"NeXLSpectrum.ScaleROISum","text":"Scale to a default sum in the specified ROI.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.ScaleSum","page":"Home","title":"NeXLSpectrum.ScaleSum","text":"Scale to a fixed total integral.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.ScaleWidth","page":"Home","title":"NeXLSpectrum.ScaleWidth","text":"Scale to a constant dose⋅width (Counts/(nA⋅s/eV))  Requires a spectrum has both :ProbeCurrent & :LiveTime.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.Signal","page":"Home","title":"NeXLSpectrum.Signal","text":"Signal\n\nThe multidimensional equivalent of Spectrum.  A megapixel spectrum image might be constructed as Signal(energy, props, (4096, 1024, 2048)) where there are 4096 channels, 1024 rows and 2048 columns.  HyperSpectra may be 1, 2, .. N dimensional but since they reside in memory, there are practical limits.\n\nA type for data sets containing multiple closely related spectra.  A Signal is slighly more restricted than an Array{Spectrum,N} because all the Spectra in a Signal are assumed to have certain properties in common -  the EnergyScale and a set of common Spectrum properties.  You can also specify an efficient packing of the data by using UInt8, UInt16, ... etc as required to hold the data.\n\nSignal maintains the data as an abstract array but provides functions to extract individual points or sets of points as Spectrum.\n\nSpecial property tags:\n\n:Elapse  # Total elapse time for map (so sig[:RealTime] ≈ sig[:Elapse]/length(sig)\n:Axes # Names for axes [ \"Data\", \"Y\", \"X\" ]\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.Spectrum","page":"Home","title":"NeXLSpectrum.Spectrum","text":"Spectrum\n\nA structure to hold spectrum data (energy scale, counts and metadata). Spectrum implements indexing using various different mechanisms.  If spec is a Spectrum then\n\nspec[123] # will return the number of counts in channel 123\nspec[123:223] # will return a Vector of counts from channel 123:223\nspec[134.] # will return the number of counts in the channel at energy 134.0 eV\nspec[134.0:270.0] # will return a Vector of counts for channels with energies between 134.0 eV and 270.0 eV\nspec[:Comment] # will return the property named :Comment\n\nMetadata is identified by a symbol. Predefined symbols include\n\n:BeamEnergy    # In eV\n:Elevation     # In radians\n:TakeOffAngle  # In radians (Detector position)\n:Azimuthal     # In radians (Detector position)\n:WorkingDistance # In cm\n:LiveTime      # In seconds\n:RealTime      # In seconds\n:ProbeCurrent  # In nano-amps\n:Name          # A string\n:Owner         # A string\n:StagePosition # A Dict{Symbol,Real} with entries :X, :Y, :Z, :R, :T, B: in cm and degrees\n:Comment       # A string\n:Composition   # A Material (known composition, not measured)\n:Elements      # A collection of elements in the material\n:ReferenceROIS # A collection of reference ROIs (as Vector{ReferenceROI})\n:Detector      # A Detector like a BasicEDS or another EDSDetector\n:Filename      # Source filename\n:Coating       # A Film or Film[] (eg. 10 nm of C|Au etc.)\n:AcquisitionTime # Date and time of acquisition (DateTime struct)\n:Signature     # Dict{Element,Real} with the \"particle signature\"\n\nLess common items:\n\n:ImageMag\t   # Magnification (assuming a 3.5\" image) of the first image\n:ImageZoom     # Additional zoom for second image in a two image TIFF\n:Operator      # Analyst in ASPEX TIFF files\n:Image1, :Image2 ... # Images associated with the spectrum\n:BrukerThroughtput # Nominal throughtput setting on a Bruker detector\n:DetectorSerialNumber # EDS detector serial number\n:DetectorModel # Vendor model name\n:DetectorThickness # Thickness of detector active area\n:DeadLayerThickness # Thickness of Si dead layer on the entrance surface of the detector\n:Window        # Window construction details\n:DetectorSolidAngle # Collection solid angle of the X-ray detector\n:ChamberPressure # Vacuum presure in the sample chamber\n:ChamberAtmosphere # Nominally the composition of the residual gas in the chamber\n\nXRF related items:\n\n:BeamEnergy  # Accelarating voltage within X-ray tube (eV)\n:XRFTubeAnode]    # Element from which the X-ray tube is constructed\n:ProbeCurrent]  # Electron current in the X-ray tube\n:XRFTubeIncidentAngle # Incident angle of electron beam in tube\n:XRFTubeTakeOffAngle # Take-off angle from tube\n:XRFExcitationAngle # Angle of incidence of the X-ray beam on the sample\n:XRFDetectionAngle # Angle of the detector relative to the sample\n:XRFExcitationPathLength # Distance from X-ray source to sample\n:XRFDetectionPathLength # Distance from the sample to the X-ray detector\n:XRFSampleTilt    #  Additional tilt of the sample\n:XRFTubeWindow]   # Construction of the tube window\n\nNot all spectra will define all properties.  Algorithms can define the NeXLCore.minproperties(ty::Type) method to specify which properties are required by an algorithm of ty::Type.  Then hasminrequired and requiredbutmissing methods will determine whether a Spectrum or Dict{Symbol,Any} is suitable for an algorithm.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.SpectrumScaling","page":"Home","title":"NeXLSpectrum.SpectrumScaling","text":"SpectrumScaling types are designed to rescale spectrum data primarily for plotting.\n\nImplement\n\nBase.show(io::IO, scn::SpectrumScaling)\nscalefactor(sc::SpectrumScaling, spec::Spectrum)\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.TopHatFilter","page":"Home","title":"NeXLSpectrum.TopHatFilter","text":"The TopHatFilter struct represents a zero-sum symmetric second-derivative-like filter that when applied to spectral data has the property of suppressing constant and slowly varying signals (like the continuum) while retaining a linear signal for faster changing signals like the characteristic peaks.\n\nSee\n\nF. H. Schamber Proc Symposium of \"X-ray Fluorscence Analysis on Environmental Samples\" Chapel Hill 1976 T Dzubay Ed.\nP. Statham Anal Chem 49 no 14 Dec 1977\n\nThe TopHatFilter struct optimizes the memory and CPU use when applying top-hat filters to spectrum data.\n\nThe easiest way to implement a top-hat filter is as matrix F.  The rows represent the filters.  The product of the filter and the data vector is the filtered spectrum.  The product of the filter times a diagnonal matrix constructed from the data times the transpose of the filter is the covariance of the filtered data.  The diagonal matrix constructed from the spectrum data is the covariance matrix associated with the spectrum data because the channels in the spectrum data are independent (thus the matrix is diagnonal) and the magnitude equals the counts in each channels because the spectrum data is nominally Poissonian and in the large number limit, the variance of a Poissonian random variable is the number itself (σ=sqrt(N) => Var = N)\n\nNotes on memory and code optimization: The filter matrix is banded diagonal.  Approximately, 2.5% of the elements are non-zero.  This suggest use of the BandedMatrix type.  The most expensive operation is calculating F⋅D⋅Fᵀ, the covariance matrix of the filtered data. D is a diagonal matrix and so computing each element in F⋅D⋅Fᵀ reduces to a sum over a single variable. Furthermore, the weighted least squares fit doesn't require the full F⋅D⋅Fᵀ, just diag(F⋅D⋅Fᵀ).  However, it turns out that we can do better implementing our own banded matrix type largely because D is fully diagonal and the matrix product F⋅D⋅Fᵀ reduces down to a sum over a single variable.  The product F⋅d and F⋅D⋅Fᵀ are readily implemented as element-by-element multiplies and sums.  Thus storing the filter as offsets and row filters is efficient in both memory and CPU use.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.TopHatFilterType","page":"Home","title":"NeXLSpectrum.TopHatFilterType","text":"TopHatFilterType\n\nRepresents different fitting filter models.  A fitting filter is a linear operator that is 1) symmetric about the center, and 2) the sum of the elements must be zero.  The standard filter is a top-hat shape, although Gaussian, triangular, Savitsky-Golay and other shapes are also possible.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.UnknownLabel","page":"Home","title":"NeXLSpectrum.UnknownLabel","text":"UnknownLabel\n\nA FilteredLabel that represents the unknown spectrum.\n\n\n\n\n\n","category":"type"},{"location":"#NeXLSpectrum.VariableWidthFilter","page":"Home","title":"NeXLSpectrum.VariableWidthFilter","text":"VariableWidthFilter\n\nA top-hat filter that varies in width with the FWHM of the detector.\n\n\n\n\n\n","category":"type"},{"location":"#Base.findmax-Tuple{Spectrum,UnitRange{Int64}}","page":"Home","title":"Base.findmax","text":"findmax(spec::Spectrum, chs::UnitRange{Int})\n\nReturns the (maximum intensity, channel index) over the specified range of channels\n\n\n\n\n\n","category":"method"},{"location":"#Base.findmax-Tuple{Spectrum}","page":"Home","title":"Base.findmax","text":"findmax(spec::Spectrum)\n\nReturns the (maximum intensity, channel index) over all channels\n\n\n\n\n\n","category":"method"},{"location":"#Base.sum-Tuple{HyperSpectrum,Function}","page":"Home","title":"Base.sum","text":"sum(sig::Signal, filt::Function)\n\nProduce a sum Spectrum from those pixels for which filt(hss, idx)==true.\n\n\n\n\n\n","category":"method"},{"location":"#Base.sum-Tuple{HyperSpectrum}","page":"Home","title":"Base.sum","text":"sum(hss::HyperSpectrum)\n\nProduce a sum spectrum.\n\n\n\n\n\n","category":"method"},{"location":"#Base.sum-Tuple{Signal,Function}","page":"Home","title":"Base.sum","text":"sum(sig::Signal, filt::Function)\n\nProduce a sum vector from those pixels for which filt(hss, idx)==true where idx is an index over the dimensions 2:end.\n\n\n\n\n\n","category":"method"},{"location":"#Base.sum-Tuple{Signal}","page":"Home","title":"Base.sum","text":"sum(sig::Signal)\n\nComputes the sum at each data index over all non-data axes.\n\n\n\n\n\n","category":"method"},{"location":"#Gadfly.plot","page":"Home","title":"Gadfly.plot","text":"plot(fd::FilterFitResult, roi::Union{Missing,UnitRange{Int}} = missing; palette = NeXLCore.NeXLPalette)\n\nPlot the fit spectrum and the fit residuals along with the fit ROIs and the associated k-ratios.\n\n\n\n\n\n","category":"function"},{"location":"#Gadfly.plot-Tuple{AbstractArray{Spectrum,1}}","page":"Home","title":"Gadfly.plot","text":"Gadfly.plot(spec::AbstractVector{Spectrum{<:Real}}; klms=[], xmin=0.0, xmax=nothing)::Plot\n\nPlot a Vector of Spectrum using Gadfly.  klms is a Vector of CharXRays or Elements.\n\n\n\n\n\n","category":"method"},{"location":"#Gadfly.plot-Tuple{Vararg{Spectrum{#s94} where #s94<:Real,N} where N}","page":"Home","title":"Gadfly.plot","text":"plot(\n    specs::Spectrum...;\n    klms=[],\n    edges=[],\n\tescapes=[],\n\tcoincidences=[],\n    autoklms = false,\n    xmin=0.0,\n    xmax=missing,\n    norm=:None,\n    yscale=1.05,\n    ytransform = identity,\n\tstyle=NeXLSpectrumStyle,\n\tpalette=NeXLCore.NeXLPalette\n)::Plot\n\nPlot a multiple spectra on a single plot using Gadfly. Required:\n\nspecs::AbstractVector{Spectrum};\n\nNamed:\n\nklms = [ Element &| CharXRay ]\nedges = [ Element &| AtomicSubShell ]\nescapes = [ CharXRay ],\ncoincidences = [ CharXRay ]\nautoklms = false # Add KLMs based on elements in spectra\nxmin = 0.0 # Min energy (eV)\nxmax = missing # Max energy (eV) (defaults to max(:BeamEnergy))\nnorm = NoScaling() | ScaleDoseWidth() | ScaleDose() | ScaleSum() | ScaleROISum() | ScalePeak() | (<: SpectrumScaling)()\nyscale = 1.05 # Fraction of max intensity for ymax over [max(lld,xmin):xmax]\nytransform = identity | log10 | sqrt | ??? # How to transform the counts data before plotting\nstyle=NeXLSpectrumStyle (or another Gadfly.style)\npalette = NeXLCore.NeXLPalette | NeXLCore.NeXLColorblind | Colorant[ ... ] # Colors for spectra...\ncustomlayers = Gadfly.Layer[] # Allows additional plot layers to be added\n\n\n\n\n\n","category":"method"},{"location":"#NeXLCore.elms","page":"Home","title":"NeXLCore.elms","text":"elms(spec::Spectrum, withcoating = false, def=missing)\n\nReturns a list of the elements associated with this spectrum. withcoating determines whether the coating elements are also added.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLCore.energy-Tuple{Int64,EDSDetector}","page":"Home","title":"NeXLCore.energy","text":"energy(ch::Int, det::EDSDetector)\n\nEnergy of the low-energy side of the ch-th detector bin.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLCore.energy-Tuple{Int64,LinearEnergyScale}","page":"Home","title":"NeXLCore.energy","text":"energy(ch::Integer, sc::LinearEnergyScale)\n\nReturns the energy (in eV) for the low energy side of the bin representing the ch-th channel.\n\nExample:\n\nles = LinearEnergyScale(3.0, 10.1)\nenergy(101,lsc) == 10.1*101 + 3.0\nenergy(101,lsc) - energy(100,lsc) == 10.1\n\n\n\n\n\n","category":"method"},{"location":"#NeXLCore.energy-Tuple{Int64,Spectrum}","page":"Home","title":"NeXLCore.energy","text":"NeXLCore.energy(ch::Int, spec::Spectrum)\n\nThe energy of the start of the ch-th channel.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLCore.energy-Tuple{Integer,NeXLSpectrum.PolyEnergyScale}","page":"Home","title":"NeXLCore.energy","text":"energy(ch::Integer, sc::PolyEnergyScale)\n\nReturns the energy (in eV) for the low energy side of the bin representing the ch-th channel.\n\nExample:\n\npes = PolyEnergyScale([ 3.0, 10.1, 0.001])\nenergy(101,pes) ==  3.0 + 10.0*101 + 0.001*101^2\n\n\n\n\n\n","category":"method"},{"location":"#NeXLCore.weight","page":"Home","title":"NeXLCore.weight","text":"weight(esc::EscapeArtifact, factor=0.01)\n\nThe weight of an EscapeArtifact which is factor * weight(esc.xray).\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.AP33Tabulation-Tuple{}","page":"Home","title":"NeXLSpectrum.AP33Tabulation","text":"AP33Tabulation()\nAP5Tabulation()\n\nConstruct tabulated window models for the Moxtek AP3.3 and AP5 windows.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.Beryllium","page":"Home","title":"NeXLSpectrum.Beryllium","text":"Beryllium(thickness=5.0e-4)\n\nConstruct a beryllium window.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum._filter-Tuple{Spectrum,UnitRange{Int64},TopHatFilter,Float64}","page":"Home","title":"NeXLSpectrum._filter","text":"_filter(\n  spec::Spectrum,\n  roi::UnitRange{Int},\n  thf::TopHatFilter,\n  tol::Float64\n)::FilteredReference\n\nFor filtering an ROI on a reference spectrum. Process a portion of a Spectrum with the specified filter.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.ashyperspectrum","page":"Home","title":"NeXLSpectrum.ashyperspectrum","text":"HyperSpectrum\n\nConvert the Array{<:Real, N} perspective into a Array{Spectrum{<:Real}, N} perspective.\n\nSpecial property tags:\n\n:Cartesian # The pixel index of a Spectrum extracted from a HyperSpectrum\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.asimage-Tuple{HyperspectrumQuant,Int64}","page":"Home","title":"NeXLSpectrum.asimage","text":"asimage(vqr::HyperspectrumQuant, idx::Int; transform=identity)\n\nCreate an image that represents the data associated with the idx label. transform is a function nominally from x -> [0,1] which is applied to the raw quantified results.\n\nExamples:\n\ntransform=x->0.8x                  # linear scaling\ntransform=x->log10(1.0+99.0x)/2.0  # log scaling\ntransform=x->1.0-x                 # invert\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.background-Tuple{Spectrum,UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.background","text":"background(spec::Spectrum, chs::UnitRange{Int}, ash::AtomicSubShell)::Float64\n\nEstimates the background intensity for the characteristic X-ray in the specified range of channels.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.buildfilter","page":"Home","title":"NeXLSpectrum.buildfilter","text":"buildfilter(::Type{<:TopHatFilterType}, det::Detector, a::Float64=1.0, b::Float64=1.0)::TopHatFilter\n\nBuild a top-hat-style filter for the specified detector with the specified top and base parameters. The VariableWidthFilter and ConstantWidthFilter types are currently supported.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.buildfilter-2","page":"Home","title":"NeXLSpectrum.buildfilter","text":"buildfilter(::Type{GaussianFilter}, det::Detector, a::Float64=1.0, b::Float64=5.0)::TopHatFilter\n\nBuild a top-hat filter with Gaussian shape whose width varies with the detector's resolution as a function of X-ray energy for the specified detector with the specified top and base parameters. The a parameter corresponds to the filter width relative to the detector resolution expressed as Gaussian width.  So a=1 is a filter whose width equals the detector resolution at each energy.  The b parameter is the extent of the filter in Gaussian widths.  The default a=1, b=5 corresponds to a  filter that has the same resolution as the detector and an extent of 2.5 Gaussian widths above and below the center channel.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.buildfilter-3","page":"Home","title":"NeXLSpectrum.buildfilter","text":"buildfilter(det::Detector, a::Float64=1.0, b::Float64=2.0)::TopHatFilter\n\nBuild the default top-hat filter for the specified detector with the specified top and base parameters.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.channel-Tuple{AbstractFloat,LinearEnergyScale}","page":"Home","title":"NeXLSpectrum.channel","text":"channel(eV::AbstractFloat, sc::LinearEnergyScale)\n\nReturns the integer index of the channel for the specified energy X-ray (in\n\neV).\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.channel-Tuple{AbstractFloat,NeXLSpectrum.PolyEnergyScale}","page":"Home","title":"NeXLSpectrum.channel","text":"channel(eV::AbstractFloat, sc::PolyEnergyScale)\n\nReturns the integer index of the channel for the specified energy X-ray (in\n\neV).\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.channel-Tuple{Float64,EDSDetector}","page":"Home","title":"NeXLSpectrum.channel","text":"channel(eV::Float64, det::EDSDetector)\n\nThe channel index in which the specified energy X-ray belongs.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.channel-Tuple{Float64,Spectrum}","page":"Home","title":"NeXLSpectrum.channel","text":"channel(eV::Float64, spec::Spectrum)\n\nThe index of the channel containing the specified energy.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.channelcount-Tuple{EDSDetector}","page":"Home","title":"NeXLSpectrum.channelcount","text":"channelcount(det::EDSDetector)\n\nNumber of detector channels.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.channels-Tuple{ReferenceLabel}","page":"Home","title":"NeXLSpectrum.channels","text":"channels(rl::ReferenceLabel)::UnitRange{Int}\n\nThe range of channels associated with the specified ReferenceLabel.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.channelwidth-Tuple{Int64,Spectrum}","page":"Home","title":"NeXLSpectrum.channelwidth","text":"channelwidth(ch::Int, spec::Spectrum)::Float64\n\nReturns the width of the ch channel\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.charXRayLabels","page":"Home","title":"NeXLSpectrum.charXRayLabels","text":"charXRayLabels(#\n  spec::Spectrum, #\n  elm::Element, #\n  allElms::AbstractVector{Element}, #\n  det::Detector, #\n  ampl::Float64, #\n  maxE::Float64=1.0e6)::Vector{SpectrumFeature}\n\nCreates a vector CharXRayLabel objects associated with 'elm' for a spectrum containing the elements 'allElms' assuming that it was collected on 'det'.  ROIs in which other elements from 'allElms' interfere with 'elm' will not be included.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.characteristiccounts-Tuple{FilterFitResult,Any}","page":"Home","title":"NeXLSpectrum.characteristiccounts","text":"characteristiccounts(ffr::FiterFitResult, strip)\n\nNumber of spectrum counts that were accounted for by the fitted elements with the strip Element(s) removed.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.compressed-Tuple{Signal}","page":"Home","title":"NeXLSpectrum.compressed","text":"compressed(sig::Signal)\n\nReturns a Signal with smaller or equal storage space to sig without losing any infomation.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.continuumrois-Tuple{Any,EDSDetector,Float64,Float64}","page":"Home","title":"NeXLSpectrum.continuumrois","text":"continuumrois(elms, det::EDSDetector, minE::Float64, maxE::Float64)\n\nCompute the ROIs for the contiguous continuum regions for the specified elements elms on an EDSDetector for the specified range of energies.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.counts-Union{Tuple{T}, Tuple{Spectrum,UnitRange{Int64},Type{T}}, Tuple{Spectrum,UnitRange{Int64},Type{T},Any}} where T<:Real","page":"Home","title":"NeXLSpectrum.counts","text":"counts(spec::Spectrum, channels::UnitRange{Int}, numType::Type{T}, applyLLD=false)::Vector{T} where {T<:Number}\n\nCreates a copy of the spectrum counts data as the specified Number type.  If the spectrum has a :Detector property then the detector's lld (low-level discriminator) and applyLLD=true then the lld is applied to the result by setting all channels less-than-or-equal to det.lld to zero.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.counts-Union{Tuple{T}, Tuple{Spectrum}, Tuple{Spectrum,Type{T}}, Tuple{Spectrum,Type{T},Any}} where T<:Number","page":"Home","title":"NeXLSpectrum.counts","text":"counts(spec::Spectrum, numType::Type{T}, applyLLD=false)::Vector{T} where {T<:Number}\n\nCreates a copy of the spectrum counts data as the specified Number type. If the spectrum has a :Detector property then the detector's lld (low-level discriminator) and applyLLD=true then the lld is applied to the result by setting all channels less-than-or-equal to det.lld to zero.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.details-Tuple{IO,Spectrum}","page":"Home","title":"NeXLSpectrum.details","text":"details(io, spec::Spectrum)\n\nOutputs a description of the data in the spectrum.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.details-Tuple{Spectrum}","page":"Home","title":"NeXLSpectrum.details","text":"details(spec::Spectrum)\n\nOutputs a description of the data in the spectrum to standard output.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.detectorresponse","page":"Home","title":"NeXLSpectrum.detectorresponse","text":"detectorresponse(det::EDSDetector, eff::DetectorEfficiency, incidence::Float64=π/2)::AbstractMatrix\n\nBuild a matrix which models the detector response including aspects like the detector efficiency, the resolution, the escape peaks.  All the warts that can be modeled within a linear model but not things like coincidence peaks that are non-linear.  This function can (!should!) be specialized for more sophisticated detector models that include more warts.\n\nExample:\n\ngenint = computegeneratedintensity(....) # Either characteristic or Bremsstrahlung...\ndet = simpleEDS(4096, 5.0, 0.0, 132.0, 10)\neff = SDDEfficiency(AP33Tabulation(); thickness=0.0370, deadlayer=30.0e-7, entrance=Film(pure(n\"Al\"), 10.0e-7))\nresp = detectorresponse(det, eff)\n# finally compute the measured signal\nmeasured = genint*resp\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.dose-Tuple{Spectrum,Union{Missing, Float64}}","page":"Home","title":"NeXLSpectrum.dose","text":"dose(spec::Spectrum, def=missing)\n\nThe probe dose in nano-amp seconds\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.emitted-Tuple{ContinuumModel,Float64}","page":"Home","title":"NeXLSpectrum.emitted","text":"emitted(cm::ContinuumModel, ea::Float64)\n\nCompute the intensity of the measured continuum emitted from the material and conditions specified in the continuum model object at the specified measured energy ea.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.energyscale-Tuple{EnergyScale,Any}","page":"Home","title":"NeXLSpectrum.energyscale","text":"energyscale(es::EnergyScale, channels)\n\nComputes the energy associated with a range of channel indexes and returns it as an Array.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.energyscale-Tuple{Spectrum}","page":"Home","title":"NeXLSpectrum.energyscale","text":"energyscale(spec::Spectrum)\n\nReturns an array with the bin-by-bin energies\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.escapeLabels","page":"Home","title":"NeXLSpectrum.escapeLabels","text":"escapeLabels(#\n  spec::Spectrum, #\n  elm::Element, #\n  allElms::AbstractVector{Element}, #\n  det::Detector, #\n  ampl::Float64, #\n  maxE::Float64=1.0e6)::Vector{CharXRayLabel}\n\nCreates a vector CharXRayLabel objects associated with 'elm' for a spectrum containing the elements 'allElms' assuming that it was collected on 'det'.  ROIs in which other elements from 'allElms' interfere with 'elm' will not be included.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.escapeextents-Union{Tuple{T}, Tuple{AbstractArray{T,1},Detector,Float64,Float64}, Tuple{AbstractArray{T,1},Detector,Float64,Float64,CharXRay}, Tuple{AbstractArray{T,1},Detector,Float64,Float64,CharXRay,Float64}} where T<:Union{CharXRay, NeXLSpectrum.ComptonArtifact, EscapeArtifact}","page":"Home","title":"NeXLSpectrum.escapeextents","text":"function escapeextents(\n    cxrs::AbstractVector{T},\n    det::Detector,\n    ampl::Float64\n)::Vector{Tuple{Vector{T},UnitRange{Int}}} where T <: SpectrumFeature\n\nCreates a vector containing pairs containing a vector of T <: SpectrumFeature and an interval. The interval represents a contiguous interval over which all the X-rays in the interval are sufficiently close in energy that they will interfere with each other on the specified detector.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.estimatebackground","page":"Home","title":"NeXLSpectrum.estimatebackground","text":"estimatebackground(data::AbstractArray{Float64}, channel::Int, width::Int=5, order::Int=2)\n\nReturns the tangent to the a quadratic fit to the counts data centered at channel with width\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.estkratio-Tuple{Spectrum,Spectrum,UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.estkratio","text":"estkratio(unk::Spectrum, std::Spectrum, chs::UnitRange{Int})\n\nEstimates the k-ratio from niave models of peak and background intensity.  Only works if the peak is not interfered.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.extent","page":"Home","title":"NeXLSpectrum.extent","text":"extent(escape::ComptonArtifact, res::Resolution, ampl::Float64)::Tuple{2,Float64}\n\nThe extent of a Compton artifact is determined by the resolution of the detector at the energy of the Compton peak.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.extent-2","page":"Home","title":"NeXLSpectrum.extent","text":"extent(escape::EscapeArtifact, res::Resolution, ampl::Float64)::Tuple{2,Float64}\n\nThe extent of an escape artifact is determined by the resolution of the detector at the energy of the escape peak.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.extent-Tuple{CharXRay,Resolution,Float64}","page":"Home","title":"NeXLSpectrum.extent","text":"extent(cxr::CharXRay, res::Resolution, ampl::Float64)::Tuple{2,Float64}\n\nComputes the energy range encompassed by the specified x-ray down to an intensity of ampl.  Relative line weights are taken into account.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.extent-Tuple{Float64,MnKaResolution,Float64}","page":"Home","title":"NeXLSpectrum.extent","text":"extent(xrayE::Float64, res::MnKaPlusICC, ampl::Float64)\n\nCalculates the extent of the peak interval for an x-ray of the specified energy.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.extent-Tuple{Float64,NeXLSpectrum.MnKaPlusICC,Float64}","page":"Home","title":"NeXLSpectrum.extent","text":"extent(xrayE::Float64, res::MnKaPlusICC, ampl::Float64)\n\nCalculates the extent of the peak interval for an x-ray of the specified energy.  This includes extra at the low-energy side to account for ICC.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.extent-Tuple{Union{CharXRay, NeXLSpectrum.ComptonArtifact, EscapeArtifact},Detector,Float64}","page":"Home","title":"NeXLSpectrum.extent","text":"extent(sf::SpectrumFeature, det::Detector, ampl::Float64)::Tuple{Float64, Float64}\n\nComputes the channel range encompassed by the specified set of x-ray transitions down to an intensity of ampl.  Relative line weights are taken into account.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.extents-Union{Tuple{T}, Tuple{AbstractArray{T,1},Detector,Float64}} where T<:Union{CharXRay, NeXLSpectrum.ComptonArtifact, EscapeArtifact}","page":"Home","title":"NeXLSpectrum.extents","text":"extents(cxrs::AbstractVector{<:SpectrumFeature},det::Detector,ampl::Float64)::Vector{UnitRange{Int}}\n\nDetermine the contiguous ranges of channels over which the specified collection of X-rays will be measured on the specified detector.  The ampl determines the extent of each peak.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.extractcharacteristic-Tuple{Spectrum,UnitRange{Int64},AtomicSubShell}","page":"Home","title":"NeXLSpectrum.extractcharacteristic","text":"extractcharacteristic(spec::Spectrum, lowBack::UnitRange{Int}, highBack::UnitRange{Int})::Vector{Float64}\n\nExtract the characteristic intensity for the peak located within chs with an edge at ash.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.filteredcovar-Tuple{TopHatFilter,Array{Float64,1},Int64,Int64}","page":"Home","title":"NeXLSpectrum.filteredcovar","text":"filteredcovar(filt::TopHatFilter, specdata::Vector{Float64}, row::Int, col::Int)::Float64\n\nCompute the covariance matrix entry for the specified row and column.  The resulting covariance matrix is equal to F⋅Ω⋅Fᵀ where F is the filter and Ω is the covariance matrix of the spectrum data.  Since each channel in the spectrum is 1) independent; 2) Poisson distributed, Ωᵢⱼ = specdata[i] if i==j, 0 otherwise. Because Ω is diagonal, the matrix multiplication reduces to sum over a single index.  Often this sum is zero because the non-zero portions of the row and col filters don't intersect.\n\nNote:  specdata should be preprocessed so that no element is less than or equal to zero.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.filtereddatum-Tuple{TopHatFilter,Array{Float64,1},Int64}","page":"Home","title":"NeXLSpectrum.filtereddatum","text":"filtereddatum(filt::TopHatFilter, specdata::Vector{Float64}, ch::Int)::Float64 =\n\nCompute a single channel in the filtered spectrum.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.filteredresidual-Tuple{FilterFitResult,NeXLSpectrum.FilteredUnknown,AbstractArray{FilteredReference,1}}","page":"Home","title":"NeXLSpectrum.filteredresidual","text":"filteredresidual(fit::FilterFitResult, unk::FilteredUnknown, ffs::AbstractVector{FilteredReference})::Vector{Float64}\n\nComputes the difference between the best fit and the unknown filtered spectral data.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.filterfit","page":"Home","title":"NeXLSpectrum.filterfit","text":"filterfit(unk::FilteredUnknownW, ffs::AbstractVector{FilteredReference}, alg=fitcontiguousww)::UncertainValues\n\nFilter fit the unknown against ffs, an array of FilteredReference and return the result as an FilterFitResult object. By default use the generalized LLSQ fitting (pseudo-inverse implementation).\n\nThis function is designed to reperform the fit if one or more k-ratio is less-than-or-equal-to zero.  The FilteredReference corresponding to the negative value is removed from the fit and the fit is reperformed. How the non-positive value is handled is determine by forcezeros. If forcezeros=true, then the returned k-ratio for the non-positive value will be set to zero (but the uncertainty remains the fitted one).  However, if forcezeros=false, then the final non-positive k-ratio is returned along with the associated uncertainty.  forcezeros=false is better when a number of fit k-ratio sets are combined to produce an averaged k-ratio with reduced uncertainty. forcezeros=true would bias the result positive.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.filterfit-2","page":"Home","title":"NeXLSpectrum.filterfit","text":"filterfit(unk::FilteredUnknownG, ffs::AbstractVector{FilteredReference}, alg=fitcontiguousw)::UncertainValues\n\nFilter fit the unknown against ffs, an array of FilteredReference and return the result as an FilterFitResult object. By default use the generalized LLSQ fitting (pseudo-inverse implementation).\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.fitcontiguousg-Tuple{FilteredUnknownG,AbstractArray{FilteredReference,1},UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.fitcontiguousg","text":"Generalized least squares (my implementation)\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.fitcontiguousi-Tuple{FilteredUnknownG,AbstractArray{FilteredReference,1},UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.fitcontiguousi","text":"Generalized least squares (inverse)\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.fitcontiguouso-Tuple{NeXLSpectrum.FilteredUnknown,AbstractArray{FilteredReference,1},UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.fitcontiguouso","text":"Ordinary least squares for either FilteredUnknown[G|W]\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.fitcontiguousp-Tuple{FilteredUnknownG,AbstractArray{FilteredReference,1},UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.fitcontiguousp","text":"Generalized least squares (pseudo-inverse)\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.fitcontiguousw-Tuple{FilteredUnknownG,AbstractArray{FilteredReference,1},UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.fitcontiguousw","text":"Weighted least squares using the diagonal from the FilteredUnknownG covariance as a matrix fed into glspinv.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.fitcontiguousw2-Tuple{FilteredUnknownG,AbstractArray{FilteredReference,1},UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.fitcontiguousw2","text":"Weighted least squares using the diagonal from the FilteredUnknownG covariance as a vector fed into wlssvd.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.fitcontiguousww-Tuple{FilteredUnknownW,AbstractArray{FilteredReference,1},UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.fitcontiguousww","text":"Weighted least squares for FilteredUnknownW\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.fitcontinuum-Tuple{Spectrum,AbstractArray{#s67,2} where #s67<:Real,AbstractArray{#s55,1} where #s55<:UnitRange}","page":"Home","title":"NeXLSpectrum.fitcontinuum","text":"fitcontinuum(\n  spec::Spectrum,\n  resp::AbstractArray,\n  rois::Vector{UnitRange};\n  brem::Type{<:NeXLBremsstrahlung} = Castellano2004a,\n  mc::Type{<:MatricCorrection} = Riveros1993,\n)\n\nFit a continuum model to the specified range of channels (`rois`).  The `resp` argument is a matrix which describes\n\nthe detector response on a channel-by-channel basis.  It can be calculated from an EDSDetector and an DetectorEfficiency using resp = NeXLSpectrum.detectorresponse(det, eff).  The Spectrum object must have the :Composition, :BeamEnergy and :TakeOffAngle properties defined.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.fitcontinuum-Tuple{Spectrum,EDSDetector,AbstractArray{#s69,2} where #s69<:Real}","page":"Home","title":"NeXLSpectrum.fitcontinuum","text":"fitcontinuum(\n  spec::Spectrum,\n  det::EDSDetector,\n  resp::AbstractArray{<:Real,2}; #\n  minE::Float64 = 1.5e3,\n  maxE::Float64 = 0.95 * spec[:BeamEnergy],\n  brem::Type{<:NeXLBremsstrahlung} = Castellano2004a,\n  mc::Type{<:MatrixCorrection} = Riveros1993,\n)\n\nFit the continuum from ROIs determined from the data within the spectrum (:Composition, :BeamEnergy & :TakeOffAngle). The ROIs are computed using continuumrois(...) and each roi is fit seperately.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.fittedcontinuum-Tuple{Spectrum,EDSDetector,AbstractArray{#s70,2} where #s70<:Real}","page":"Home","title":"NeXLSpectrum.fittedcontinuum","text":"fittedcontinuum(\n  spec::Spectrum,\n  det::EDSDetector,\n  resp::AbstractArray{<:Real,2}; #\n  mode = :Global [ | :Local ] # Fit to all ROIs simultaneously (:Global) or to each roi independently (:Local)\n  minE::Float64 = 1.5e3,\n  maxE::Float64 = 0.95 * spec[:BeamEnergy],\n  brem::Type{<:NeXLBremsstrahlung} = Castellano2004a,\n  mc::Type{<:MatrixCorrection} = Riveros1993,\n)::Spectrum\n\nFit the continuum under the characteristic peaks by fitting the closest continuum ROIs.  The low energy peaks are fit using the continuum immediately higher in energy and the high energy peaks are fit using the continuum on both sides.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.gaussianwidth-Tuple{Float64}","page":"Home","title":"NeXLSpectrum.gaussianwidth","text":"gaussianwidth(fwhm::Float64)\n\nConverts full-width half-max to Gaussian width.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.generated-Tuple{ContinuumModel,Float64}","page":"Home","title":"NeXLSpectrum.generated","text":"generated(cm::ContinuumModel, ea::Float64)\n\nCompute the intensity of the measured continuum generated from the material and conditions specified in the continuum model object at the specified measured energy ea.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.glsinv-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,2},Array{#s78,1} where #s78<:Label}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,2},Array{#s77,1} where #s77<:Label,N}} where N<:AbstractFloat","page":"Home","title":"NeXLSpectrum.glsinv","text":"glsinv(y::AbstractVector{N}, a::AbstractMatrix{N}, v::Matrix{N}, xlabels::Vector{<:Label}, tol::N=convert(N,1.0e-10))::UncertainValues\n\nSolve the generalized least squares problem y = x β + ϵ for β where ϵ ~ v σ using the inverse.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.glspinv-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,2},Array{#s78,1} where #s78<:Label}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,2},Array{#s77,1} where #s77<:Label,N}} where N<:AbstractFloat","page":"Home","title":"NeXLSpectrum.glspinv","text":"glspinv(y::AbstractVector{N}, a::AbstractMatrix{N}, v::Matrix{N}, xlabels::Vector{<:Label}, tol::N=convert(N,1.0e-10))::UncertainValues\n\nSolve the generalized least squares problem y = x β + ϵ for β where ϵ ~ v σ using the pseudo-inverse.\n\nβ = (xᵀv⁻¹x)⁻¹xᵀv⁻¹y where a⁻¹ => pinv(a)\n\ncov[β] = (xᵀv⁻¹x)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.glssvd-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,2},Array{#s78,1} where #s78<:Label}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,2},Array{#s77,1} where #s77<:Label,N}} where N<:AbstractFloat","page":"Home","title":"NeXLSpectrum.glssvd","text":"glssvd(y::AbstractVector{N}, a::AbstractMatrix{N}, cov::Matrix{N}, xlabels::Vector{<:Label}, tol::N=convert(N,1.0e-10))::UncertainValues\n\nSolves the generalized least squares problem y = x β + ϵ for β using covariance whitening and the ordinary least squares pseudo-inverse.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.heterogeneity-Tuple{ReferenceLabel,Array{#s79,1} where #s79<:FitResult}","page":"Home","title":"NeXLSpectrum.heterogeneity","text":"heterogeneity(lbl::ReferenceLabel, ffrs::Vector{FilterFitResult})\n\nComputes the ratio of the standard deviation of the measured values over the mean calculated uncertainty from the fit.  A value near 1 means the sample appears homogeneous and a value greater than 1 means the sample appears heterogeneous.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.indexofmaxpixel-Tuple{Signal,Int64,CartesianIndices}","page":"Home","title":"NeXLSpectrum.indexofmaxpixel","text":"indexofmaxpixel(sig::Signal, ch::Int) # at channel `ch`\nindexofmaxpixel(sig::Signal) # all channels\nindexofmaxpixel(sig::Signal, ch::Int, cis::CartesianIndices)\nindexofmaxpixel(sig::Signal, cis::CartesianIndices)\nindexofmaxpixel(hs::HyperSpectrum, ch::Int) # at channel `ch`\nindexofmaxpixel(hs::HyperSpectrum) # all channels\nindexofmaxpixel(hs::HyperSpectrum, ch::Int, cis::CartesianIndices)\nindexofmaxpixel(hs::HyperSpectrum, cis::CartesianIndices)\n\nFind the coordinates producing the maximum value in data[ch] or data[:] within 'cis' or full spatial dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.integrate-Tuple{Spectrum,StepRangeLen{Float64,R,S} where S where R,StepRangeLen{Float64,R,S} where S where R,StepRangeLen{Float64,R,S} where S where R}","page":"Home","title":"NeXLSpectrum.integrate","text":"integrate(spec::Spectrum, back1::StepRangeLen{Float64}, peak::StepRangeLen{Float64}, back2::StepRangeLen{Float64})::UncertainValue\n\nPerform a background corrected peak integration using energy (eV) ranges. Converts the energy ranges to channels ranges before performing the integral.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.integrate-Tuple{Spectrum,StepRangeLen{Float64,R,S} where S where R}","page":"Home","title":"NeXLSpectrum.integrate","text":"integrate(spec, channels)\n\nSums all the counts in the specified energy range.  No background correction.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.integrate-Tuple{Spectrum,UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.integrate","text":"integrate(spec::Spectrum, back1::UnitRange{Int}, peak::UnitRange{Int}, back2::UnitRange{Int})::Float64\n\nPerform a background corrected peak integration using channel ranges. Fits a line to each background region and extrapolates the background from the closest background channel through the peak region.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.integrate-Tuple{Spectrum,UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.integrate","text":"integrate(spec, channels)\n\nSums all the counts in the specified channels.  No background correction.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.integrate-Tuple{Spectrum}","page":"Home","title":"NeXLSpectrum.integrate","text":"integrate(spec::Spectrum)\n\nTotal integral of all counts from the LLD to the beam energy\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.kratio-Tuple{Spectrum,Spectrum,UnitRange,UnitRange,UnitRange}","page":"Home","title":"NeXLSpectrum.kratio","text":"kratio(unk::Spectrum, std::Spectrum, back1::UnitRange{Int}, peak::UnitRange{Int}, back2::UnitRange{Int})::UncertainValue\nkratio(unk::Spectrum, std::Spectrum, back1::StepRangeLen{Float64}, peak::StepRangeLen{Float64}, back2::StepRangeLen{Float64})::UncertainValue\n\nThe k-ratio of unk relative to std corrected for dose.  Requires that unk and std have the properties :LiveTime and :ProbeCurrent defined.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.kratios-Tuple{FitResult}","page":"Home","title":"NeXLSpectrum.kratios","text":"kratios(ffr::FitResult)::Vector{KRatio}\n\nThe k-ratios associated with each CharXRayLabel as a vector 'KRatio' objects.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.labeledextents","page":"Home","title":"NeXLSpectrum.labeledextents","text":"function labeledextents(\n    elm::Element,  # All CharXRay for this element\n    det::Detector,\n    ampl::Float64,\n    maxE::Float64=energy(det.channelcount+1, det) # full detector range\n)::Vector{Tuple{Vector{CharXRay},UnitRange{Int}}}\n\nCreates a vector containing pairs containing a vector of CharXRay and an interval. The interval represents a contiguous interval over which all the X-rays in the interval are sufficiently close in energy that they will interfere with each other on the specified detector.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.labeledextents-Union{Tuple{T}, Tuple{AbstractArray{T,1},Detector,Float64}} where T<:Union{CharXRay, NeXLSpectrum.ComptonArtifact, EscapeArtifact}","page":"Home","title":"NeXLSpectrum.labeledextents","text":"function labeledextents(\n    cxrs::AbstractVector{T},\n    det::Detector,\n    ampl::Float64\n)::Vector{Tuple{Vector{T},UnitRange{Int}}} where T <: SpectrumFeature\n\nCreates a vector containing pairs containing a vector of T <: SpectrumFeature and an interval. The interval represents a contiguous interval over which all the X-rays in the interval are sufficiently close in energy that they will interfere with each other on the specified detector.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.lld-Tuple{EDSDetector}","page":"Home","title":"NeXLSpectrum.lld","text":"lld(det::EDSDetector)\n\nLow level detector in channels\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.lld-Tuple{Spectrum}","page":"Home","title":"NeXLSpectrum.lld","text":"lld(spec::Spectrum)\n\nGets the low-level discriminator associated with this spectrum if there is one.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.matching","page":"Home","title":"NeXLSpectrum.matching","text":"matching(spec::Spectrum, resMnKa::Float64, lld::Int=1)::BasicEDS\n\nBuild an EDSDetector to match the channel count and energy scale in this spectrum.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.maxpixel-Tuple{HyperSpectrum}","page":"Home","title":"NeXLSpectrum.maxpixel","text":"maxpixel(hss::HyperSpectrum)\n\nProduce a maxpixel spectrum.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.maxpixel-Tuple{Signal}","page":"Home","title":"NeXLSpectrum.maxpixel","text":"maxpixel(sig::Signal)\n\nCompute Bright's Max-Pixel derived signal.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.modelBackground-Tuple{Spectrum,UnitRange{Int64},AtomicSubShell}","page":"Home","title":"NeXLSpectrum.modelBackground","text":"modelBackground(spec::Spectrum, chs::UnitRange{Int}, ash::AtomicSubShell)\n\nspec: A spectrum containing a peak centered on chs chs:  A range of channels containing a peak ash:  The edge (as an AtomicSubShell)\n\nA simple model for modeling the background under a characteristic x-ray peak. The model fits a line to low and high energy background regions around chs.start and chs.end. If the low energy line extended out to the edge energy is larger than the high energy line at the same energy, then a negative going edge is fit between the two. Otherwise a line is fit between the low energy side and the high energy side. This model only works when there are no peak interference over the range chs.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.modelBackground-Tuple{Spectrum,UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.modelBackground","text":"modelBackground(spec::Spectrum, chs::UnitRange{Int})\n\nspec: A spectrum containing a peak centered on chs chs:  A range of channels containing a peak\n\nA simple model for modeling the background under a characteristic x-ray peak. The model fits a line between the  low and high energy background regions around chs.start and chs.end. This model only works when there are no peak interference over the range chs.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.olspinv-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,2},N,Array{#s78,1} where #s78<:Label}, Tuple{AbstractArray{N,1},AbstractArray{N,2},N,Array{#s77,1} where #s77<:Label,N}} where N<:AbstractFloat","page":"Home","title":"NeXLSpectrum.olspinv","text":"olspinv(y::AbstractVector{N}, a::AbstractMatrix{N}, v::Matrix{N}, xlabels::Vector{<:Label}, tol::N=convert(N,1.0e-10))::UncertainValues\n\nSolves the ordinary least squares problem a⋅x = y for x using the pseudo-inverse for AbstractFloat-based types.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.olssvd-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,2},N,Array{#s78,1} where #s78<:Label}, Tuple{AbstractArray{N,1},AbstractArray{N,2},N,Array{#s77,1} where #s77<:Label,N}} where N<:AbstractFloat","page":"Home","title":"NeXLSpectrum.olssvd","text":"olssvd(y::AbstractVector{N}, a::AbstractMatrix{N}, sigma::N, xLabels::Vector{<:Label}, tol::N=convert(N,1.0e-10))::UncertainValues where N <: AbstractFloat\n\nSolves the ordinary least squares problem a⋅x = y for x using singular value decomposition for AbstractFloat-based types.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.peak-Tuple{Spectrum,UnitRange{Int64}}","page":"Home","title":"NeXLSpectrum.peak","text":"peak(spec::Spectrum, chs::UnitRange{Int}, ash::AtomicSubShell)::Float64\n\nEstimates the peak intensity for the characteristic X-ray in the specified range of channels.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.peaktobackground","page":"Home","title":"NeXLSpectrum.peaktobackground","text":"peaktobackground(ffr::FilterFitResult, backwidth::Float64=10.0)::Float64\n\nThe peak-to-background ratio as determined from the raw and residual spectra integrated over the fit region-of-interest and scaled to backwidth eV of continuum (nominally 10 eV).\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.peaktobackground-Tuple{Spectrum,UnitRange{Int64},AtomicSubShell}","page":"Home","title":"NeXLSpectrum.peaktobackground","text":"peaktobackground(spec::Spectrum, chs::UnitRange{Int}, ash::AtomicSubShell)::Float64\n\nEstimates the peak-to-background ratio for the characteristic X-ray intensity in the specified range of channels which encompass the specified AtomicSubShell.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.plane","page":"Home","title":"NeXLSpectrum.plane","text":"plane(hss::HyperSpectrum, chs::Union{Int,UnitRange{Int}}, norm=false) =\n\nExtract as an Array the sum of the data in chs.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.plane-2","page":"Home","title":"NeXLSpectrum.plane","text":"plane(hss::Signal, ch::Int, normalize=false)\n\nSums a contiguous range of data planes into an Array. The dimension of the result is one less than the dimension of the Signal.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.plane-3","page":"Home","title":"NeXLSpectrum.plane","text":"plane(hss::Signal, chs::UnitRange, normalize=false)\n\nSums a contiguous range of data planes into an Array. The dimension of the result is one less than the dimension of the Signal.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.profile-Tuple{Float64,Float64,MnKaResolution}","page":"Home","title":"NeXLSpectrum.profile","text":"\"     profile(energy::Float64, xrayE::Float64, res::MnKaResolution) Calculates a Gaussian profile for an X-ray of xrayE (eV) for a detector with the specified resolution.  Maintains normalization to a sum of unity.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.profile-Tuple{Float64,Float64,NeXLSpectrum.MnKaPlusICC}","page":"Home","title":"NeXLSpectrum.profile","text":"\"     profile(energy::Float64, xrayE::Float64, res::MnKaPlusICC)\n\nCalculates a Gaussian profile for an X-ray of xrayE (eV) for a detector with the specified resolution.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.profile-Tuple{Int64,Float64,EDSDetector}","page":"Home","title":"NeXLSpectrum.profile","text":"\"     profile(ch::Int, xrayE::Float64, det::EDSDetector)\n\nCalculates the profile for an X-ray of xrayE (eV) for a detector with the specified resolution.  Performs a crude integration to account for the channel width.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.rangeofenergies-Tuple{Spectrum,Any}","page":"Home","title":"NeXLSpectrum.rangeofenergies","text":"rangeofenergies(spec::Spectrum, ch)\n\nReturns the low and high energy extremes for the channels ch.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.readEMSA","page":"Home","title":"NeXLSpectrum.readEMSA","text":"readEMSA(filename::AbstractString, det::Detector, force::Bool=false)::Spectrum\n\nRead an EMSA file and apply the specified detector.  If force is false and the detector and read calibration don't match then the function errors.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.readEMSA-2","page":"Home","title":"NeXLSpectrum.readEMSA","text":"readEMSA(ios::IO, T::Type{<:Real}=Float64)::Spectrum\n\nRead an ISO/EMSA format spectrum from a disk file at the specified path. T is the type of the channel data elements.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.readEMSA-3","page":"Home","title":"NeXLSpectrum.readEMSA","text":"readEMSA(filename::AbstractString, T::Type{<:Real}=Float64)::Spectrum\n\nRead an ISO/EMSA format spectrum from a disk file at the specified path. T is the type of the channel data elements.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.readbrukerpdz-Tuple{IO}","page":"Home","title":"NeXLSpectrum.readbrukerpdz","text":"readbrukerpdz(io::IO|fn::AbstractString)\n\nRead the default data file type for the Bruker handheld XRF unit. (Reverse engineered.)\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.readbrukerspx-Tuple{String}","page":"Home","title":"NeXLSpectrum.readbrukerspx","text":"readbrukerspx(fn::AbstractString)::Spectrum\nreadbrukerspx(io::IO)::Spectrum\n\nRead a Bruker SPX EDS spectrum file into a Spectrum.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.readraw-Tuple{IOStream,RPLHeader,EnergyScale,Dict{Symbol,Any}}","page":"Home","title":"NeXLSpectrum.readraw","text":"readraw(ios::IOStream, T::Type{<:Real}, size::NTuple{Int, N}, energy::EnergyScale, props::Dict{Symbol,Any}) =\n\nConstruct a full Signal from the counts data in binary from the specified stream.  Always returns the data in [d,w,h] order.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.readrplraw","page":"Home","title":"NeXLSpectrum.readrplraw","text":"readrplraw(rplfilename::AbstractString, rawfilename::AbstractString, scale::EnergyScale, props::Dict{Symbol,Any}=Dict{Symbol,Any}())\nreadrplraw(rplio::IO, rawio::IO, scale::EnergyScale, props::Dict{Symbol,Any}=Dict{Symbol,Any}())\n\nRead a RPL/RAW file pair from IO or filename into a Signal obect.  The reader supports :bigendian, :littleendian ordering and :vector or :image alignment.  Since the Signal can be very large it is beneficial to release and collected the associated memory when you are done with the data by assigning nothing to the variable (or allowing it to go out of scope) and then calling GC.gc() to force a garbage collection.\n\n* Ordering: The individual data items may be in `:littleendian` or `:bigendian`.\n** `:littleendian` => Intel/AMD and others\n** `:bigendian` => ARM/PowerPC/Motorola\n* Alignment:  The data in the file can be organized as `:vector` or `:image`.  However, the data will be\n\nreorganized into 'vector' format when returned as a Signal.     **:vector => Spectrum/data vector as contiguous blocks by pixel     ** :image => Each channel of data organized in image planes     * Data types: signed/unsigned 8/16/32-bit integers or 16-bit/32-bit/64-bit floats\n\nStandard LISPIX Parameters in .rpl File\n\n.rpl files consist of 9 lines.  Each line consists of a 'key'<tab>'value' where there is one and only one tab and possibly other space between the parameter name and parameter value. Parameter names are case-insensitive. The first line in the files is \"key<tab>value\".  Subsequent lines contain the keys and values described in this table.\n\nkey value description\nwidth 849 pixels per row       integer\nheight 846 rows                 integer\ndepth 4096 images or spec pts   integer\noffset 0 bytes to skip        integer\ndata-length 1 bytes per pixel      1, 2, 4, or 8\ndata-type unsigned signed, unsigned, or float\nbyte-order dont-care big-endian, little-endian, or dont-care\nrecord-by vector image, vector, or dont-care\n\nThis .rpl file indicates the image is 849 pixels wide and 846 pixels high, with 4096 levels in the depth dimension.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.residual-Tuple{FilterFitResult}","page":"Home","title":"NeXLSpectrum.residual","text":"residual(ffr::FilterFitResult)::Spectrum\n\nA Spectrum containing the histogram representing the unknown spectrum minus the fitted characteristic peaks shapes times the best fit coefficient.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.resolution-Tuple{Float64,EDSDetector}","page":"Home","title":"NeXLSpectrum.resolution","text":"resolution(eV::Float64, det::EDSDetector)\n\nResolution (FWHM) of the detector in eV at the specified energy.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.resolution-Tuple{Float64,MnKaResolution}","page":"Home","title":"NeXLSpectrum.resolution","text":"\"     resolution(eV::Float64, res::MnKaResolution)\n\nThe FWHM at eV for the MnKaResolution model.  Uses Chuck Fiori's simple function relating the FWHM at eV to the FWHM at another energy.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.resolution-Tuple{Float64,NeXLSpectrum.MnKaPlusICC}","page":"Home","title":"NeXLSpectrum.resolution","text":"\"     resolution(eV::Float64, res::MnKaPlusICC)\n\nThe FWHM at eV in the MnKaPlusICC model.  Uses Chuck Fiori's simple function relating the FWHM at eV to the FWHM at another energy plus a term to account for incomplete charge collection.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.roiimage","page":"Home","title":"NeXLSpectrum.roiimage","text":"roiimage(hss::Signal, cxr::CharXRay, n=5)\n\nCreate a count map for the specified characteristic X-ray.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.roiimage-Tuple{HyperSpectrum,UnitRange}","page":"Home","title":"NeXLSpectrum.roiimage","text":"roiimage(hss::Signal, chs::UnitRange)\n\nCreate a count map from the specified contiguous range of channels.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.roiimages","page":"Home","title":"NeXLSpectrum.roiimages","text":"roiimages(hss::HyperSpectrum, cxrs::Vector{CharXRay}, n=5)\n\nCreate an array of Gray images representing the intensity in each of the CharXRay lines in cxrs.  They are normalized such the the most intense pixel in any of them defines white.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.roiimages-Tuple{HyperSpectrum,Array{UnitRange{Int64},1}}","page":"Home","title":"NeXLSpectrum.roiimages","text":"roiimages(hss::HyperSpectrum, achs::Vector{UnitRange{Int}})\n\nCreate an array of Gray images representing the intensity in each range of channels in in achs.  They are normalized such the the most intense pixel in any of them defines white.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.roiimages-Tuple{Signal,Array{UnitRange{Int64},1}}","page":"Home","title":"NeXLSpectrum.roiimages","text":"roiimages(hss::Signal, achs::Vector{UnitRange{Int}})\n\nCreate an array of Gray images representing the intensity in each range of channels in in achs.  They are normalized such the the most intense pixel in any of them defines white.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.scale-Tuple{EDSDetector}","page":"Home","title":"NeXLSpectrum.scale","text":"scale(det::EDSDetector)\n\nEnergyScale associated with this detector.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.selectBestReferences-Tuple{AbstractArray{FilteredReference,1}}","page":"Home","title":"NeXLSpectrum.selectBestReferences","text":"selectBestReferences(refs::AbstractVector{FilteredReference})::Vector{FilteredReference}\n\nFor each roi in each element, pick the best FilteredReference with the highest intensity in the filtered data.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.simpleEDS","page":"Home","title":"NeXLSpectrum.simpleEDS","text":"simpleEDS(chCount::Integer, width::Float64, offset::Float64, fwhmatmnka::Float64, lld::Int = channel(150.0 eV))\n\nConstruct simple model of an EDS detector.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.simpleEDS-Tuple{Spectrum,Float64}","page":"Home","title":"NeXLSpectrum.simpleEDS","text":"simpleEDS(spec::Spectrum, fwhmatmnka::Float64)\n\nBuild a EDSDetector object for this spectrum with the specified FWHM at Mn Kα.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.simpleEDSwICC","page":"Home","title":"NeXLSpectrum.simpleEDSwICC","text":"simpleEDSwICC(chCount::Integer, width::Float64, offset::Float64, fwhmatmnka::Float64, lld::Int=channel(150.0 eV))\n\nConstruct simple model of an EDS detector with incomplete charge collection at low X-ray energies.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.spectrum-Tuple{NeXLSpectrum.FilteredLabel}","page":"Home","title":"NeXLSpectrum.spectrum","text":"spectrum(fl::FilteredLabel)::Spectrum\n\nThe spectrum associated with a FilteredLabel-based type.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.subdivide-Tuple{Spectrum,Int64}","page":"Home","title":"NeXLSpectrum.subdivide","text":"subdivide(spec::Spectrum, n::Int)::Vector{Spectrum}\n\nSplits the event data in one spectrum into n spectra by assigning each event to a pseudo-random choice of one of the n result spectra.  Produces n spectra that act as though the original spectrum was collected in n time intervals of LiveTime/n.  This is quite slow because it needs to call rand() for each count in the spectrum (not just each channel).\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.subsample-Tuple{Spectrum,Float64}","page":"Home","title":"NeXLSpectrum.subsample","text":"subsample(spec::Spectrum, frac::Float64)\n\nSubsample the counts data in a spectrum according to a statistically valid algorithm.  Returns spec if frac>=1.0.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.subtractcontinuum-Tuple{Spectrum,EDSDetector,AbstractArray{#s70,2} where #s70<:Real}","page":"Home","title":"NeXLSpectrum.subtractcontinuum","text":"subtractcontinuum(\n  spec::Spectrum,\n  det::EDSDetector,\n  resp::AbstractArray{<:Real,2}; #\n  minE::Float64 = 1.5e3,\n  maxE::Float64 = 0.95 * spec[:BeamEnergy],\n  brem::Type{<:NeXLBremsstrahlung} = Castellano2004a,\n  mc::Type{<:MatrixCorrection} = Riveros1993,\n)::Spectrum\n\nComputes the characteristic-only spectrum by subtracting the .\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.tophatfilter","page":"Home","title":"NeXLSpectrum.tophatfilter","text":"tophatfilter(spec::Spectrum, thf::TopHatFilter, scale::Float64=1.0, tol::Float64 = 1.0e-4)::FilteredUnknown\n\nFor filtering the unknown spectrum. Defaults to the weighted fitting model.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.tophatfilter-2","page":"Home","title":"NeXLSpectrum.tophatfilter","text":"tophatfilter(\n  reflabel::ReferenceLabel,\n  roi::UnitRange{Int},\n  thf::TopHatFilter,\n  scale = 1.0,\n  tol = 1.0e-6\n)::FilteredReference\n\nFor filtering an ROI on a reference spectrum. Process a portion of a Spectrum with the specified filter. Use a naive linear background model.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.tophatfilter-3","page":"Home","title":"NeXLSpectrum.tophatfilter","text":"tophatfilter(spec::Spectrum, thf::TopHatFilter, scale::Float64=1.0, tol::Float64 = 1.0e-4)::FilteredDatum\n\nFor filtering the unknown spectrum. Process the full Spectrum with the specified filter.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.tophatfilter-4","page":"Home","title":"NeXLSpectrum.tophatfilter","text":"tophatfilter(\n    charLabel::CharXRayLabel,\n    thf::TopHatFilter,\n    scale::Float64 = 1.0,\n    tol::Float64 = 1.0e-6,\n)::FilteredReference\n\nFor filtering an ROI on a reference spectrum. Process a portion of a Spectrum with the specified filter.  Use a simple edge-based background model.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.tophatfilter-5","page":"Home","title":"NeXLSpectrum.tophatfilter","text":"tophatfilter(::Type{FilteredUnknownW}, spec::Spectrum, thf::TopHatFilter, scale::Float64=1.0, tol::Float64 = 1.0e-4)::FilteredUnknownW\n\nFor filtering the unknown spectrum. Process the full Spectrum with the specified filter for use with the weighted least squares model.\n\n\n\n\n\n","category":"function"},{"location":"#NeXLSpectrum.visible-Tuple{AbstractArray{#s14,1} where #s14<:Union{CharXRay, NeXLSpectrum.ComptonArtifact, EscapeArtifact},Detector}","page":"Home","title":"NeXLSpectrum.visible","text":"visible(cxrs::AbstractVector{<:SpectrumFeature}, det::Detector)\n\nReturns the characteristic x-rays that are visible on the specified detector (ie. Between the LLD and the maximum channel).\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.visible-Tuple{EscapeArtifact,BasicEDS}","page":"Home","title":"NeXLSpectrum.visible","text":"visible(sf::SpectrumFeature, det::Detector)\n\nIs sf visible on the specified Detector?\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.wlspinv-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,1},Array{#s78,1} where #s78<:Label}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,1},Array{#s77,1} where #s77<:Label,N}} where N<:AbstractFloat","page":"Home","title":"NeXLSpectrum.wlspinv","text":"wlspinv(y::AbstractVector{N}, a::AbstractMatrix{N}, cov::AbstractVector{N}, xlabels::Vector{<:Label}, tol::N=convert(N,1.0e-10))::UncertainValues\n\nSolves the weighted least squares problem a⋅x = y for x using singular value decomposition for AbstractFloat-based types.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.wlspinv2-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,1},AbstractArray{N,1},Array{#s76,1} where #s76<:Label}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,1},AbstractArray{N,1},Array{#s75,1} where #s75<:Label,N}} where N<:AbstractFloat","page":"Home","title":"NeXLSpectrum.wlspinv2","text":"wlspinv(y::AbstractVector{N}, a::AbstractMatrix{N}, cov::AbstractVector{N}, xlabels::Vector{<:Label}, tol::N=convert(N,1.0e-10))::UncertainValues\n\nSolves the weighted least squares problem a⋅x = y for x using singular value decomposition for AbstractFloat-based types.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.wlssvd-Union{Tuple{N}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,1},Array{#s78,1} where #s78<:Label}, Tuple{AbstractArray{N,1},AbstractArray{N,2},AbstractArray{N,1},Array{#s77,1} where #s77<:Label,N}} where N<:AbstractFloat","page":"Home","title":"NeXLSpectrum.wlssvd","text":"wlssvd(y::AbstractVector{N}, a::AbstractMatrix{N}, cov::AbstractVector{N}, xlabels::Vector{<:Label}, tol::N=convert(N,1.0e-10))::UncertainValues\n\nSolves the weighted least squares problem y = x β + ϵ  for β using singular value decomposition for AbstractFloat-based types.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLSpectrum.xrays-Tuple{CharXRayLabel}","page":"Home","title":"NeXLSpectrum.xrays","text":"xrays(cl::CharXRayLabel)\n\nA list of the X-rays associated with this CharXRayLabel.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame},AbstractArray{Spectrum,1}}","page":"Home","title":"NeXLUncertainties.asa","text":"NeXLUncertainties.asa(::Type{DataFrame}, spec::AbstractVector{Spectrum})::DataFrame\n\nReturns a DataFrame that summarizes the list of spectra.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame},AbstractDict{Element,Spectrum}}","page":"Home","title":"NeXLUncertainties.asa","text":"NeXLUncertainties.asa(::Type{DataFrame}, spec::AbstractDict{Element, Spectrum})::DataFrame\n\nReturns a DataFrame that summarizes a dictionary of standard spectra.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame},FilterFitResult}","page":"Home","title":"NeXLUncertainties.asa","text":"asa(::Type{DataFrame}, ffr::FilterFitResult)::DataFrame\n\nTabulate details about each region-of-interest in the 'FilterFitResult' in a 'DataFrame'.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame},Spectrum}","page":"Home","title":"NeXLUncertainties.asa","text":"asa(::Type{DataFrame}, spec::Spectrum)\n\nConverts the spectrum energy and counts data into a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLUncertainties.covariance-Tuple{FilteredUnknownG,UnitRange{Int64}}","page":"Home","title":"NeXLUncertainties.covariance","text":"covariance(fd::FilteredUnknownG, roi::UnitRange{Int})::AbstractMatrix{Float64}\n\nLike extract(fd,roi) except extracts the covariance matrix over the specified range of channels.  roi must be fully contained within the filtered edata in fd.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLUncertainties.covariance-Tuple{FilteredUnknownW,UnitRange{Int64}}","page":"Home","title":"NeXLUncertainties.covariance","text":"covariance(fd::FilteredUnknownW, roi::UnitRange{Int})\n\nLike extract(fd,roi) except extracts the covariance diagnonal elements over the specified range of channels. roi must be fully contained within the data in fd.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLUncertainties.extract-Tuple{FilteredReference,UnitRange{Int64}}","page":"Home","title":"NeXLUncertainties.extract","text":"extract(fd::FilteredReference, roi::UnitRange{Int})\n\nExtract the filtered data representing the specified range.  roi must fully encompass the filtered data in fd.\n\n\n\n\n\n","category":"method"},{"location":"#NeXLUncertainties.extract-Tuple{NeXLSpectrum.FilteredUnknown,UnitRange{Int64}}","page":"Home","title":"NeXLUncertainties.extract","text":"extract(fd::FilteredUnknown, roi::UnitRange{Int})::AbstractVector{Float64}\n\nExtract the filtered data representing the specified range.  roi must be fully contained within the filtered data in fd.\n\n\n\n\n\n","category":"method"}]
}
