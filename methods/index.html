<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · NeXLSpectrum.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">
<script src="https://pages.nist.gov/nist-header-footer/js/jquery-1.9.0.min.js" type="text/javascript" defer="defer"></script>
<script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>
</head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NeXLSpectrum.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">NeXLSpectrum.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../spectrum/">Spectrum Methods</a></li><li><a class="tocitem" href="../k412refs/">Fitting K412 (simple API)</a></li><li><a class="tocitem" href="../K412fit/">Fitting K412 (flexible API)</a></li><li><a class="tocitem" href="../K412quick/">Fitting K412 (quick fit)</a></li><li><a class="tocitem" href="../XRFspectra/">Fitting XRF Spectra</a></li><li><a class="tocitem" href="../errorbars/">Lovely Error Bars</a></li><li><a class="tocitem" href="../continuummodel/">Modeling the Continuum</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Microanalytical-X-ray-Spectrum-Analysis"><span>Microanalytical X-ray Spectrum Analysis</span></a></li><li class="toplevel"><a class="tocitem" href="#Spectrum-Manipulation"><span>Spectrum Manipulation</span></a></li><li><a class="tocitem" href="#Spectrum-Plotting"><span>Spectrum Plotting</span></a></li><li><a class="tocitem" href="#Spectrum-Tabulation"><span>Spectrum Tabulation</span></a></li><li class="toplevel"><a class="tocitem" href="#HyperSpectrum-Manipulation"><span>HyperSpectrum Manipulation</span></a></li><li class="toplevel"><a class="tocitem" href="#Fitting-Filter"><span>Fitting Filter</span></a></li><li><a class="tocitem" href="#Filter-Fit-Tabulation"><span>Filter Fit Tabulation</span></a></li><li><a class="tocitem" href="#Filter-Fit-Plotting"><span>Filter Fit Plotting</span></a></li><li><a class="tocitem" href="#Advanced-Filter-Fitting"><span>Advanced Filter Fitting</span></a></li><li class="toplevel"><a class="tocitem" href="#Matrix-Correction"><span>Matrix Correction</span></a></li><li><a class="tocitem" href="#Standardization"><span>Standardization</span></a></li><li class="toplevel"><a class="tocitem" href="#EDS-Detectors"><span>EDS Detectors</span></a></li><li class="toplevel"><a class="tocitem" href="#EDS-Detector-Plotting"><span>EDS Detector Plotting</span></a></li><li><a class="tocitem" href="#Energy-Axis-Scales-for-EDS-Detectors"><span>Energy Axis Scales for EDS Detectors</span></a></li><li><a class="tocitem" href="#Multi-Detector-Functions"><span>Multi-Detector Functions</span></a></li><li><a class="tocitem" href="#Bremsstrahlung"><span>Bremsstrahlung</span></a></li><li><a class="tocitem" href="#Utility"><span>Utility</span></a></li></ul></li><li><a class="tocitem" href="../precompile/">Precompilation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/master/docs/src/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="![](NeXL_sm.png)Spectrum"><a class="docs-heading-anchor" href="#![](NeXL_sm.png)Spectrum"><img src="../NeXL_sm.png" alt/>Spectrum</a><a id="![](NeXL_sm.png)Spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#![](NeXL_sm.png)Spectrum" title="Permalink"></a></h1><h2 id="Microanalytical-X-ray-Spectrum-Analysis"><a class="docs-heading-anchor" href="#Microanalytical-X-ray-Spectrum-Analysis">Microanalytical X-ray Spectrum Analysis</a><a id="Microanalytical-X-ray-Spectrum-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Microanalytical-X-ray-Spectrum-Analysis" title="Permalink"></a></h2><h1 id="Spectrum-Manipulation"><a class="docs-heading-anchor" href="#Spectrum-Manipulation">Spectrum Manipulation</a><a id="Spectrum-Manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Spectrum-Manipulation" title="Permalink"></a></h1><p>See the <a href="../spectrum/#spectrum_methods">Spectrum Methods</a> page for the most used methods and details.</p><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.property!" href="#NeXLSpectrum.property!"><code>NeXLSpectrum.property!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">property!(spec::Spectrum, sym::Symbol, val::Any)</code></pre><p>Useful to broadcast properties over many spectra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.duane_hunt" href="#NeXLSpectrum.duane_hunt"><code>NeXLSpectrum.duane_hunt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">duane_hunt(spec::Spectrum)</code></pre><p>Estimates the Duane-Hunt limit (the energy at which the continuum goes to effectively zero.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L1255-L1259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.sigma" href="#NeXLSpectrum.sigma"><code>NeXLSpectrum.sigma</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma(spec::Spectrum, specs::AbstractArray{&lt;:Spectrum}, chs::AbstractRange{&lt;:Integer})::Vector{Float64}</code></pre><p>Computes on a channel-by-channel basis how much <code>spec</code> spectrum deviates from the mean of the other spectra in <code>specs</code>.  The result is expressed in terms of the standard deviation expected from count statistics alone.   Assuming <code>spec</code> varies only by count statistics we expect the result values have a mean 0.0 and a standard deviation of 1.0. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L1273-L1280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.findsimilar" href="#NeXLSpectrum.findsimilar"><code>NeXLSpectrum.findsimilar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findsimilar(specs::AbstractArray{Spectrum{T}}; tol = 1.8, minspecs=3)::Vector{Spectrum{T}}</code></pre><p>Filters a collection of spectra for the ones most similar to the average by removing the least similar spectrum sequentially until all the remaining spectra are within tol times the mean(χ²).  This is useful for finding which of a set of replicate spectra are sufficiently similar to each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L1192-L1199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.multiscore" href="#NeXLSpectrum.multiscore"><code>NeXLSpectrum.multiscore</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">multiscore(specs::AbstractArray{&lt;:Spectrum}, e0=specs[1][:BeamEnergy])</code></pre><p>Compares each spectrum against the mean spectrum by comparing the 200 eV to 500 eV range with the [e0/2,e0/1.5] range. If all spectra are equivalent at low energies then all the scores will be close to zero.  A number less than zero means that the low energy region of the spectrum was depressed relative to the others.  A number more than zero means that the high energy region of the spectrum was elevated relative to the others.  The multi-score is sensitive to tilt and obstructions like surface texture which may make one spectrum&#39;s low energy be more absorbed than the  others. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/multidet.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.multirank" href="#NeXLSpectrum.multirank"><code>NeXLSpectrum.multirank</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">multirank(specs::AbstractArray{&lt;:Spectrum})::Float64</code></pre><p>A single number that compares the low and high energy portions of the spectra for similarity.  A <code>multirank(...)</code> score of zero means all the spectra are very similar and a large number means very different. A high score suggests that one or more of the spectra may suffer from additional low energy absorption due to surface roughness, an obstruction, sample tilt or other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/multidet.jl#L107-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.plot_compare" href="#NeXLSpectrum.plot_compare"><code>NeXLSpectrum.plot_compare</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_compare(specs::AbstractArray{&lt;:Spectrum}, mode=:Plot; xmin=100.0, xmax=1.0, palette = NeXLPalette)</code></pre><p>Plots a comparison of the channel-by-channel data from each individual spectrum relative to the dose-corrected mean of the other spectra.  Count statistics are taken into account so if the spectra agree to within count statistics we expect a mean of 0.0 and a standard deviation of 1.0 over all channels. Note: xmax is relative to the :BeamEnergy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L577-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.apply" href="#NeXLSpectrum.apply"><code>NeXLSpectrum.apply</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply(filt::SavitzkyGolayFilter, spec::Spectrum, applyLLD=false)</code></pre><p>Applys a function to the channel data in <code>spec</code> (with/wo the low-level discriminator.) The function can only be a function of the counts data and can not change the energy scale or spectrum properties.  The result is a Spectrum.</p><p>Example:</p><pre><code class="nohighlight hljs">apply(SavitzkyGolayFilter{6,4}(),spec)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/smoothing.jl#L52-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.loadmultispec" href="#NeXLSpectrum.loadmultispec"><code>NeXLSpectrum.loadmultispec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loadmultispec(path::AbstractString, basefn::AbstractString; indexes=0:3, fnmapper::String = &quot;{1}[{2}].msa&quot;)</code></pre><p>Load multiple spectra using the <code>basefn</code> and <code>fnmapper</code> to determine which spectra to load.  The spectra should be related in the sense that they were all collected simulataneously so they have the same <code>:RealTime</code>, <code>:BeamEnergy</code>  and <code>:LiveTime</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/multidet.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.uv" href="#NeXLUncertainties.uv"><code>NeXLUncertainties.uv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uv(spec::Spectrum, chs::AbstractRange{&lt;:Integer}=eachindex(spec))::Vector{UncertainValue}</code></pre><p>Converts the count&#39;s data in a spectrum into an Vector{UncertainValue} assuming count statistics can be approximated by C ± √C. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L1262-L1267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.χ²" href="#NeXLSpectrum.χ²"><code>NeXLSpectrum.χ²</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">χ²(s1::Spectrum{T}, s2::Spectrum{T}, chs)::T where {T&lt;:Real}
χ²(specs::AbstractArray{Spectrum{T}}, chs)::Matrix{T}</code></pre><p>Computes the dose corrected χ² metric of similarity between <code>s1</code> and <code>s2</code>. Or computes the matrix of χ² for the array of spectra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L1105-L1111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.recalibrate" href="#NeXLSpectrum.recalibrate"><code>NeXLSpectrum.recalibrate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">recalibrate(s::Spectrum{T}, es::LinearEnergyScale)</code></pre><p>Allows changing the energy scale on a spectrum from one LinearEnergyScale to another as though the spectrum were  measured on a different detector.  The algorith uses a FFT-base scheme to rescale and shift the spectral data. Ths scheme allows for fractional shifts of offset and fractional changes in the width.  It is limited in that the change in width must produce an integral number of channels in the resulting spectrum.  The algorithm  maintains the total spectrum integral so the new spectrum can be used for quantitative purposes. Plotting one spectrum over the other should maintain peak position but is likely to change the channel counts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L1316-L1325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.shift" href="#NeXLSpectrum.shift"><code>NeXLSpectrum.shift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shift(s::Spectrum, ev::AbstractFloat)::Spectrum</code></pre><p>Shift the entire spectrum along the energy axis by a specified number of ev by modifying the counts data.  This function can shift by a fractional number of channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L1343-L1348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.offset" href="#NeXLSpectrum.offset"><code>NeXLSpectrum.offset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">offset(s::Spectrum, dcounts::Real)</code></pre><p>Returns a <code>Spectrum</code> like <code>s</code> but with dcounts added to each channel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.dosenormalize" href="#NeXLSpectrum.dosenormalize"><code>NeXLSpectrum.dosenormalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dosenormalize(spectrum::Spectrum{T}, dose=60.0)::Spectrum{T} where { T &lt;: Real }
dosenormalize(spectrum::Spectrum{T}, dose=60.0)::Spectrum{Float64} where { T &lt;: Integer }</code></pre><p>Compute a spectrum which is <code>spectrum</code> rescaled to a live time times probe current equal to <code>dose</code>. Useful for setting spectra on an equivalent acquisition duration scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L1293-L1299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.extent" href="#NeXLSpectrum.extent"><code>NeXLSpectrum.extent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extent(xrayE::Float64, res::Resolution, ampl::Float64)</code></pre><p>Calculates the extent of the peak interval for an x-ray of the specified energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L190-L195">source</a></section><section><div><pre><code class="nohighlight hljs">extent(escape::EscapeArtifact, res::Resolution, ampl::Float64)::Tuple{2,Float64}</code></pre><p>The extent of an escape artifact is determined by the resolution of the detector at the energy of the escape peak.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L245-L249">source</a></section><section><div><pre><code class="nohighlight hljs">extent(escape::ComptonArtifact, res::Resolution, ampl::Float64)::Tuple{2,Float64}</code></pre><p>The extent of a Compton artifact is determined by the resolution of the detector at the energy of the Compton peak.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L253-L257">source</a></section><section><div><pre><code class="nohighlight hljs">extent(sf::SpectrumFeature, det::Detector, ampl::Float64)::Tuple{Float64, Float64}</code></pre><p>Computes the channel range encompassed by the specified set of x-ray transitions down to an intensity of ampl.  Relative line weights are taken into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L261-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.characteristiccounts" href="#NeXLSpectrum.characteristiccounts"><code>NeXLSpectrum.characteristiccounts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">characteristiccounts(ffr::FiterFitResult, strip)</code></pre><p>Number of spectrum counts that were accounted for by the fitted elements with the <code>strip</code> Element(s) removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.scale" href="#NeXLSpectrum.scale"><code>NeXLSpectrum.scale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale(det::Detector)</code></pre><p>EnergyScale associated with this detector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L291-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.channelcount" href="#NeXLSpectrum.channelcount"><code>NeXLSpectrum.channelcount</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">channelcount(det::Detector)</code></pre><p>Number of detector channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.sumcounts" href="#NeXLSpectrum.sumcounts"><code>NeXLSpectrum.sumcounts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sumcounts(hss::HyperSpectrum, cis::CartesianIndices = CartesianIndices(hss))</code></pre><p>An array containing the number of counts at each pixel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L536-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.shannon_entropy-Tuple{Spectrum}" href="#NeXLSpectrum.shannon_entropy-Tuple{Spectrum}"><code>NeXLSpectrum.shannon_entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shannon_entropy(spec::Spectrum)</code></pre><p>Computes a measure of the information content in a spectrum.  As there become more and more distinct values in a spectrum, this value approaches log2(nchannels(spec)).  This number reflects the number of bits necessary to encode the spectrum data with maximum efficiency.</p><p>This is inspired by John Colby&#39;s FLAME software which did something similar.  Although, to be honest, I don&#39;t know how his algorithm was implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L1353-L1362">source</a></section></article><h2 id="Spectrum-Plotting"><a class="docs-heading-anchor" href="#Spectrum-Plotting">Spectrum Plotting</a><a id="Spectrum-Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Spectrum-Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{AbstractVector{Spectrum}}" href="#Gadfly.plot-Tuple{AbstractVector{Spectrum}}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(
    specs::Union{Spectrum...,AbstractVector{Spectrum{&lt;:Real}}};
    klms=[],
    edges=[],
	escapes=[],
	coincidences=[],
    autoklms = false,
    xmin=0.0,
    xmax=missing,
    norm=:None,
    yscale=1.05,
    ytransform = identity,
	style=NeXLSpectrumStyle,
	palette=NeXLPalette
)::Plot</code></pre><p>Required:</p><pre><code class="nohighlight hljs">specs::AbstractVector{Spectrum};</code></pre><p>Named:</p><pre><code class="nohighlight hljs">klms = [ Element &amp;| CharXRay ]
edges = [ Element &amp;| AtomicSubShell ]
escapes = [ CharXRay ],
coincidences = [ CharXRay ]
autoklms = false # Add KLMs based on elements in spectra
xmin = 0.0 # Min energy (eV)
xmax = missing # Max energy (eV) (defaults to max(:BeamEnergy))
norm = NoScaling() | ScaleDoseWidth() | ScaleDose() | ScaleSum() | ScaleROISum() | ScalePeak() | (&lt;: SpectrumScaling)()
yscale = 1.05 # Fraction of max intensity for ymax over [max(lld,xmin):xmax]
ytransform = identity | log10 | sqrt | ??? # How to transform the counts data before plotting
style=NeXLSpectrumStyle (or another Gadfly.style)
palette = NeXLPalette | Colorant[ ... ] # Colors for spectra...
customlayers = Gadfly.Layer[] # Allows additional plot layers to be added</code></pre><p>Plot a multiple spectra on a single plot using Gadfly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L24-L62">source</a></section></article><p>These types define the different ways that spectra can be scaled when plotted using the <code>Gadfly.plot(...)</code> methods.</p><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.SpectrumScaling" href="#NeXLSpectrum.SpectrumScaling"><code>NeXLSpectrum.SpectrumScaling</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SpectrumScaling types are designed to rescale spectrum data primarily for plotting.</p><p><strong>Implement</strong></p><pre><code class="nohighlight hljs">Base.show(io::IO, scn::SpectrumScaling)
scalefactor(sc::SpectrumScaling, spec::Spectrum)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/specscaling.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.NoScaling" href="#NeXLSpectrum.NoScaling"><code>NeXLSpectrum.NoScaling</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Don&#39;t scale the spectrum data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/specscaling.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.ScaleSum" href="#NeXLSpectrum.ScaleSum"><code>NeXLSpectrum.ScaleSum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Scale to a fixed total integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/specscaling.jl#L66-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.ScaleDose" href="#NeXLSpectrum.ScaleDose"><code>NeXLSpectrum.ScaleDose</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Scale to a constant dose (Counts/(nA⋅s)).   Requires a spectrum has both :ProbeCurrent &amp; :LiveTime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/specscaling.jl#L54-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.ScaleDoseWidth" href="#NeXLSpectrum.ScaleDoseWidth"><code>NeXLSpectrum.ScaleDoseWidth</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Scale to a constant dose⋅width (Counts/(nA⋅s/eV))  Requires a spectrum has both :ProbeCurrent &amp; :LiveTime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/specscaling.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.ScaleROISum" href="#NeXLSpectrum.ScaleROISum"><code>NeXLSpectrum.ScaleROISum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Scale to a default sum in the specified ROI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/specscaling.jl#L92-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.ScalePeak" href="#NeXLSpectrum.ScalePeak"><code>NeXLSpectrum.ScalePeak</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Scale to a fixed peak intensity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/specscaling.jl#L79-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.ScaleWidth" href="#NeXLSpectrum.ScaleWidth"><code>NeXLSpectrum.ScaleWidth</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Scale to a constant dose⋅width (Counts/(nA⋅s/eV))  Requires a spectrum has both :ProbeCurrent &amp; :LiveTime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/specscaling.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.NeXLSpectrumStyle" href="#NeXLSpectrum.NeXLSpectrumStyle"><code>NeXLSpectrum.NeXLSpectrumStyle</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>NeXLSpectrumStyle</code> defines the default look-and-feel for Gadfly.plot(...) as applied to EDS spectra using the Gadfly.plot(...) functions implemented in  <code>NeXLSpectrum</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L4-L8">source</a></section></article><h2 id="Spectrum-Tabulation"><a class="docs-heading-anchor" href="#Spectrum-Tabulation">Spectrum Tabulation</a><a id="Spectrum-Tabulation-1"></a><a class="docs-heading-anchor-permalink" href="#Spectrum-Tabulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, Spectrum}" href="#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, Spectrum}"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NeXLUncertainties.asa(::Type{DataFrame}, spec::Spectrum; properties::Bool = false)</code></pre><p>Converts the spectrum energy and counts data into a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L324-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, AbstractArray{&lt;:Spectrum}}" href="#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, AbstractArray{&lt;:Spectrum}}"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NeXLUncertainties.asa(::Type{DataFrame}, spec::AbstractArray{Spectrum})::DataFrame</code></pre><p>Returns a DataFrame that summarizes the list of spectra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L872-L876">source</a></section></article><h1 id="HyperSpectrum-Manipulation"><a class="docs-heading-anchor" href="#HyperSpectrum-Manipulation">HyperSpectrum Manipulation</a><a id="HyperSpectrum-Manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#HyperSpectrum-Manipulation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.HyperSpectrum" href="#NeXLSpectrum.HyperSpectrum"><code>NeXLSpectrum.HyperSpectrum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HyperSpectrum(arr::Array{T&lt;:Real}, energy::EnergyScale, props::Array{Symbol, Any})

HyperSpectrum(energy::EnergyScale, props::Dict{Symbol,Any}, arr::Array{&lt;:Real}; axisnames = ( &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ), fov = ( 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ), livetime=)
HyperSpectrum(energy::EnergyScale, props::Dict{Symbol,Any}, arr::AxisArray)
HyperSpectrum(energy::EnergyScale, props::Dict{Symbol,Any}, dims::NTuple{&lt;:Integer}, depth::Int, type::Type{Real}; axisnames = ( &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ), fov = ( 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 )</code></pre><p>The HyperSpectrum struct represents a multi-dimensional array of Spectrum objects.  The dimension of a HyperSpectrum may be 1 for a traverse or a line-scan, 2 for a spectrum image or &gt;2 for time-series of spectrum images or multi-slice spectrum images.</p><p>The first constructor is used to create a HyperSpectrum from a raw Array of data.  The second to construct a HyperSpectrum from another HyperSpectrum or an AxisArray.  The third from a description of the intended contents.</p><ul><li><code>axisnames</code>: A list of the names by which the axis can be referred</li><li><code>fov</code>: The full width of the dimension in mm.</li></ul><p>HyperSpectra differ from Array{Spectrum} in that the spectra in a HyperSpectrum must share properties like :ProbeCurrent and :BeamEnergy.  However, each pixel can have it&#39;s own livetime.  HyperSpectrum objects can refer  to line-scans (1D), spectrum images (2D), slice-and-view (3D), time sequenced images (3D), or higher dimension spectrum images.</p><p>Internally, HyperSpectrum reinterpretes an Array{T&lt;:Real, N+1} as an Array{Spectrum{T&lt;:Real},N-1}.</p><p>HyperSpectrum objects can be read from a RPL/RAW file (using <code>readrplraw(filenamebase::AbstractString)</code>) but can be constructed from any Array{&lt;:Real}.</p><p>HyperSpectrum objects can be indexed using the standard Julia array idioms including a single integer index or a CartesianIndex.  For example, to iterate over every spectrum in a HyperSpectrum</p><pre><code class="nohighlight hljs">% Construct a 21 row × 19 column spectrum image with 2048 channels of [0,255].
hs = HyperSpectrum{es, props, (21,19), 2048, UInt8}
for idx in eachindex(hs)
    spec = hs[idx]   % get a Spectrum representing the 2048 channels of data at idx
    spec[22] = 1     % Set the 22nd channel to 1
end
% Indices into a HyperSpectrum are (row, column)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L6-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.linescan" href="#NeXLSpectrum.linescan"><code>NeXLSpectrum.linescan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linescan(hss::HyperSpectrum{T,2,3}, ci1::CartesianIndex{2}, ci2::CartesianIndex{2}, width::Int=1)</code></pre><p>Extract pixels from <code>hss</code> along the line from <code>ci1</code> to <code>ci2</code> as a 1D HyperSpectrum.  The <code>width</code> argument integrates the linescan along a line perpendicular to the primary axis. Only works on 2D SpectrumImages and for odd values of <code>width</code>.   The algorithm does double count the occasional pixel but the length of each perpendicular is maintained at <code>width</code>. The <code>AxisArrays.axes(...)</code> scaling is maintained so lengths on the linescan can be compared to lengths on the original map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L763-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.block" href="#NeXLSpectrum.block"><code>NeXLSpectrum.block</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">block(hss::HyperSpectrum{T,N,NP}, steps::NTuple{N, Int})::HyperSpectrum{T,N,NP} where {T&lt;:Real, N, NP}
block(hss::HyperSpectrum{T,N,NP}, step::Int) where {T&lt;:Real, N, NP}</code></pre><p>Reduce the size of a HyperSpectrum by summing together blocks of adjacent pixels.  For example, <code>steps=(4,4)</code> would sum together blocks of 16 spectra in <code>hss</code> to form a single pixel in the resulting <code>Hyperspectrum</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L729-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.readrplraw" href="#NeXLSpectrum.readrplraw"><code>NeXLSpectrum.readrplraw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readrplraw(rplfilename::AbstractString, rawfilename::AbstractString)
readrplraw(rplio::IO, rawio::IO)</code></pre><p>Read a RPL/RAW file pair from IO or filename into an Array obect.  The reader supports :bigendian, :littleendian ordering and :vector or :image alignment.  Since the Array can be very large it is beneficial to release and collected the associated memory when you are done with the data by assigning <code>nothing</code> to the variable (or allowing it to go out of scope) and then calling <code>GC.gc()</code> to force a garbage collection.</p><pre><code class="nohighlight hljs">* Ordering: The individual data items may be in `:littleendian` or `:bigendian`.
** `:littleendian` =&gt; Intel/AMD and others
** `:bigendian` =&gt; ARM/PowerPC/Motorola
* Alignment:  The data in the file can be organized as `:vector` or `:image`.  However, the data will be</code></pre><p>reorganized into &#39;vector&#39; format when returned as a Array.     **<code>:vector</code> =&gt; Spectrum/data vector as contiguous blocks by pixel     ** <code>:image</code> =&gt; Each channel of data organized in image planes     * Data types: signed/unsigned 8/16/32-bit integers or 16-bit/32-bit/64-bit floats</p><pre><code class="nohighlight hljs">readrplraw(filenamebase::AbstractString)::Array{&lt;:Real}</code></pre><p>Read the files filenamebase<em>&quot;.rpl&quot; and filenamebase</em>&quot;.raw&quot; into an Array.  Maintains the data type of the values in the RAW file.</p><p><strong>Standard LISPIX Parameters in .rpl File</strong></p><p>.rpl files consist of 9 lines.  Each line consists of a &#39;key&#39;&lt;tab&gt;&#39;value&#39; where there is one and only one tab and possibly other space between the parameter name and parameter value. Parameter names are case-insensitive. The first line in the files is &quot;key&lt;tab&gt;value&quot;.  Subsequent lines contain the keys and values described in this table.</p><table><tr><th style="text-align: left"><strong>key</strong></th><th style="text-align: right"><strong>value</strong></th><th style="text-align: left"><strong>description</strong></th></tr><tr><td style="text-align: left">width</td><td style="text-align: right">849</td><td style="text-align: left">pixels per row       integer</td></tr><tr><td style="text-align: left">height</td><td style="text-align: right">846</td><td style="text-align: left">rows                 integer</td></tr><tr><td style="text-align: left">depth</td><td style="text-align: right">4096</td><td style="text-align: left">images or spec pts   integer</td></tr><tr><td style="text-align: left">offset</td><td style="text-align: right">0</td><td style="text-align: left">bytes to skip        integer</td></tr><tr><td style="text-align: left">data-length</td><td style="text-align: right">1</td><td style="text-align: left">bytes per pixel      1, 2, 4, or 8</td></tr><tr><td style="text-align: left">data-type</td><td style="text-align: right">unsigned</td><td style="text-align: left">signed, unsigned, or float</td></tr><tr><td style="text-align: left">byte-order</td><td style="text-align: right">dont-care</td><td style="text-align: left">big-endian, little-endian, or dont-care</td></tr><tr><td style="text-align: left">record-by</td><td style="text-align: right">vector</td><td style="text-align: left">image, vector, or dont-care</td></tr></table><p>This .rpl file indicates the image is 849 pixels wide and 846 pixels high, with 4096 levels in the depth dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/rplraw.jl#L45-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.readptx" href="#NeXLSpectrum.readptx"><code>NeXLSpectrum.readptx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readptx(
    fn::AbstractString, 
    scale::EnergyScale, # Energy scale for hyperspectrum
    props::Dict{Symbol,Any},
    nch::Int; # Number of channels in hyperspectrum
    blocksize = 1,  # Size of blocks to sum to create averaged hyperspectrum
    dets=[true,true,true,true], # Which detectors to include
    frames=1:typemax(Int)) # which frames to include in hyperspectrum
readptx(
    fn::AbstractString, 
    scale::EnergyScale, # Energy scale for hyperspectrum
    nch::Int; # Number of channels in hyperspectrum
    blocksize = 1,  # Size of blocks to sum to create averaged hyperspectrum
    dets=[true,true,true,true], # Which detectors to include
    frames=1:typemax(Int)) # which frames to include in hyperspectrum</code></pre><p>Read a SEMantics .ptx file into a HyperSpectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/semanticsptx.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.readhspy" href="#NeXLSpectrum.readhspy"><code>NeXLSpectrum.readhspy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readhspy(filename::String, name=nothing)</code></pre><p>Read a HyperSpectrum from a HyperSpy-style HDF5 file.  The <code>name</code> argument allows the user to optionally specify an experiment to load.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hspy.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.ishspy" href="#NeXLSpectrum.ishspy"><code>NeXLSpectrum.ishspy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ishspy(filename::String)::Bool</code></pre><p>Is the file a HyperSpy-style HDF5 file?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hspy.jl#L465-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.plane" href="#NeXLSpectrum.plane"><code>NeXLSpectrum.plane</code></a> — <span class="docstring-category">Function</span></header><section><div><p>plane(hss::HyperSpectrum, chs::AbstractUnitRange{&lt;:Integer}, normalize=false)</p><p>Sums a contiguous range of data channels into an Array. The dimension of the result is one less than the dimension of the HyperSpectrum and is stored as a Float64 to ensure that not information is lost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L399-L404">source</a></section><section><div><p>plane(hss::HyperSpectrum, ch::Int, normalize=false)</p><p>Extracts a single channel plane from a HyperSpectrum. The dimension of the result is one less than the dimension of the HyperSpectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L425-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.roiimage" href="#NeXLSpectrum.roiimage"><code>NeXLSpectrum.roiimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">roiimage(hss::HyperSpectrum, chs::AbstractUnitRange{&lt;:Integer})</code></pre><p>Create a count map from the specified contiguous range of channels. (Accounts for differences in :LiveTime between pixels.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L672-L677">source</a></section><section><div><pre><code class="nohighlight hljs">roiimage(hss::HyperSpectrum, cxr::CharXRay)</code></pre><p>Create a count map for the specified characteristic X-ray.  By default, integrates for one FWHM at <code>cxr</code>.  If hss[:Detector] is an <code>EDSDetector</code>, the FWHM is taken from it. Otherwise, a FWHM of 130 eV at Mn Kα is assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L692-L698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.compress" href="#NeXLSpectrum.compress"><code>NeXLSpectrum.compress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compress(hss::HyperSpectrum)</code></pre><p>Returns a HyperSpectrum with smaller or equal storage space to <code>hss</code> without losing or truncating any counts  (note: AbstractFloat compresses to Float32 with loss of precision).  Can change the storage type and/or  reduce the depth of hss.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L363-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.maxpixel" href="#NeXLSpectrum.maxpixel"><code>NeXLSpectrum.maxpixel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maxpixel(hss::HyperSpectrum, filt=ci-&gt;true)
maxpixel(hss::HyperSpectrum, cis::CartesianIndices, filt=ci-&gt;true)
maxpixel(hss::HyperSpectrum, mask::BitArray)
minpixel(hss::HyperSpectrum, filt=ci-&gt;true)
minpixel(hss::HyperSpectrum, cis::CartesianIndices, filt=ci-&gt;true)
minpixel(hss::HyperSpectrum, mask::BitArray)</code></pre><p>Compute Bright&#39;s Max-Pixel derived signal for the entire HyperSpectrum or a rectanglar sub-region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L436-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.colorize" href="#NeXLCore.colorize"><code>NeXLCore.colorize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colorize(hss::HyperSpectrum, cxrs::AbstractVector{CharXRay}, normalize=:All)</code></pre><p>Create RGB colorized images from up to three <code>CharXRay</code> which define channels over which the count signal is integrated. <code>normalize=:All</code> puts the intensities on a common scale using the <code>roiimages(...)</code> method.  Otherwise each image is scaled independently based on the brightest pixel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L711-L718">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.labeledimages" href="#NeXLSpectrum.labeledimages"><code>NeXLSpectrum.labeledimages</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">labeledimages(labels::AbstractVector{&lt;:AbstractString}, images::AbstractVector{&lt;:AbstractArray}; ncols=3, halign = hleft)</code></pre><p>Create a matrix of labeled images.  Useful in Weave, Juno or Jupyter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/labeled.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.labeledimage" href="#NeXLSpectrum.labeledimage"><code>NeXLSpectrum.labeledimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">labeledimage(label::String, image::Array)</code></pre><p>Displays a string label below an image.  Useful in Weave, Juno or Jupyter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/labeled.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.region" href="#NeXLSpectrum.region"><code>NeXLSpectrum.region</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">region(hss::HyperSpectrum{T, N}, ranges::AbstractRange...)::HyperSpectrum where {T&lt;:Real,N}</code></pre><p>Creates a view of a HyperSpectrum to represent the range of pixels within the <code>hss</code> HyperSpectrum.  Does not copy the data or properties so any modifications to the region are also made to <code>hss</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L299-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.indexofmaxpixel" href="#NeXLSpectrum.indexofmaxpixel"><code>NeXLSpectrum.indexofmaxpixel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">indexofmaxpixel(hss::HyperSpectrum, ch::Int) # at channel `ch`
indexofmaxpixel(hss::HyperSpectrum) # all channels
indexofmaxpixel(hss::HyperSpectrum, ch::Int, cis::CartesianIndices)
indexofmaxpixel(hss::HyperSpectrum, cis::CartesianIndices)</code></pre><p>Find the indices producing the maximum value in data[ch] or data[:] within &#39;cis&#39; or full spatial dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L548-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.roiimages" href="#NeXLSpectrum.roiimages"><code>NeXLSpectrum.roiimages</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">roiimages(hss::HyperSpectrum, achs::AbstractVector{&lt;:AbstractUnitRange{&lt;:Integer}})</code></pre><p>Create an array of Gray images representing the intensity in each range of channels in in <code>achs</code>.  They are normalized such the the most intense pixel in any of them defines white. (Accounts for differences in :LiveTime between pixels.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L654-L660">source</a></section><section><div><pre><code class="nohighlight hljs">roiimages(hss::HyperSpectrum, cxrs::AbstractVector{CharXRay})</code></pre><p>Create an array of Gray images representing the intensity in each of the CharXRay lines in <code>cxrs</code>.  They are normalized such the the most intense pixel in any of them defines white. By default, integrates for one FWHM at <code>cxr</code>.  If hss[:Detector] is an <code>EDSDetector</code>, the FWHM  is taken from it.   Otherwise, a FWHM of 130 eV at Mn Kα is assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L701-L708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.livetime!" href="#NeXLSpectrum.livetime!"><code>NeXLSpectrum.livetime!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">livetime!(hss::HyperSpectrum, lt::AbstractFloat, idx...)
livetime!(hss::HyperSpectrum{T,N}, lt::AbstractFloat) # All pixels to lt</code></pre><p>Set the livetime on a per pixel basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/hyperspectrum.jl#L202-L207">source</a></section></article><h1 id="Fitting-Filter"><a class="docs-heading-anchor" href="#Fitting-Filter">Fitting Filter</a><a id="Fitting-Filter-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-Filter" title="Permalink"></a></h1><p>Core methods for constructing <code>FilterFitPacket</code>s and fitting spectra.</p><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.reference" href="#NeXLSpectrum.reference"><code>NeXLSpectrum.reference</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reference( elm::Element, spec::Spectrum, mat::Material=spec[:Composition]; pc = nothing, lt = nothing, e0 = nothing, coating = nothing)::ReferencePacket
reference(els::AbstractVector{Element}, spec::Spectrum, mat::Material = spec[:Composition]; pc = nothing, lt = nothing, e0 = nothing, coating = nothing)::Vector{ReferencePacket}</code></pre><p>Construct a <code>ReferencePacket</code> from a <code>Spectrum</code> collected from the specified <code>Material</code> for the specified <code>Element</code>. Often used with <code>references(...)</code> to build <code>FilterFitPacket</code>s.</p><p>Optional named arguments <code>pc</code>, <code>lt</code>, <code>e0</code>, <code>coating</code> allow you to specify the probe current, live time, beam energy and sample coating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/reference.jl#L96-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.references" href="#NeXLSpectrum.references"><code>NeXLSpectrum.references</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">references(refs::AbstractVector{ReferencePacket}, det::EDSDetector)::FilterFitPacket
references(refs::AbstractVector{ReferencePacket}, fwhm::Float64)::FilterFitPacket</code></pre><p>Constructs a FilterFitPacket from a vector of <code>ReferencePackets</code>.  Each <code>ReferencePacket</code> represents a  single ROI for an element.  It is possible more than one <code>ReferencePacket</code> might be defined for an  elemental ROI.  In this case, the <code>ReferencePacket</code> with the lower index will take preference over later ones.  This allows you to fill in only the missing elemental ROIs using spectra collected from  alternative materials.  For example, a spectrum from F₂Fe is suitable for the Fe K-lines but not the  Fe L-lines. So we might specify F₂Fe first to specify the references for the Fe K-lines and then fill  in the L-lines with a spectrum from pure Fe.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/reference.jl#L156-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.FilterFitPacket" href="#NeXLSpectrum.FilterFitPacket"><code>NeXLSpectrum.FilterFitPacket</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents the processed spectral data necessary to efficiently filter-fit one or more unknown spectra. A <code>FilterFitPacket</code> contains the data necessary to filter the unknown and to apply pre-filtered references. If there are duplicate <code>FilteredReference</code> for an elemental ROI, the preference is for the first one.  This allows you to fill in unavailable &quot;FilteredReference&quot; elemental ROIs with more general ones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/reference.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.suitability" href="#NeXLSpectrum.suitability"><code>NeXLSpectrum.suitability</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">suitability(elm::Element, mats::AbstractSet{&lt;:Material}, det::Detector; maxE=30.0e3)
suitability(elm::Element, det::Detector; maxE=30.0e3, minC=0.1)</code></pre><p>Tabulates the characteristic X-ray peaks for the <code>Element</code> for which there are suitable materials  in <code>mats</code> for the specified detector.  The second form uses a default set of Materials in the file NeXLCore &quot;standards.txt&quot;.</p><p>This function is helpful for determining which <code>Material</code>s are suitable to act as  fitting standards for the specified Element.  It shows how NeXLSpectrum will break up the  characteristic peaks associated with <code>elm</code> into contiguous regions each of which will be  fit independently. NeXLSpectrum attempts to break each element into as many independent  regions as possible dependent on the resolution of the specified <code>EDSDetector</code>.  If there is an interference between one of the other elements in the <code>Material</code> and <code>elm</code> then this peak will not be suitable as a fitting standard.  However, it can be used as a  similar standard.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L440-L456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.suitablefor" href="#NeXLSpectrum.suitablefor"><code>NeXLSpectrum.suitablefor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">suitablefor(
    elm::Element, 
    matOrElms::Union{Material, AbstractSet{Element}}, 
    det::Detector; 
    maxE::Float64 = 1.0e6, 
    ampl::Float64 = 1.0e-5,
    warnme::Bool = true
)::Vector{Tuple{Vector{CharXRay}, UnitRange{Int64}}}</code></pre><p>Given a material or collection of <code>Element</code> which ROIs for element <code>elm</code> is the material a suitable reference on the detector <code>det</code>?   This function provides informational, warning and error messages depending upon the suitability of the material. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L386-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.fit_spectrum" href="#NeXLSpectrum.fit_spectrum"><code>NeXLSpectrum.fit_spectrum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit_spectrum(spec::Spectrum, ffp::FilterFitPacket)::FilterFitResult

fit_spectrum(specs::AbstractVector{&lt;:Spectrum}, ffp::FilterFitPacket)::FilterFitResult</code></pre><p>Fit a <code>Spectrum</code> or a vector of <code>Spectrum</code> using the specified <code>FilterFitPacket</code>.  The result is a <code>FilterFitResult</code> structure which contains k-ratios, residuals, etc. </p><pre><code class="nohighlight hljs">fit_spectrum(hs::HyperSpectrum, ffp::FilterFitPacket; mode::Symbol=:Fast, zero = x -&gt; max(0.0, x))::Array{KRatios}</code></pre><ul><li><code>mode = :Fast</code> - Uses precomputed, filtered &quot;vector&quot; fit method.  No uncertainties are available.</li><li><code>mode = :Intermediate</code> - Uses an optimized full fit without refits for negative k-ratios.</li><li><code>mode = :Full</code> - Uses the full single spectrum fit algorithm including refitting when one or more k-ratio is less than zero.</li></ul><p>Performs a filtered fit on a hyperspectrum returning an <code>Array{KRatios}</code>.</p><p>Selecting a mode:   :Fast is good for generating k-ratio maps or exploratory analysis of a k-ratio map. :Full is best when a   quantitative map of a high count hyperspectrum is desired.  Fit frefsults for major elements are similar for   all three but differ for minor and trace elements.  Particularly when a k-ratio is slightly negative. This   negative k-ratio can effect the other k-ratios.  :Fast also works less well when many elements (&gt;&gt;10) (particularly   interfering elements) are included in the fit. Unfortunately, :Intermediate and :Full slow down when many elements   are fit - O(n(elements)²).</p><p>The following timing on a 512 x 512 x 2048 hyperspectrum fitting 15 elements with 25 distinct ROIs on a fast laptop with 64 GiB memory give a relative feel for the speed of each algorithm.  Yes, :Fast is approximately 20x faster than :Intermediate and used almost 100x less memory.  (Single thread timings)</p><table><tr><th style="text-align: right">mode</th><th style="text-align: right">Run time (s)</th><th style="text-align: right">Allocations</th><th style="text-align: right">Memory (GiB)</th><th style="text-align: right">GC time</th></tr><tr><td style="text-align: right">:Fast</td><td style="text-align: right">44.8</td><td style="text-align: right">3.95 M</td><td style="text-align: right">5.72</td><td style="text-align: right">4.2%</td></tr><tr><td style="text-align: right">:Intermediate</td><td style="text-align: right">1305.1</td><td style="text-align: right">24.83 M</td><td style="text-align: right">523.7</td><td style="text-align: right">2.7%</td></tr><tr><td style="text-align: right">:Full</td><td style="text-align: right">2056</td><td style="text-align: right">2.7 G</td><td style="text-align: right">786.1</td><td style="text-align: right">4.2%</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/reference.jl#L194-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.FilteredReference" href="#NeXLSpectrum.FilteredReference"><code>NeXLSpectrum.FilteredReference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FilteredReference</code></pre><p>Represents the filtered reference spectrum over an ROI. Carries the minimal data necessary to support filter-fitting a single region-of-interest (continguous range of channles) and computing useful output statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L263-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.spectra" href="#NeXLSpectrum.spectra"><code>NeXLSpectrum.spectra</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns a tuple containing the unfiltered spectra associated with the references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/reference.jl#L78-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.elms" href="#NeXLCore.elms"><code>NeXLCore.elms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elms(spec::Spectrum, withcoating = false)::Set{Element}</code></pre><p>Returns a set of the elements associated with this spectrum. <code>withcoating</code> determines whether the coating elements are also added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L405-L410">source</a></section><section><div><p>A list of elements for which there are filtered references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/reference.jl#L83-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.missingReferences" href="#NeXLSpectrum.missingReferences"><code>NeXLSpectrum.missingReferences</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">missingReferences(ffp::FilterFitPacket, elms::Vector{Element}, e0::Float64, ampl=1.0e-5)</code></pre><p>Returns a <code>Vector{Tuple{Vector{CharXRay}, UnitRange{Int64}}}</code> containing the ROIs for which a  <code>FilteredReference</code> is missing from the <code>FilterFitPacket</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/reference.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.BasicFitResult" href="#NeXLSpectrum.BasicFitResult"><code>NeXLSpectrum.BasicFitResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A measured set of correlated k-ratios.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.FilterFitResult" href="#NeXLSpectrum.FilterFitResult"><code>NeXLSpectrum.FilterFitResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FilterFitResult</code></pre><p>Represents the result of fitting a FilteredUnknownW to a FilteredUnknown.</p><p>Struct elements</p><pre><code class="nohighlight hljs">label::UnknownLabel  # Identifies the unknown
kratios::UncertainValues # Labeled with ReferenceLabel objects
roi::UnitRange{Int} # Range of channels fit
raw::Vector{Float64} # Raw spectrum data
residual::Vector{Float64} # Residual spectrum
peakback::Dict{ReferenceLabel,NTuple{3,Float64}} # peak counts, background counts and counts/(nAs)</code></pre><p>Use asa(DataFrame, ffr::FilterFitResult) to summarize in tabular form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L202-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.kratios" href="#NeXLSpectrum.kratios"><code>NeXLSpectrum.kratios</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kratios(ffr::FitResult)::Vector{KRatio}</code></pre><p>The k-ratios associated with each <code>CharXRayLabel</code> as a vector &#39;KRatio&#39; objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.spectrum" href="#NeXLSpectrum.spectrum"><code>NeXLSpectrum.spectrum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spectrum(ffr::FilterFitResult)::Spectrum</code></pre><p>Returns the original unknown spectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.residual" href="#NeXLSpectrum.residual"><code>NeXLSpectrum.residual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">residual(ffr::FilterFitResult)::Spectrum</code></pre><p>A Spectrum containing the histogram representing the unknown spectrum minus the fitted characteristic peaks shapes times the best fit coefficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.covariance" href="#NeXLUncertainties.covariance"><code>NeXLUncertainties.covariance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">covariance(fd::FilteredUnknownW, roi::UnitRange{Int})</code></pre><p>Like extract(fd,roi) except extracts the covariance diagnonal elements over the specified range of channels. <code>roi</code> must be fully contained within the data in <code>fd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filterfit_wls.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.filteredresidual" href="#NeXLSpectrum.filteredresidual"><code>NeXLSpectrum.filteredresidual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filteredresidual(fit::FilterFitResult, unk::FilteredUnknown, ffs::AbstractVector{FilteredReference})::Vector{Float64}</code></pre><p>Computes the difference between the best fit and the unknown filtered spectral data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L371-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.extract" href="#NeXLUncertainties.extract"><code>NeXLUncertainties.extract</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract(fd::FilteredReference, roi::UnitRange{Int})</code></pre><p>Extract the filtered data representing the specified range.  <code>roi</code> must fully encompass the filtered data in <code>fd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L604-L609">source</a></section><section><div><pre><code class="nohighlight hljs">extract(fd::FilteredUnknown, roi::UnitRange{Int})::AbstractVector{Float64}</code></pre><p>Extract the filtered data representing the specified range.  <code>roi</code> must be fully contained within the filtered data in <code>fd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L619-L624">source</a></section></article><h2 id="Filter-Fit-Tabulation"><a class="docs-heading-anchor" href="#Filter-Fit-Tabulation">Filter Fit Tabulation</a><a id="Filter-Fit-Tabulation-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-Fit-Tabulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, FilterFitPacket}" href="#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, FilterFitPacket}"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NeXLUncertainties.asa(::Type{DataFrame}, ffp::FilterFitPacket)</code></pre><p>Summarize the <code>FilteredReference</code> structs within a <code>FilterFitPacket</code> as a <code>DataFrame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/reference.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, AbstractVector{&lt;:FitResult}}" href="#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, AbstractVector{&lt;:FitResult}}"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NeXLUncertainties.asa(::Type{DataFrame}, ffrs::AbstractVector{&lt;:FitResult}; charOnly = true, withUnc = false, format = :normal # :pivot or :long)</code></pre><p>Return generic <code>FitResult</code> as a DataFrame.</p><p>Format:</p><ul><li>:normal - One row per spectrum, one column per k-ratio</li><li>:pivot - One row per ROI, one column per spectrum (optional: column for 1σ uncertainty on k-ratio)</li><li>:long - One row per spectrum, feature, measured k-ratio</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L119-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, FilterFitResult}" href="#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, FilterFitResult}"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NeXLUncertainties.asa(
    ::Type{DataFrame}, 
    ffr::FilterFitResult; 
    charOnly::Bool=true, 
    material=nothing,
    mc = XPP, fc=ReedFluorescence,
    columns = () # Selected from ( :roi, :peakback, :counts, :dose )
)::DataFrame</code></pre><p>Tabulate details about each region-of-interest in the &#39;FilterFitResult&#39; in a &#39;DataFrame&#39;.</p><ul><li>If charOnly then only display characteristic X-ray data (not escapes etc.)</li><li>If <code>material</code> is a Material then the computed k-ratio (KCalc) will also be tabulated along with kmeas/kcalc (KoKCalc).</li><li>columns - Select optional column outputs (see below)</li></ul><p>Columns:</p><ul><li>Spectrum : UnknownLabel - Identifies the fit spectrum</li><li>Feature  : Label - Identifies the fit feature (Vector{CharXRay} or other)</li><li>Reference: String - Name of reference against which :Spectrum was fit over :Feature</li><li>K : Float64 - The multiplicative fit constant</li><li>dK : Float64 - The 1σ uncertainty in :K</li><li>:Start : Int - Start index for fit channels (:roi ∈ columns)</li><li>:Stop : Int - Stop index for fit channels  (:roi ∈ columns)</li><li>:Peak : Float64 - Total counts in characteristic peak (:peakback ∈ columns)</li><li>:Back : Float64 - Total counts in background under the characteristic peak (:peakback ∈ columns)</li><li>:PtoB : Float64 - Peak-to-Background assuming 10 eV/channel (:peakback ∈ columns)</li><li>:KCalc : Float64 - Computed k-ratio assuming a composition. (Requires <code>material</code> argument to be specified.)</li><li>:KoKcalc : Float64 - Ratio of measured/computed k-ratio.  (Requires <code>material</code> argument to be specified.)</li><li>:LiveTime : Float64 - Acquisiton live time (s) (:dose ∈ columns)</li><li>:ProbeCurrent : Float64 - Probe current (nA) (:dose ∈ columns)</li><li>:DeadPct : Float64 - Dead time in ProbeCurrent (:dose ∈ columns)</li><li>:Counts : Float64 - Total counts in characteristic peak (:counts ∈ columns)</li><li>:RefCountsPernAs : Float64 - Estimated counts in :Reference in :Feature per unit dose.  (:counts ∈ columns)</li><li>:CountsPernAs : Float64 - Estimated counts in :Spectrum in :Feature per unit dose.  (:counts ∈ columns)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L273-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, FitResult}" href="#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, FitResult}"><code>NeXLUncertainties.asa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NeXLUncertainties.asa(::Type{DataFrame}, fr::FitResult; withUnc = false)</code></pre><p>Summarize the ROI and k-ratio data within a <code>FitResult</code> structure as a <code>DataFrame</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L176-L180">source</a></section></article><h2 id="Filter-Fit-Plotting"><a class="docs-heading-anchor" href="#Filter-Fit-Plotting">Filter Fit Plotting</a><a id="Filter-Fit-Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-Fit-Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{VectorQuant, UnitRange}" href="#Gadfly.plot-Tuple{VectorQuant, UnitRange}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gadfly.plot(vq::VectorQuant, chs::UnitRange)</code></pre><p>Plots the &quot;vectors&quot; used to quantify various elements/regions-of-interest over the range of channels specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L491-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{TopHatFilter, FilteredReference}" href="#Gadfly.plot-Tuple{TopHatFilter, FilteredReference}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(ff::TopHatFilter, fr::FilteredReference)</code></pre><p>Plot a color map showing the filter data relevant to filtering the specified <code>FilteredReference</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L479-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{FilteredReference}" href="#Gadfly.plot-Tuple{FilteredReference}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gadfly.plot(fr::FilteredReference; palette = NeXLPalette))</code></pre><p>Plot a filtered reference spectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L431-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{FilterFitPacket}" href="#Gadfly.plot-Tuple{FilterFitPacket}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gadfly.plot(ffp::FilterFitPacket; kwargs...)</code></pre><p>Plots the reference spectra which were used to construct a <code>FilterFitPacket</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L569-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{FilterFitResult, Union{Nothing, AbstractUnitRange{&lt;:Integer}}}" href="#Gadfly.plot-Tuple{FilterFitResult, Union{Nothing, AbstractUnitRange{&lt;:Integer}}}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gadfly.plot(
    ffr::FilterFitResult,
    roi::Union{Nothing,AbstractUnitRange{&lt;:Integer}} = nothing;
    palette = NeXLPalette,
    style = NeXLSpectrumStyle,
    xmax::Union{AbstractFloat, Nothing} = nothing,
    comp::Union{Material, Nothing} = nothing,
    det::Union{EDSDetector, Nothing} = nothing,
    resp::Union{AbstractArray{&lt;:AbstractFloat,2},Nothing} = nothing,
    yscale = 1.0
)</code></pre><p>Plot the sample spectrum, the residual and fit regions-of-interests and the associated k-ratios.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L331-L345">source</a></section></article><h2 id="Advanced-Filter-Fitting"><a class="docs-heading-anchor" href="#Advanced-Filter-Fitting">Advanced Filter Fitting</a><a id="Advanced-Filter-Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Filter-Fitting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.TopHatFilter" href="#NeXLSpectrum.TopHatFilter"><code>NeXLSpectrum.TopHatFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The TopHatFilter struct represents a zero-sum symmetric second-derivative-like filter that when applied to spectral data has the property of suppressing constant and slowly varying signals (like the continuum) while retaining a linear signal for faster changing signals like the characteristic peaks.</p><p>See</p><ul><li>F. H. Schamber Proc Symposium of &quot;X-ray Fluorscence Analysis on Environmental Samples&quot; Chapel Hill 1976 T Dzubay Ed.</li><li>P. Statham Anal Chem 49 no 14 Dec 1977</li></ul><p>The TopHatFilter struct optimizes the memory and CPU use when applying top-hat filters to spectrum data.</p><p>The easiest way to implement a top-hat filter is as matrix F.  The rows represent the filters.  The product of the filter and the data vector is the filtered spectrum.  The product of the filter times a diagnonal matrix constructed from the data times the transpose of the filter is the covariance of the filtered data.  The diagonal matrix constructed from the spectrum data is the covariance matrix associated with the spectrum data because the channels in the spectrum data are independent (thus the matrix is diagnonal) and the magnitude equals the counts in each channels because the spectrum data is nominally Poissonian and in the large number limit, the variance of a Poissonian random variable is the number itself (σ=sqrt(N) =&gt; Var = N)</p><p>Notes on memory and code optimization: The filter matrix is banded diagonal.  Approximately, 2.5% of the elements are non-zero.  This suggest use of the BandedMatrix type.  The most expensive operation is calculating F⋅D⋅Fᵀ, the covariance matrix of the filtered data. D is a diagonal matrix and so computing each element in F⋅D⋅Fᵀ reduces to a sum over a single variable. Furthermore, the weighted least squares fit doesn&#39;t require the full F⋅D⋅Fᵀ, just diag(F⋅D⋅Fᵀ).  However, it turns out that we can do better implementing our own banded matrix type largely because D is fully diagonal and the matrix product F⋅D⋅Fᵀ reduces down to a sum over a single variable.  The product F⋅d and F⋅D⋅Fᵀ are readily implemented as element-by-element multiplies and sums.  Thus storing the filter as offsets and row filters is efficient in both memory and CPU use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L33-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.ConstantWidthFilter" href="#NeXLSpectrum.ConstantWidthFilter"><code>NeXLSpectrum.ConstantWidthFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantWidthFilter</code></pre><p>A top-hat filter that has constant width determined by FWHM at Mn Kα for all channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.GaussianFilter" href="#NeXLSpectrum.GaussianFilter"><code>NeXLSpectrum.GaussianFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussianFilter</code></pre><p>A Gaussian-shaped filter that varies in width with the FWHM of the detector.  The Gaussian is offset to ensure the sum of the filter elements is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.VariableWidthFilter" href="#NeXLSpectrum.VariableWidthFilter"><code>NeXLSpectrum.VariableWidthFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VariableWidthFilter</code></pre><p>A top-hat filter that varies in width with the FWHM of the detector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.tophatfilter" href="#NeXLSpectrum.tophatfilter"><code>NeXLSpectrum.tophatfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tophatfilter(
    charLabel::CharXRayLabel,
    thf::TopHatFilter,
    scale::Float64 = 1.0,
    tol::Float64 = 1.0e-6,
)::FilteredReference</code></pre><p>For filtering an ROI on a reference spectrum. Process a portion of a Spectrum with the specified filter.  Use a simple edge-based background model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L521-L531">source</a></section><section><div><pre><code class="nohighlight hljs">tophatfilter(
  reflabel::ReferenceLabel,
  roi::UnitRange{Int},
  thf::TopHatFilter,
  scale = 1.0,
  tol = 1.0e-6
)::FilteredReference</code></pre><p>For filtering an ROI on a reference spectrum. Process a portion of a Spectrum with the specified filter. Use a naive linear background model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L566-L577">source</a></section><section><div><pre><code class="nohighlight hljs">tophatfilter(spec::Spectrum, thf::TopHatFilter, scale::Float64=1.0, tol::Float64 = 1.0e-4)::FilteredUnknown</code></pre><p>For filtering the unknown spectrum. Defaults to the weighted fitting model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filterfit_wls.jl#L68-L72">source</a></section><section><div><pre><code class="nohighlight hljs">tophatfilter(::Type{FilteredUnknownW}, spec::Spectrum, thf::TopHatFilter, scale::Float64=1.0, tol::Float64 = 1.0e-4)::FilteredUnknownW</code></pre><p>For filtering the unknown spectrum. Process the full Spectrum with the specified filter for use with the weighted least squares model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filterfit_wls.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.buildfilter" href="#NeXLSpectrum.buildfilter"><code>NeXLSpectrum.buildfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">buildfilter(det::Detector, a::Float64=1.0, b::Float64=2.0)::TopHatFilter</code></pre><p>Build the default top-hat filter for the specified detector with the specified top and base parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L156-L160">source</a></section><section><div><pre><code class="nohighlight hljs">buildfilter(::Type{&lt;:TopHatFilterType}, det::Detector, a::Float64=1.0, b::Float64=1.0)::TopHatFilter</code></pre><p>Build a top-hat-style filter for the specified detector with the specified top and base parameters. The VariableWidthFilter and ConstantWidthFilter types are currently supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L164-L169">source</a></section><section><div><pre><code class="nohighlight hljs">buildfilter(::Type{GaussianFilter}, det::Detector, a::Float64=1.0, b::Float64=5.0)::TopHatFilter</code></pre><p>Build a top-hat filter with Gaussian shape whose width varies with the detector&#39;s resolution as a function of X-ray energy for the specified detector with the specified top and base parameters. The <code>a</code> parameter corresponds to the filter width relative to the detector resolution expressed as Gaussian width.  So <code>a=1</code> is a filter whose width equals the detector resolution at each energy.  The <code>b</code> parameter is the extent of the filter in Gaussian widths.  The default <code>a=1, b=5</code> corresponds to a  filter that has the same resolution as the detector and an extent of 2.5 Gaussian widths above and below the center channel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L221-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.FilteredUnknownW" href="#NeXLSpectrum.FilteredUnknownW"><code>NeXLSpectrum.FilteredUnknownW</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FilteredUnknownW</code></pre><p>Represents the unknown in a filter fit using the weighted fitting model.  This is an approximation that produces over optimistic resulting covariance matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filterfit_wls.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.filterfit" href="#NeXLSpectrum.filterfit"><code>NeXLSpectrum.filterfit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filterfit(unk::FilteredUnknownW, ffs::AbstractVector{FilteredReference}, forcezeros = true)::FilterFitResult</code></pre><p>Filter fit the unknown against ffs, an array of FilteredReference and return the result as an FilterFitResult object. By default use the generalized LLSQ fitting (pseudo-inverse implementation).</p><p>This function is designed to reperform the fit if one or more k-ratio is less-than-or-equal-to zero.  The FilteredReference corresponding to the negative value is removed from the fit and the fit is reperformed. How the non-positive value is handled is determine by forcezeros. If forcezeros=true, then the returned k-ratio for the non-positive value will be set to zero (but the uncertainty remains the fitted one).  However, if forcezeros=false, then the final non-positive k-ratio is returned along with the associated uncertainty.  forcezeros=false is better when a number of fit k-ratio sets are combined to produce an averaged k-ratio with reduced uncertainty. forcezeros=true would bias the result positive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filterfit_wls.jl#L134-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.isvisible" href="#NeXLSpectrum.isvisible"><code>NeXLSpectrum.isvisible</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isvisible(cxrs::AbstractVector{&lt;:SpectrumFeature}, det::Detector)</code></pre><p>Returns the characteristic x-rays that are visible on the specified detector (ie. Between the LLD and the maximum channel).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L339-L344">source</a></section><section><div><pre><code class="nohighlight hljs">isvisible(sf::SpectrumFeature, det::Detector)</code></pre><p>Is <code>sf</code> visible on the specified Detector?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L567-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.ReferenceLabel" href="#NeXLSpectrum.ReferenceLabel"><code>NeXLSpectrum.ReferenceLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReferenceLabel</code></pre><p>A label associated with reference spectra.  The label encapsulates the original spectrum and the range of channels represented by this reference object.  structs that extend ReferenceLabel should have <code>.roi</code>, <code>.spectrum</code> and &quot;.hash&quot;  fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitlabels.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.SpectrumFeature" href="#NeXLSpectrum.SpectrumFeature"><code>NeXLSpectrum.SpectrumFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SpectrumFeature</code></pre><p>A union representing the different type of peak-like features (helpful and harmful) that can appear in a spectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/features.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.CharXRayLabel" href="#NeXLSpectrum.CharXRayLabel"><code>NeXLSpectrum.CharXRayLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CharXRayLabel</code></pre><p>A ReferenceLabel that represents a reference spectrum or reference properties associated with a set of  characteristic x-rays (CharXRay) objects over a contiguous range of spectrum channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitlabels.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.EscapeLabel" href="#NeXLSpectrum.EscapeLabel"><code>NeXLSpectrum.EscapeLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EscapeLabel</code></pre><p>A ReferenceLabel&lt;:FilteredLabel that Represents a reference spectrum associated with an escape peak from a set of characteristic x-rays (CharXRay) objects over a contiguous range of spectrum channels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitlabels.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.UnknownLabel" href="#NeXLSpectrum.UnknownLabel"><code>NeXLSpectrum.UnknownLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnknownLabel</code></pre><p>A Label that represents the unknown spectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitlabels.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.charXRayLabels" href="#NeXLSpectrum.charXRayLabels"><code>NeXLSpectrum.charXRayLabels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">charXRayLabels(#
  spec::Spectrum, #
  elm::Element, #
  allElms::AbstractSet{Element}, #
  det::Detector, #
  ampl::Float64, #
  maxE::Float64=1.0e6)::Vector{SpectrumFeature}</code></pre><p>Creates a vector of CharXRayLabel objects associated with &#39;elm&#39; for a spectrum containing the elements &#39;allElms&#39; assuming that it was collected on &#39;det&#39;.  ROIs in which other elements from &#39;allElms&#39; interfere with &#39;elm&#39; will not be included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/filter.jl#L351-L363">source</a></section></article><h1 id="Matrix-Correction"><a class="docs-heading-anchor" href="#Matrix-Correction">Matrix Correction</a><a id="Matrix-Correction-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Correction" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="NeXLMatrixCorrection.quantify" href="#NeXLMatrixCorrection.quantify"><code>NeXLMatrixCorrection.quantify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">NeXLMatrixCorrection.quantify(
  ffr::FitResult;
  strip::AbstractVector{Element} = [],
  mc::Type{&lt;:MatrixCorrection} = XPP,
  fl::Type{&lt;:FluorescenceCorrection} = ReedFluorescence,
  kro::KRatioOptimizer = SimpleKRatioOptimizer(1.5),
)::IterationResult</code></pre><p>Facilitates converting <code>FilterFitResult</code> or <code>BasicFitResult</code> objects into estimates of composition by extracting k-ratios from measured spectra and applying matrix correction algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/quantify.jl#L1-L12">source</a></section><section><div><pre><code class="nohighlight hljs">NeXLMatrixCorrection.quantify(
    spec::Union{Spectrum,AbstractVector{&lt;:Spectrum}},
    ffp::FilterFitPacket;
    kwargs...
)::IterationResult</code></pre><p>Failitates quantifying spectra.  First filter fits and then matrix corrects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/quantify.jl#L28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLMatrixCorrection.estimatecoating" href="#NeXLMatrixCorrection.estimatecoating"><code>NeXLMatrixCorrection.estimatecoating</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">NeXLMatrixCorrection.estimatecoating(fr::FitResult, substrate::Material, coating::Material, cxr::CharXRay, mc::Type{&lt;:MatrixCorrection}=XPP)::Film</code></pre><p>Estimate the mass-thickness of <code>coating</code> on bulk <code>substrate</code> using the X-ray <code>cxr</code> for which there is KRatio in <code>fr</code>.  The result is assigned to the properties of <code>fr</code> so that it can be account for in the matrix correction process.</p><p>This method is intended for use on standards where the substrate composition is known a priori.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L387-L394">source</a></section></article><h2 id="Standardization"><a class="docs-heading-anchor" href="#Standardization">Standardization</a><a id="Standardization-1"></a><a class="docs-heading-anchor-permalink" href="#Standardization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.extractStandards" href="#NeXLSpectrum.extractStandards"><code>NeXLSpectrum.extractStandards</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extractStandards(ffr::FitResult, elm::Element, mat::Material)::Vector{KRatio}</code></pre><p>Extract a <code>Vector{KRatio}</code> for <code>elm::Element</code> from a <code>ffr::FilterFitResult</code> measured from <code>mat::Material</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L69-L73">source</a></section><section><div><pre><code class="nohighlight hljs">extractStandards(ffr::FitResult, cxrs::AbstractVector{CharXRay}, mat::Material)::Vector{KRatio}</code></pre><p>Extract a <code>KRatio</code> for the <code>CharXRay</code> from a <code>FilterFitResult</code> associated with the <code>Material</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.standardize" href="#NeXLCore.standardize"><code>NeXLCore.standardize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">NeXLCore.standardize(ffr::FilterFitResult, standard::FilterFitResult, material::Material, els=elms(material))::FilterFitResult
NeXLCore.standardize(ffrs::Vector{FilterFitResult}, standard::FilterFitResult, material::Material, els=elms(material))::Vector{FilterFitResult}
NeXLCore.standardize(ffr::FilterFitResult, standards::AbstractArray{KRatio})::FilterFitResult
NeXLCore.standardize(ffrs::Vector{FilterFitResult}, standards::AbstractArray{KRatio})::FilterFitResult</code></pre><p>Apply the standard <code>KRatio</code>s to the <code>FilterFitResult</code> producing a re-standardized <code>FilterFitResult</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/standardize.jl#L117-L124">source</a></section></article><h1 id="EDS-Detectors"><a class="docs-heading-anchor" href="#EDS-Detectors">EDS Detectors</a><a id="EDS-Detectors-1"></a><a class="docs-heading-anchor-permalink" href="#EDS-Detectors" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.Detector" href="#NeXLSpectrum.Detector"><code>NeXLSpectrum.Detector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Detector</code></pre><p>An abstract type defining the characteristics of an X-ray detector.</p><p>Implements:</p><pre><code class="nohighlight hljs">channelcount(det::Detector)::Int
scale(det::Detector)::EnergyScale
resolution(eV::Float64, det::Detector)::Float64 # FWHM at eV
energy(ch::Int, det::Detector)::Float64
channel(eV::Float64, det::Detector)::Int
profile(energy::Float64, xrayE::Float64, det::Detector)
lld(det::Detector)::Int
isvisible(sf::SpectrumFeature, det::Detector)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L227-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.EDSDetector" href="#NeXLSpectrum.EDSDetector"><code>NeXLSpectrum.EDSDetector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EDSDetector</code></pre><p>Types extending EDSDetector must have member variables</p><pre><code class="nohighlight hljs">channelcount::Int # Number of channels
scale::EnergyScale # Detector calibration funtion
resolution::Resolution # Detector lineshape function
lld::Int # low level discriminator</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L270-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.resolution" href="#NeXLSpectrum.resolution"><code>NeXLSpectrum.resolution</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&quot;     resolution(eV::Float64, res::Resolution)     resolution(eV::Float64, det::EDSDetector)</p><p>The FWHM at eV for the <code>&lt;:Resolution</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L157-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.Resolution" href="#NeXLSpectrum.Resolution"><code>NeXLSpectrum.Resolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Resolution</code></pre><p>An abstract type describing the channel dependence of the resolution of an EDS detector.</p><p>Implements:</p><pre><code class="nohighlight hljs">resolution(eV::Float64, res::Resolution)::Float # Resolution at specified energy
profile(energy::Float64, xrayE::Float64, res::Resolution) # Amplitude for a signal at the specified energy at the specified energy
extent(xrayE::Float64, res::Resolution, ampl::Float64)::Tuple{2,Float} # The range of channels over which the signal exceeds ampl</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L122-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.simpleEDSwICC" href="#NeXLSpectrum.simpleEDSwICC"><code>NeXLSpectrum.simpleEDSwICC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simpleEDSwICC(chCount::Integer, width::Float64, offset::Float64, fwhmatmnka::Float64, lld::Int=channel(150.0 eV))</code></pre><p>Construct simple model of an EDS detector with incomplete charge collection at low X-ray energies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L486-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.MnKaResolution" href="#NeXLSpectrum.MnKaResolution"><code>NeXLSpectrum.MnKaResolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MnKaResolution</code></pre><p>Uses Chuck Fiori&#39;s simple function relating the FWHM at eV to the FWHM at another energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.Beryllium" href="#NeXLSpectrum.Beryllium"><code>NeXLSpectrum.Beryllium</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Beryllium(thickness=5.0e-4)</code></pre><p>Construct a beryllium window.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/window.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.AP33Tabulation" href="#NeXLSpectrum.AP33Tabulation"><code>NeXLSpectrum.AP33Tabulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AP33Tabulation()
AP5Tabulation()</code></pre><p>Construct tabulated window models for the Moxtek AP3.3 and AP5 windows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/window.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.matches" href="#NeXLSpectrum.matches"><code>NeXLSpectrum.matches</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matches(spec::Spectrum, det::Detector, tol::Float64 = 1.0)::Bool
matches(spec1::Spectrum, spec2::Spectrum, tol::Float64 = 1.0)::Bool</code></pre><p>Does the calibration of the Spectrum (approximately) match the calibration of the Detector or the other Spectrum?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L372-L378">source</a></section><section><div><pre><code class="nohighlight hljs">matches(cxrl::CharXRayLabel, std::KRatio)
matches(cxrl::CharXRayLabel, std::StandardLabel)</code></pre><p>Does the measured <code>CharXRayLabel</code> match the standard?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/standardize.jl#L25-L30">source</a></section></article><h1 id="EDS-Detector-Plotting"><a class="docs-heading-anchor" href="#EDS-Detector-Plotting">EDS Detector Plotting</a><a id="EDS-Detector-Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#EDS-Detector-Plotting" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{DetectorEfficiency}" href="#Gadfly.plot-Tuple{DetectorEfficiency}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gadfly.plot(deteff::DetectorEfficiency, emax = 20.0e3)</code></pre><p>Plots the detector efficiency function assuming the detector is perpendicular to the incident X-rays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L537-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gadfly.plot-Tuple{DetectorEfficiency, Any}" href="#Gadfly.plot-Tuple{DetectorEfficiency, Any}"><code>Gadfly.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gadfly.plot(deteff::DetectorEfficiency, emax = 20.0e3)</code></pre><p>Plots the detector efficiency function assuming the detector is perpendicular to the incident X-rays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L537-L541">source</a></section></article><h2 id="Energy-Axis-Scales-for-EDS-Detectors"><a class="docs-heading-anchor" href="#Energy-Axis-Scales-for-EDS-Detectors">Energy Axis Scales for EDS Detectors</a><a id="Energy-Axis-Scales-for-EDS-Detectors-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-Axis-Scales-for-EDS-Detectors" title="Permalink"></a></h2><p>Structures and functions that implement the energy scale functions for EDS detectors.</p><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.EnergyScale" href="#NeXLSpectrum.EnergyScale"><code>NeXLSpectrum.EnergyScale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EnergyScale</code></pre><p>An EnergyScale is a way of representing the energy axis associated with X-ray data. The scale may be linear, polynomial or ??? to handle the various different non-linearities that happen with EDS detectors plus we can also handle WDS wavescans.</p><p>Implements:</p><pre><code class="nohighlight hljs">channel(::Type{Float64}, eV::AbstractFloat, sc::EnergyScale)::Float64
energy(ch::Int, sc::EnergyScale)::Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.LinearEnergyScale" href="#NeXLSpectrum.LinearEnergyScale"><code>NeXLSpectrum.LinearEnergyScale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearEnergyScale</code></pre><p>An EnergyScale implementation parameterized by channel width and offset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.PolyEnergyScale" href="#NeXLSpectrum.PolyEnergyScale"><code>NeXLSpectrum.PolyEnergyScale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PolyEnergyScale</code></pre><p>An energy scale based on a polynomial function of the channel index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.fwhm" href="#NeXLSpectrum.fwhm"><code>NeXLSpectrum.fwhm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fwhm(gauss::Float64)</code></pre><p>Converts Gaussian width to full-width half-max.  See also gaussianwidth</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.gaussianwidth" href="#NeXLSpectrum.gaussianwidth"><code>NeXLSpectrum.gaussianwidth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gaussianwidth(fwhm::Float64)</code></pre><p>Converts full-width half-max to Gaussian width.  See also fwhm(...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.resolution_to_fwhm" href="#NeXLSpectrum.resolution_to_fwhm"><code>NeXLSpectrum.resolution_to_fwhm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resolution_to_fwhm(::Type{MnKaResolution}, res::Float64, eV::Float64)</code></pre><p>Given the FWHM at res predict the resolution at Mn Kα.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L148-L152">source</a></section></article><h2 id="Multi-Detector-Functions"><a class="docs-heading-anchor" href="#Multi-Detector-Functions">Multi-Detector Functions</a><a id="Multi-Detector-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Detector-Functions" title="Permalink"></a></h2><p>Functions for interpreting and manipulating spectr collected on multiple detectors simultaneously.</p><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.multicompare" href="#NeXLSpectrum.multicompare"><code>NeXLSpectrum.multicompare</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">multicompare(specs::AbstractArray{Spectrum{T}}) where {T &lt;: Real}</code></pre><p>Compares the intensity for the spectra in <code>specs</code> against the mean intensity on a channel-by-channel basis.  Compute the ratio for each channel in each  spectrum of the spectrum intensity over the mean intensity for that channel. You expect the ratio to be unity when the spectra are identical and deviate from unity when the spectra are different. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/multidet.jl#L165-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.multimean" href="#NeXLSpectrum.multimean"><code>NeXLSpectrum.multimean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">multimean(specs::Spectrum{T})::Spectrum{T} where {T &lt;: Real}</code></pre><p>Average on a channel-by-channel basis spectra collected from multiple detectors simultaneously from the same electrons interacting with the same material for  the real-time.  The detectors should be calibrated close to identically to maintain the detector resolution and peak positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/multidet.jl#L148-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.multisum" href="#NeXLSpectrum.multisum"><code>NeXLSpectrum.multisum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">multisum(specs::Spectrum{T})::Spectrum{T} where {T &lt;: Real}</code></pre><p>Sum together spectra collected from multiple detectors simultaneously from the same electrons interacting with the same material for the real-time.   The detectors should be calibrated close to identically to maintain the detector resolution and peak positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/multidet.jl#L131-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.plot_multicompare" href="#NeXLSpectrum.plot_multicompare"><code>NeXLSpectrum.plot_multicompare</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot_multicompare(specs::AbstractArray{Spectrum{T}}; minE=200.0, maxE=0.5*specs[1][:BeamEnergy]) where { T&lt;: Real}</code></pre><p>Compare spectra collected simultaneously on multiple detectors in a single acquisition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/gadflysupport.jl#L609-L613">source</a></section></article><h2 id="Bremsstrahlung"><a class="docs-heading-anchor" href="#Bremsstrahlung">Bremsstrahlung</a><a id="Bremsstrahlung-1"></a><a class="docs-heading-anchor-permalink" href="#Bremsstrahlung" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.continuumrois" href="#NeXLSpectrum.continuumrois"><code>NeXLSpectrum.continuumrois</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">continuumrois(elems, det::EDSDetector, minE::Float64, maxE::Float64)</code></pre><p>Compute the ROIs for the contiguous continuum regions for the specified elements <code>elems</code> on an <code>EDSDetector</code> for the specified range of energies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/continuum.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.generated" href="#NeXLSpectrum.generated"><code>NeXLSpectrum.generated</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generated(cm::ContinuumModel, ea::Float64)</code></pre><p>Compute the intensity of the measured continuum generated from the material and conditions specified in the continuum model object at the specified measured energy <code>ea</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/continuum.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.emitted" href="#NeXLSpectrum.emitted"><code>NeXLSpectrum.emitted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">emitted(cm::ContinuumModel, ea::Float64)</code></pre><p>Compute the intensity of the measured continuum emitted from the material and conditions specified in the continuum model object at the specified measured energy <code>ea</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/continuum.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.fitcontinuum" href="#NeXLSpectrum.fitcontinuum"><code>NeXLSpectrum.fitcontinuum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fitcontinuum(
  spec::Spectrum,
  resp::AbstractArray,
  rois::Vector{UnitRange};
  brem::Type{&lt;:NeXLBremsstrahlung} = Castellano2004a,
  mc::Type{&lt;:MatricCorrection} = Riveros1993,
)

Fit a continuum model to the specified range of channels (`rois`).  The `resp` argument is a matrix which describes</code></pre><p>the detector response on a channel-by-channel basis.  It can be calculated from an <code>EDSDetector</code> and an <code>DetectorEfficiency</code> using <code>resp = NeXLSpectrum.detectorresponse(det, eff)</code>.  The <code>Spectrum</code> object must have the :Composition, :BeamEnergy and :TakeOffAngle properties defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/continuum.jl#L49-L62">source</a></section><section><div><pre><code class="nohighlight hljs">fitcontinuum(
  spec::Spectrum,
  det::EDSDetector,
  resp::AbstractArray{&lt;:Real,2}; #
  minE::Float64 = 1.5e3,
  maxE::Float64 = 0.95 * spec[:BeamEnergy],
  brem::Type{&lt;:NeXLBremsstrahlung} = Castellano2004a,
  mc::Type{&lt;:MatrixCorrection} = Riveros1993,
)</code></pre><p>Fit the continuum from ROIs determined from the data within the spectrum (:Composition, :BeamEnergy &amp; :TakeOffAngle). The ROIs are computed using <code>continuumrois(...)</code> and each roi is fit seperately.</p><pre><code class="nohighlight hljs">fittedcontinuum(
  spec::Spectrum,
  det::EDSDetector,
  resp::AbstractArray{&lt;:Real,2}; #
  mode = :Global [ | :Local ] # Fit to all ROIs simultaneously (:Global) or to each roi independently (:Local)
  minE::Float64 = 1.5e3,
  maxE::Float64 = 0.95 * spec[:BeamEnergy],
  brem::Type{&lt;:NeXLBremsstrahlung} = Castellano2004a,
  mc::Type{&lt;:MatrixCorrection} = Riveros1993,
)::Spectrum</code></pre><p>Fit the continuum under the characteristic peaks by fitting the closest continuum ROIs.  The low energy peaks are fit using the continuum immediately higher in energy and the high energy peaks are fit using the continuum on both sides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/continuum.jl#L149-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.detectorresponse" href="#NeXLSpectrum.detectorresponse"><code>NeXLSpectrum.detectorresponse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">detectorresponse(det::EDSDetector, eff::DetectorEfficiency, incidence::Float64=π/2)::AbstractMatrix</code></pre><p>Build a matrix which models the detector response including aspects like the detector efficiency, the resolution, the escape peaks.  All the warts that can be modeled within a linear model but not things like coincidence peaks that are non-linear.  This function can (!should!) be specialized for more sophisticated detector models that include more warts.</p><p>Example:</p><pre><code class="nohighlight hljs">genint = computegeneratedintensity(....) # Either characteristic or Bremsstrahlung...
det = simpleEDS(4096, 5.0, 0.0, 132.0, 10)
eff = SDDEfficiency(AP33Tabulation(); thickness=0.0370, deadlayer=30.0e-7, entrance=Film(pure(n&quot;Al&quot;), 10.0e-7))
resp = detectorresponse(det, eff)
# finally compute the measured signal
measured = resp*genint</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detefficiency.jl#L41-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.weight" href="#NeXLCore.weight"><code>NeXLCore.weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weight(esc::EscapeArtifact, factor=0.01)</code></pre><p>The weight of an EscapeArtifact which is factor * weight(esc.xray).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/features.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.extents" href="#NeXLSpectrum.extents"><code>NeXLSpectrum.extents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extents(cxrs::AbstractVector{&lt;:SpectrumFeature},det::Detector,ampl::Float64)::Vector{UnitRange{Int}}</code></pre><p>Determine the contiguous ranges of channels over which the specified collection of X-rays will be measured on the specified detector.  The ampl determines the extent of each peak.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L348-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.profile" href="#NeXLSpectrum.profile"><code>NeXLSpectrum.profile</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&quot;     profile(energy::Float64, xrayE::Float64, res::Resolution)</p><p>Calculates a Gaussian profile for an X-ray of xrayE (eV) for a detector with the specified resolution.  Maintains normalization to a sum of unity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L179-L185">source</a></section><section><div><p>&quot;     profile(ch::Int, xrayE::Float64, det::EDSDetector)</p><p>Calculates the profile for an X-ray of xrayE (eV) for a detector with the specified resolution.  Performs a crude integration to account for the channel width.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/detector.jl#L322-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.subtractcontinuum" href="#NeXLSpectrum.subtractcontinuum"><code>NeXLSpectrum.subtractcontinuum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subtractcontinuum(
  spec::Spectrum,
  det::EDSDetector,
  resp::AbstractArray{&lt;:Real,2}; #
  minE::Float64 = 1.5e3,
  maxE::Float64 = 0.95 * spec[:BeamEnergy],
  brem::Type{&lt;:NeXLBremsstrahlung} = Castellano2004a,
  mc::Type{&lt;:MatrixCorrection} = Riveros1993,
)::Spectrum</code></pre><p>Computes the characteristic-only spectrum by subtracting the .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/continuum.jl#L245-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.heterogeneity" href="#NeXLSpectrum.heterogeneity"><code>NeXLSpectrum.heterogeneity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">heterogeneity(ffrs::Vector{FilterFitResult}, lbl::ReferenceLabel)</code></pre><p>Computes the ratio of the standard deviation of the measured values over the mean calculated uncertainty from the fit.  A value near 1 means the sample appears homogeneous and a value greater than 1 means the sample appears heterogeneous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/fitresult.jl#L109-L115">source</a></section></article><h2 id="Utility"><a class="docs-heading-anchor" href="#Utility">Utility</a><a id="Utility-1"></a><a class="docs-heading-anchor-permalink" href="#Utility" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.drawline" href="#NeXLSpectrum.drawline"><code>NeXLSpectrum.drawline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">drawline(func::Function, ci1::CartesianIndex{2}, ci2::CartesianIndex{2}, eachstep::Bool=false)</code></pre><p>At each step along the line from <code>ci1</code> to <code>ci2</code> call <code>func</code> with a single argument, the row, column coordinates of the pixel as a <code>Tuple{Int, Int}</code>.</p><p>If <code>eachstep=true</code> then <code>func</code> is called once when the row changes and once when the column changes.  When <code>eachstep=false</code> then <code>func</code> is called less frequently and both row and col may change between calls.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/line.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.shannon_entropy-Tuple{AbstractArray{Gray{N0f8}}}" href="#NeXLSpectrum.shannon_entropy-Tuple{AbstractArray{Gray{N0f8}}}"><code>NeXLSpectrum.shannon_entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shannon_entropy(img::AbstractArray{Gray{N0f8}})</code></pre><p>Computes the log2-entropy of the data in the image. The entropy(...) in Images.jl 24.1 is buggy and is removed in 25.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/semantics_image.jl#L175-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.readSEManticsImage" href="#NeXLSpectrum.readSEManticsImage"><code>NeXLSpectrum.readSEManticsImage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readSEManticsImage(fn::AbstractString)</code></pre><p>Read a SEMantics PNG image and the create an <code>ImageAxes</code> (<code>AxisArray</code>) which associates <code>:x</code>, <code>:y</code> coordinates with the image axes according to the X, Y and FOV in the images.txt file in the same directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/semantics_image.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.requiredbutmissing" href="#NeXLCore.requiredbutmissing"><code>NeXLCore.requiredbutmissing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">NeXLCore.requiredbutmissing(ty::Type, spec::Spectrum)</code></pre><p>Which properties are missing from <code>spec</code> but are required for the algorithm <code>ty</code>?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLCore.hasminrequired" href="#NeXLCore.hasminrequired"><code>NeXLCore.hasminrequired</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">NeXLCore.hasminrequired(ty::Type, spec::Spectrum)</code></pre><p>Does <code>spec</code> have the necessary property items for the algorithm <code>ty</code>?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/spectrum.jl#L260-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NeXLSpectrum.annotate" href="#NeXLSpectrum.annotate"><code>NeXLSpectrum.annotate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">annotate(
    img::AxisArray; 
    scale::Bool = true,
    coords::Union{Nothing, AbstractArray{&lt;:AbstractDict{Symbol, &lt;:AbstractFloat}}} = nothing,
    spectra::Union{Nothing, &lt;:AbstractArray{&lt;:Spectrum}} = nothing,
    thumbnails::Union{Nothing, AbstractArray{&lt;:AxisArray}}=nothing,
    labelcoords::Bool = true,
    labelthumbnails::Bool = true,
    marker::Colorant = HSVA(60, 1, 1, 0.3) 
)</code></pre><p>Add annotations like scale-bars, acquisition points, image areas to an image and display the result.</p><ul><li><code>coords</code> and <code>spectra</code> display as circles (with/without numeric labels).</li><li><code>thumbnails</code> display as rectangles overlaying the image</li><li><code>scale</code> displays as a scale-bar in the upper-right corner</li><li><code>marker</code> is the color of the annotations which is by-default slightly transparent</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/63b91bd6783e7726e9326e15d03afe560d3fee68/src/semantics_image.jl#L119-L138">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../continuummodel/">« Modeling the Continuum</a><a class="docs-footer-nextpage" href="../precompile/">Precompilation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 30 December 2021 12:20">Thursday 30 December 2021</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
