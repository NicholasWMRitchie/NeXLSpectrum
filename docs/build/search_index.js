var documenterSearchIndex = {"docs":
[{"location":"K412quick/#Quick-Quantifying-K412-using-NeXLSpectrum-VectorQuant","page":"Fitting K412 (quick fit)","title":"Quick Quantifying K412 using NeXLSpectrum VectorQuant","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Fred Schamber taught me this trick for quantifying spectrum extremely quickly.  It works reasonably well for a moderate number of ROIs, particularly when few of the ROIs interfere.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Use the NeXLSpectrum to load, plot, fit and report the quantification of a set of K412 spectra.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Loading NeXLSpectrum also automatically makes NeXLCore and NeXLUncertainties available.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Loading the Gadfly library adds plotting support to NeXLSpectrum.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"using NeXLSpectrum              # Provides spectrum reading and fitting tools\nusing NeXLMatrixCorrection      # Provides `quant` to convert k-ratios to mass fraction.\nusing Gadfly                    # Plotting\nusing DataFrames, Latexify      # Tables","category":"page"},{"location":"K412quick/#Read-in-the-Spectra","page":"Fitting K412 (quick fit)","title":"Read in the Spectra","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"path = joinpath(@__DIR__, \"K412 spectra\")\n# Load the unknowns \nunks = map(0:4) do i\n  loadspectrum(joinpath(path, \"III-E K412[$i][4].msa\"))\nend\n# Create a detector model to match the unknown spectra\ndet = matching(unks[1], 132.0, 10)","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"BasicEDS[4096 chs, 1.63032 + 9.99856⋅ch eV, 132.0 eV @ Mn K-L3, 10 ch LLD, \n[Be,Sc,Ba,Pu]]","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Name BeamEnergy ProbeCurrent LiveTime RealTime Coating Integral Material\nIII-E K412[0][all] 2e+04 1.114 235.5 286.3 nothing 8.08e+06 K412\nIII-E K412[1][all] 2e+04 1.114 235.4 286.2 nothing 8.077e+06 K412\nIII-E K412[2][all] 2e+04 1.112 235.5 286.3 nothing 8.084e+06 K412\nIII-E K412[3][all] 2e+04 1.11 235.4 286.3 nothing 8.087e+06 K412\nIII-E K412[4][all] 2e+04 1.11 235.4 286.2 nothing 8.081e+06 K412","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Notice that the spectra all have 1) live-time (:LiveTime); 2) probe-current (:ProbeCurrent); 3) take-off angle (:TakeOffAngle); 4) beam energy (:BeamEnergy); and detector (:Detector) properties defined.  These properties are necessary for extracting the k-ratios and estimating the composition.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"unks[1][:LiveTime], unks[1][:ProbeCurrent], unks[1][:TakeOffAngle], unks[1][:BeamEnergy]","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(235.48403, 1.11355, 0.6108652381980153, 20000.0)","category":"page"},{"location":"K412quick/#The-Unknowns","page":"Fitting K412 (quick fit)","title":"The Unknowns","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"display(plot(unks..., klms=[n\"O\",n\"Mg\",n\"Al\",n\"Si\",n\"Ca\",n\"Fe\"], xmax=8.0e3))","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(Image: )","category":"page"},{"location":"K412quick/#The-Reference-Spectra","page":"Fitting K412 (quick fit)","title":"The Reference Spectra","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Build a convenient structure so it is easy to appreciate the necessary information and to splat it into filteredReference.","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"ffrs = references( [\n  reference(n\"Al\", joinpath(path, \"Al2O3 std.msa\"), mat\"Al2O3\" ), #\n  reference(n\"Mg\", joinpath(path, \"MgO std.msa\"), mat\"MgO\" ),   #\n  reference(n\"Fe\", joinpath(path, \"Fe std.msa\"), mat\"Fe\" ),    #\n  reference(n\"Si\", joinpath(path, \"SiO2 std.msa\"), mat\"SiO2\" ),  #\n  reference(n\"O\", joinpath(path, \"SiO2 std.msa\"), mat\"SiO2\" ),  #\n  reference(n\"Ca\", joinpath(path, \"CaF2 std.msa\"), mat\"CaF2\" ) \n], det)\ndisplay(plot( spectra(ffrs)..., klms= [n\"O\",n\"Mg\",n\"Al\",n\"Si\",n\"Ca\",n\"Fe\"], xmax=8.0e3))","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(Image: )","category":"page"},{"location":"K412quick/#Filter-the-Reference-Spectra-and-Compute-the-VectorQuant-Structure","page":"Fitting K412 (quick fit)","title":"Filter the Reference Spectra and Compute the VectorQuant Structure","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"vq = VectorQuant(ffrs)\nplot(vq, 1:800)","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(Image: )","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Let's take a look at a residual spectrum by plotting one of the FilterFitResult objects. Perform the fit and look at the residual","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"res = map(unks) do unk\n  fit_spectrum(unk, vq)\nend\nplot(res[1])","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(Image: )","category":"page"},{"location":"K412quick/#Compare-this-with-the-weighted-fit","page":"Fitting K412 (quick fit)","title":"Compare this with the weighted fit","text":"","category":"section"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"resfull = map(unks) do unk\n  fit_spectrum(unk, ffrs)\nend\nplot(resfull[1])","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"(Image: )","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Now the full data set...","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Spectra k[O K-L3 + 1 other, SiO2] Δk[O K-L3 + 1 other, SiO2] k[Fe L3-M5 + 13 others, Fe] Δk[Fe L3-M5 + 13 others, Fe] k[Mg K-L3 + 1 other, MgO] Δk[Mg K-L3 + 1 other, MgO] k[Al K-L3 + 3 others, Al2O3] Δk[Al K-L3 + 3 others, Al2O3] k[Si K-L3 + 3 others, SiO2] Δk[Si K-L3 + 3 others, SiO2] k[Ca K-L3 + 3 others, CaF2] Δk[Ca K-L3 + 3 others, CaF2] k[Fe K-L3 + 1 other, Fe] Δk[Fe K-L3 + 1 other, Fe] k[Fe K-M3 + 3 others, Fe] Δk[Fe K-M3 + 3 others, Fe]\nIII-E K412[0][all] 0.646 0.0007025 0.04247 0.0001609 0.1473 0.0001513 0.0669 0.000103 0.3508 0.0002465 0.1922 0.0001964 0.06683 0.0001282 0.06666 0.0003453\nIII-E K412[1][all] 0.648 0.0007037 0.04215 0.0001603 0.1472 0.0001513 0.0667 0.0001029 0.3499 0.0002462 0.1916 0.0001961 0.06701 0.0001284 0.06714 0.0003466\nIII-E K412[2][all] 0.6485 0.0007045 0.04243 0.000161 0.1477 0.0001516 0.06701 0.0001032 0.351 0.0002468 0.1922 0.0001966 0.06683 0.0001283 0.06683 0.000346\nIII-E K412[3][all] 0.653 0.0007075 0.04192 0.0001601 0.1479 0.0001519 0.06708 0.0001033 0.3518 0.0002473 0.1926 0.000197 0.06684 0.0001284 0.06759 0.0003483\nIII-E K412[4][all] 0.6514 0.0007067 0.0415 0.0001593 0.1479 0.0001519 0.06722 0.0001035 0.3518 0.0002473 0.192 0.0001967 0.06687 0.0001285 0.06634 0.0003451","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Spectra k[O K-L3 + 1 other, SiO2] Δk[O K-L3 + 1 other, SiO2] k[Fe L3-M5 + 13 others, Fe] Δk[Fe L3-M5 + 13 others, Fe] k[Mg K-L3 + 1 other, MgO] Δk[Mg K-L3 + 1 other, MgO] k[Al K-L3 + 3 others, Al2O3] Δk[Al K-L3 + 3 others, Al2O3] k[Si K-L3 + 3 others, SiO2] Δk[Si K-L3 + 3 others, SiO2] k[Ca K-L3 + 3 others, CaF2] Δk[Ca K-L3 + 3 others, CaF2] k[Fe K-L3 + 1 other, Fe] Δk[Fe K-L3 + 1 other, Fe] k[Fe K-M3 + 3 others, Fe] Δk[Fe K-M3 + 3 others, Fe]\nIII-E K412[0][all] 0.6536 0.0008101 0.04191 0.0004382 0.1476 0.0001834 0.06699 0.0001589 0.3507 0.0002889 0.1922 0.0002326 0.06683 0.0001593 0.06684 0.0006722\nIII-E K412[1][all] 0.6554 0.0008108 0.04156 0.0004372 0.1475 0.0001835 0.06675 0.000159 0.3499 0.0002888 0.1916 0.0002325 0.06708 0.0001595 0.06738 0.0006721\nIII-E K412[2][all] 0.656 0.0008124 0.04191 0.0004381 0.1479 0.0001838 0.06709 0.0001594 0.3511 0.0002896 0.1922 0.0002329 0.06688 0.0001596 0.06704 0.0006737\nIII-E K412[3][all] 0.6604 0.0008155 0.04146 0.000438 0.1481 0.0001841 0.06716 0.0001595 0.3519 0.00029 0.1925 0.0002333 0.06682 0.0001598 0.0678 0.0006746\nIII-E K412[4][all] 0.6588 0.0008149 0.04081 0.0004383 0.1482 0.0001841 0.06728 0.0001597 0.3518 0.00029 0.1922 0.0002333 0.06694 0.0001598 0.06648 0.000674","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"Compare the timings (full then fast)","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"using BenchmarkTools\n@btime map(unk->fit_spectrum(unk, ffrs), unks)\n@btime map(unk->fit_spectrum(unk, vq), unks)","category":"page"},{"location":"K412quick/","page":"Fitting K412 (quick fit)","title":"Fitting K412 (quick fit)","text":"1.422 ms (2847 allocations: 1.28 MiB)\n  404.500 μs (667 allocations: 191.23 KiB)\n5-element Vector{FilterFitResult{Float64}}:\n FitResult(III-E K412[0][all])\n FitResult(III-E K412[1][all])\n FitResult(III-E K412[2][all])\n FitResult(III-E K412[3][all])\n FitResult(III-E K412[4][all])","category":"page"},{"location":"continuummodel/#Modeling-the-Continuum","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"","category":"section"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"Nicholas W. M. Ritchie 9-Jun-2020","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"Modeling the continuum (Bremsstrahlung) is a necessary component of being able to perform an straight (unfiltered) spectrum fit.  These models can either be used to handle the continuum for linear or non-linear spectrum fits.","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"using NeXLSpectrum\nusing NeXLMatrixCorrection\nusing Gadfly\nusing Colors","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"The ContinuumModel handles the generation of Bremsstrahlung within the sample, the absorption of the generated X-rays as they exit the sample and the efficiency of the detector collecting the X-rays.","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"e0 = 15.0e3\neff = SDDEfficiency(TabulatedWindow(MoxtekAP33()); thickness=0.0370, deadlayer=30.0e-7, entrance=Film(pure(n\"Al\"), 10.0e-7))\n#eff = SDDEfficiency(NoWindow(); thickness=100.0, deadlayer=0.0e-7, entrance=Film(pure(n\"Al\"), 0.0e-7))\ncmod = ContinuumModel(mat\"0.8*Fe+0.15*Cr+0.05*Ni\", e0, deg2rad(40.0))\nplot([ea->emitted(cmod, ea),ea->generated(cmod, ea)],100.0,e0)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"e0 = 5.0e3\ncmod = ContinuumModel(mat\"SiO2\", e0, deg2rad(40.0))\nplot([ea->emitted(cmod, ea),ea->generated(cmod, ea)],100.0,e0)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"det = simpleEDS(4096, 5.0, 0.0, 132.0, 10)\ne0 = 5.0e3\ncmod = ContinuumModel(mat\"0.8*Fe+0.15*Cr+0.05*Ni\", e0, deg2rad(40.0))\nresp = NeXLSpectrum.detectorresponse(det, eff)\nemt = map(ch->ch>=lld(det) ? emitted(cmod,energy(ch,det)) : 0.0,1:channelcount(det))\nmeas =  resp*emt\nlyrs = [ layer(x=energyscale(det), y=emt, Geom.line, Theme(default_color=\"red\")), layer(x=energyscale(det), y=meas, Geom.line) ]\nplot(lyrs..., Coord.cartesian(xmin=0, xmax=e0))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/#Models!!!","page":"Modeling the Continuum","title":"Models!!!","text":"","category":"section"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"model, mc = Castellano2004a, Riveros1993\neff = SDDEfficiency(TabulatedWindow(MoxtekAP33()); thickness=0.0370, deadlayer=30.0e-7, entrance=Film(pure(n\"Al\"), 10.0e-7))\n\nspec = loadspectrum(joinpath(@__DIR__, \"K412 spectra\",\"III-E K412[0][4].msa\"))\ndet=matching(spec, 132.0, 10)\nroi = channel(4.5e3,det):channel(6.0e3,det)\n\nspec = loadspectrum(joinpath(@__DIR__, \"K412 spectra\",\"III-E K412[0][4].msa\"))\ncmod = ContinuumModel(spec[:Composition], spec[:BeamEnergy], spec[:TakeOffAngle], bremsstrahlung=model)\nemt = map(ch->ch>=lld(det) ? emitted(cmod,energy(ch,det)) : 0.0,1:channelcount(det))\nresp = NeXLSpectrum.detectorresponse(det, eff)\nmeas = resp*emt\n\nplot(layer(x=eachindex(emt),y=emt, Geom.line),layer(x=eachindex(meas),y=meas, Geom.point))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(@__DIR__, \"K412 spectra\",\"III-E K412[0][4].msa\"))\nbrem = fitcontinuum(spec, resp, [roi], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")\n\nplot(spec, brem, yscale=0.05, xmax=12.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 0.00036228012968445033","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(@__DIR__, \"K412 spectra\",\"Al2O3 std.msa\"))\nbrem = fitcontinuum(spec, resp, [roi], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")\nplot(spec, brem, yscale=0.01, xmax=8.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 1.589605883279797e-5","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(@__DIR__, \"K412 spectra\",\"SiO2 std.msa\"))\nbrem = fitcontinuum(spec, resp, [roi], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")\nplot(spec, brem, yscale=0.01, xmax=8.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 1.596966709142019e-5","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(@__DIR__, \"K412 spectra\",\"MgO std.msa\"))\nbrem = fitcontinuum(spec, resp, [roi], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")\nplot(spec, brem, yscale=0.01, xmax=8.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 1.5829277549626298e-5","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(@__DIR__, \"K412 spectra\",\"CaF2 std.msa\"))\nbrem = fitcontinuum(spec, resp, [roi], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")\nplot(spec, brem, yscale=0.05, xmax=8.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 1.513254100130786e-5","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"spec = loadspectrum(joinpath(@__DIR__, \"K412 spectra\",\"Fe std.msa\"))\nbrem = fitcontinuum(spec, resp, [ channel(2.0e3,det):channel(4.0e3,det)], brem=model, mc=mc)\nprintln(\"k = $(brem[:K]/dose(spec))\")\nplot(spec, brem, yscale=0.05, xmax=8.0e3)","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"k = 1.796887828500161e-5","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: )","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"path = joinpath(@__DIR__,\"K412 spectra\")\nspec = loadspectrum(joinpath(path,\"III-E K412[0][4].msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))\n\nspec = loadspectrum(joinpath(path,\"Al2O3 std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))\n\nspec = loadspectrum(joinpath(path,\"SiO2 std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))\n\nspec = loadspectrum(joinpath(path,\"MgO std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))\n\nspec = loadspectrum(joinpath(path,\"CaF2 std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))\n\nspec = loadspectrum(joinpath(path,\"Fe std.msa\"))\ndisplay(plot(spec, subtractcontinuum(spec, det, resp), yscale=0.05, xmax=8.0e3))\n\nspec = loadspectrum(joinpath(@__DIR__, \"spectra\",\"Ag std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.05))\n\nspec = loadspectrum(joinpath(@__DIR__, \"spectra\",\"Au std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.05))\n\nspec = loadspectrum(joinpath(@__DIR__, \"spectra\",\"B std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.5))\n\nspec = loadspectrum(joinpath(@__DIR__, \"spectra\",\"Bi std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.05))\n\nspec = loadspectrum(joinpath(@__DIR__, \"spectra\",\"BN std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.20))\n\nspec = loadspectrum(joinpath(@__DIR__, \"spectra\",\"C std.msa\"))\ndisplay(plot(spec, fittedcontinuum(spec, det, resp, mode=:Global), fittedcontinuum(spec, det, resp, mode=:Local), yscale=0.05))","category":"page"},{"location":"continuummodel/","page":"Modeling the Continuum","title":"Modeling the Continuum","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"errorbars/#How-good-are-the-fit-uncertainty-estimates?","page":"Lovely Error Bars","title":"How good are the fit uncertainty estimates?","text":"","category":"section"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"This document looks at two different sets of measured spectra to evaluate how well, the estimated fit uncertainties match the observed uncertainties.  We are using two materials known to be highly homogeneous - K412 and ADM-6006a glasses.  To produce a set of spectra that differ only in count statistics, we will subdivide a spectrum into 100 spectra with an effective live-time of 0.01 of the original spectrum livetime.  We expect that we should be able to compare the \"fit-predicted\" uncertainties with the \"observed distribution\" of measured values.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"To be clear:","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"\"fit-predicted\" - Comes from the covariance matrix output from the linear least squares fit\n\"observed distribution\" - Calculated as the standard-deviation of the 100 fit values.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"We want the ratio of the (observed distribution) / (fit predicted) to be unity or close.  We will call this ratio the \"heterogeneity\" (or \"hetero\" in the fourth column of the describe(....) table.)","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"We then repeat the process on the multiple measured unknown spectra. (4 for K412 and 15 for ADM-6005a)  We expect the heterogeneity to be one or larger - larger than unity when the sample is not perfectly homogeneous.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"using NeXLSpectrum              # Provides spectrum reading and fitting tools\nusing NeXLMatrixCorrection      # Provides `quant` to convert k-ratios to mass fraction.\nusing DataFrames                # Tables\nusing Latexify\nusing BenchmarkTools","category":"page"},{"location":"errorbars/#K412","page":"Lovely Error Bars","title":"K412","text":"","category":"section"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Load the spectra, define the fit model and apply it.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"path = joinpath(@__DIR__,\"K412 spectra\")\nunks = map(0:4) do i \n  loadspectrum(joinpath(path, \"III-E K412[$i][4].msa\"))\nend\ndet = matching(unks[1], 132.0, 10)\nfrs = references( [\n  reference(n\"Al\", joinpath(path, \"Al2O3 std.msa\"), mat\"Al2O3\"),\n  reference(n\"Mg\", joinpath(path, \"MgO std.msa\"), mat\"MgO\"),\n  reference(n\"Fe\", joinpath(path, \"Fe std.msa\"), mat\"Fe\"),\n  reference(n\"Si\", joinpath(path, \"SiO2 std.msa\"), mat\"SiO2\"),\n  reference(n\"O\", joinpath(path, \"SiO2 std.msa\"), mat\"SiO2\"),\n  reference(n\"Ca\", joinpath(path, \"CaF2 std.msa\") ,mat\"CaF2\")\n], det)\n# frs is now a FilteredReference[] used to fit the unknowns.\n\n# Split the counts in unks[1] into 100 randomized spectra which will sum to unks[1] then fit them\nres = map(subdivide(unks[1], 100)) do s\n  fit_spectrum(s, frs)\nend","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"100-element Vector{FilterFitResult{Float64}}:\n FitResult(Sub[III-E K412[0][all],1 of 100])\n FitResult(Sub[III-E K412[0][all],2 of 100])\n FitResult(Sub[III-E K412[0][all],3 of 100])\n FitResult(Sub[III-E K412[0][all],4 of 100])\n FitResult(Sub[III-E K412[0][all],5 of 100])\n FitResult(Sub[III-E K412[0][all],6 of 100])\n FitResult(Sub[III-E K412[0][all],7 of 100])\n FitResult(Sub[III-E K412[0][all],8 of 100])\n FitResult(Sub[III-E K412[0][all],9 of 100])\n FitResult(Sub[III-E K412[0][all],10 of 100])\n ⋮\n FitResult(Sub[III-E K412[0][all],92 of 100])\n FitResult(Sub[III-E K412[0][all],93 of 100])\n FitResult(Sub[III-E K412[0][all],94 of 100])\n FitResult(Sub[III-E K412[0][all],95 of 100])\n FitResult(Sub[III-E K412[0][all],96 of 100])\n FitResult(Sub[III-E K412[0][all],97 of 100])\n FitResult(Sub[III-E K412[0][all],98 of 100])\n FitResult(Sub[III-E K412[0][all],99 of 100])\n FitResult(Sub[III-E K412[0][all],100 of 100])","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Spectra k[O K-L3 + 1 other, SiO2] Δk[O K-L3 + 1 other, SiO2] k[Fe L3-M5 + 13 others, Fe] Δk[Fe L3-M5 + 13 others, Fe] k[Mg K-L3 + 1 other, MgO] Δk[Mg K-L3 + 1 other, MgO] k[Al K-L3 + 3 others, Al2O3] Δk[Al K-L3 + 3 others, Al2O3] k[Si K-L3 + 3 others, SiO2] Δk[Si K-L3 + 3 others, SiO2] k[Ca K-L3 + 3 others, CaF2] Δk[Ca K-L3 + 3 others, CaF2] k[Fe K-L3 + 1 other, Fe] Δk[Fe K-L3 + 1 other, Fe] k[Fe K-M3 + 3 others, Fe] Δk[Fe K-M3 + 3 others, Fe]\nSub[III-E K412[0][all],1 of 100] 0.6538 0.008075 0.04216 0.004438 0.1486 0.001831 0.06437 0.001571 0.3557 0.002884 0.1909 0.002319 0.0677 0.001574 0.07131 0.00691\nSub[III-E K412[0][all],2 of 100] 0.6438 0.00806 0.03981 0.00439 0.1472 0.001839 0.06625 0.001587 0.3473 0.002888 0.1908 0.002321 0.06497 0.001596 0.073 0.006727\nSub[III-E K412[0][all],3 of 100] 0.643 0.008088 0.04069 0.004437 0.1462 0.001828 0.06738 0.001598 0.3563 0.002901 0.1951 0.002316 0.06883 0.001594 0.05761 0.006545\nSub[III-E K412[0][all],4 of 100] 0.6714 0.008175 0.04573 0.00429 0.1496 0.001837 0.0683 0.001591 0.3477 0.00289 0.1964 0.002324 0.06634 0.001584 0.05444 0.006681\nSub[III-E K412[0][all],5 of 100] 0.6611 0.008078 0.0373 0.004324 0.1454 0.00183 0.06489 0.001577 0.3503 0.002872 0.1926 0.002342 0.06801 0.001598 0.0684 0.006855\nSub[III-E K412[0][all],6 of 100] 0.6523 0.008134 0.04701 0.004395 0.1464 0.001825 0.06598 0.001587 0.3478 0.002876 0.1954 0.002336 0.06984 0.001604 0.06209 0.006645\nSub[III-E K412[0][all],7 of 100] 0.6589 0.008152 0.04621 0.004409 0.1471 0.001827 0.06625 0.001586 0.3484 0.002898 0.1913 0.002328 0.06743 0.001609 0.06525 0.006741\nSub[III-E K412[0][all],8 of 100] 0.657 0.008094 0.04406 0.00448 0.146 0.001827 0.06533 0.001585 0.3493 0.002896 0.1936 0.002331 0.06969 0.001604 0.05916 0.006705\nSub[III-E K412[0][all],9 of 100] 0.6569 0.00813 0.03886 0.004366 0.1492 0.001841 0.0663 0.00159 0.351 0.002908 0.197 0.002349 0.0657 0.001573 0.06313 0.006895\nSub[III-E K412[0][all],10 of 100] 0.649 0.008057 0.04605 0.004435 0.148 0.001827 0.06543 0.001574 0.3498 0.002878 0.1899 0.002326 0.06658 0.001589 0.08246 0.007","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"variable mean std hetero min q25 median q75 max\nk[O K-L3 + 1 other, SiO2] 0.6536 0.008259 1.02 0.632 0.6485 0.6552 0.6586 0.6738\nk[Fe L3-M5 + 13 others, Fe] 0.04191 0.003461 0.7901 0.03515 0.03942 0.04193 0.04412 0.05206\nk[Mg K-L3 + 1 other, MgO] 0.1476 0.001911 1.042 0.143 0.1463 0.1475 0.1486 0.1535\nk[Al K-L3 + 3 others, Al2O3] 0.06699 0.0015 0.9439 0.06361 0.06621 0.06708 0.06778 0.07048\nk[Si K-L3 + 3 others, SiO2] 0.3507 0.002909 1.007 0.3435 0.3485 0.3508 0.3524 0.3592\nk[Ca K-L3 + 3 others, CaF2] 0.1922 0.002574 1.107 0.185 0.1902 0.1922 0.1939 0.1984\nk[Fe K-L3 + 1 other, Fe] 0.06683 0.001508 0.9468 0.06296 0.06569 0.06686 0.06784 0.07051\nk[Fe K-M3 + 3 others, Fe] 0.0669 0.006532 0.9723 0.04932 0.06231 0.06698 0.07106 0.08508","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Repeat the fit for the 4 measured unknowns.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"res= map(unks) do s\n  fit_spectrum(s, frs)\nend","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"5-element Vector{FilterFitResult{Float64}}:\n FitResult(III-E K412[0][all])\n FitResult(III-E K412[1][all])\n FitResult(III-E K412[2][all])\n FitResult(III-E K412[3][all])\n FitResult(III-E K412[4][all])","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Spectra k[O K-L3 + 1 other, SiO2] Δk[O K-L3 + 1 other, SiO2] k[Fe L3-M5 + 13 others, Fe] Δk[Fe L3-M5 + 13 others, Fe] k[Mg K-L3 + 1 other, MgO] Δk[Mg K-L3 + 1 other, MgO] k[Al K-L3 + 3 others, Al2O3] Δk[Al K-L3 + 3 others, Al2O3] k[Si K-L3 + 3 others, SiO2] Δk[Si K-L3 + 3 others, SiO2] k[Ca K-L3 + 3 others, CaF2] Δk[Ca K-L3 + 3 others, CaF2] k[Fe K-L3 + 1 other, Fe] Δk[Fe K-L3 + 1 other, Fe] k[Fe K-M3 + 3 others, Fe] Δk[Fe K-M3 + 3 others, Fe]\nIII-E K412[0][all] 0.6536 0.0008101 0.04191 0.0004382 0.1476 0.0001834 0.06699 0.0001589 0.3507 0.0002889 0.1922 0.0002326 0.06683 0.0001593 0.06684 0.0006722\nIII-E K412[1][all] 0.6554 0.0008108 0.04156 0.0004372 0.1475 0.0001835 0.06675 0.000159 0.3499 0.0002888 0.1916 0.0002325 0.06708 0.0001595 0.06738 0.0006721\nIII-E K412[2][all] 0.656 0.0008124 0.04191 0.0004381 0.1479 0.0001838 0.06709 0.0001594 0.3511 0.0002896 0.1922 0.0002329 0.06688 0.0001596 0.06704 0.0006737\nIII-E K412[3][all] 0.6604 0.0008155 0.04146 0.000438 0.1481 0.0001841 0.06716 0.0001595 0.3519 0.00029 0.1925 0.0002333 0.06682 0.0001598 0.0678 0.0006746\nIII-E K412[4][all] 0.6588 0.0008149 0.04081 0.0004383 0.1482 0.0001841 0.06728 0.0001597 0.3518 0.00029 0.1922 0.0002333 0.06694 0.0001598 0.06648 0.000674","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Summary statistics.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"variable mean std hetero min q25 median q75 max\nk[O K-L3 + 1 other, SiO2] 0.6568 0.002714 3.339 0.6536 0.6554 0.656 0.6588 0.6604\nk[Fe L3-M5 + 13 others, Fe] 0.04153 0.0004496 1.026 0.04081 0.04146 0.04156 0.04191 0.04191\nk[Mg K-L3 + 1 other, MgO] 0.1479 0.0003027 1.647 0.1475 0.1476 0.1479 0.1481 0.1482\nk[Al K-L3 + 3 others, Al2O3] 0.06705 0.000202 1.268 0.06675 0.06699 0.06709 0.06716 0.06728\nk[Si K-L3 + 3 others, SiO2] 0.3511 0.000829 2.864 0.3499 0.3507 0.3511 0.3518 0.3519\nk[Ca K-L3 + 3 others, CaF2] 0.1921 0.000318 1.365 0.1916 0.1922 0.1922 0.1922 0.1925\nk[Fe K-L3 + 1 other, Fe] 0.06691 0.0001063 0.6661 0.06682 0.06683 0.06688 0.06694 0.06708\nk[Fe K-M3 + 3 others, Fe] 0.06711 0.0005071 0.7531 0.06648 0.06684 0.06704 0.06738 0.0678","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"@btime fit_spectrum(unks[1], frs)","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"291.700 μs (566 allocations: 261.02 KiB)\nFitResult(III-E K412[0][all])","category":"page"},{"location":"errorbars/#AMM-6005a","page":"Lovely Error Bars","title":"AMM-6005a","text":"","category":"section"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Repeat using the ADM glass.  Fe is not present in ADM-6005a but we fit it to see what a null result looks like.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"path = normpath(joinpath(@__DIR__, \"..\",\"test\",\"ADM6005a spectra\"))\nunks = map(i->loadspectrum(joinpath(path,\"ADM-6005a_$i.msa\")),1:15)\nal, caf2, fe, ge, si, sio2, ti, zn = map(f->loadspectrum(joinpath(path,\"$f.msa\")), (\"Al std\", \"CaF2 std\", \"Fe std\", \"Ge std\", \"Si std\", \"SiO2 std\", \"Ti trimmed\",\"Zn std\"))\n\ndet = matching(unks[1], 132.0, 10)\n\nfrs = references( [\n  reference(n\"Al\", al, mat\"Al\" ), #\n  reference(n\"Ca\", caf2, mat\"CaF2\" ),   #\n  reference(n\"Fe\", fe, mat\"Fe\" ),    #\n  reference(n\"Ge\", ge, mat\"Ge\" ),    #\n  reference(n\"Si\", si, mat\"Si\" ),  #\n  reference(n\"O\", sio2, mat\"SiO2\" ),  #\n  reference(n\"Ti\", ti, mat\"Ti\" ),\n  reference(n\"Zn\", zn, mat\"Zn\" ) \n], det)\n\nss = \nres= map(subdivide(unks[1], 100)) do s\n  fit_spectrum(s, frs)\nend","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"100-element Vector{FilterFitResult{Float64}}:\n FitResult(Sub[ADM-6005a_1,1 of 100])\n FitResult(Sub[ADM-6005a_1,2 of 100])\n FitResult(Sub[ADM-6005a_1,3 of 100])\n FitResult(Sub[ADM-6005a_1,4 of 100])\n FitResult(Sub[ADM-6005a_1,5 of 100])\n FitResult(Sub[ADM-6005a_1,6 of 100])\n FitResult(Sub[ADM-6005a_1,7 of 100])\n FitResult(Sub[ADM-6005a_1,8 of 100])\n FitResult(Sub[ADM-6005a_1,9 of 100])\n FitResult(Sub[ADM-6005a_1,10 of 100])\n ⋮\n FitResult(Sub[ADM-6005a_1,92 of 100])\n FitResult(Sub[ADM-6005a_1,93 of 100])\n FitResult(Sub[ADM-6005a_1,94 of 100])\n FitResult(Sub[ADM-6005a_1,95 of 100])\n FitResult(Sub[ADM-6005a_1,96 of 100])\n FitResult(Sub[ADM-6005a_1,97 of 100])\n FitResult(Sub[ADM-6005a_1,98 of 100])\n FitResult(Sub[ADM-6005a_1,99 of 100])\n FitResult(Sub[ADM-6005a_1,100 of 100])","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Spectra k[Ti L3-M5 + 13 others, Ti] Δk[Ti L3-M5 + 13 others, Ti] k[O K-L3 + 1 other, SiO2] Δk[O K-L3 + 1 other, SiO2] k[Fe L3-M5 + 13 others, Fe] Δk[Fe L3-M5 + 13 others, Fe] k[Zn L3-M5 + 13 others, Zn] Δk[Zn L3-M5 + 13 others, Zn] k[Ge L3-M5 + 15 others, Ge] Δk[Ge L3-M5 + 15 others, Ge] k[Al K-L3 + 3 others, Al] Δk[Al K-L3 + 3 others, Al] k[Si K-L3 + 3 others, Si] Δk[Si K-L3 + 3 others, Si] k[Ca K-L3 + 3 others, CaF2] Δk[Ca K-L3 + 3 others, CaF2] k[Ti K-L3 + 3 others, Ti] Δk[Ti K-L3 + 3 others, Ti] k[Fe K-L3 + 1 other, Fe] Δk[Fe K-L3 + 1 other, Fe] k[Fe K-M3 + 3 others, Fe] Δk[Fe K-M3 + 3 others, Fe] k[Zn K-L3 + 1 other, Zn] Δk[Zn K-L3 + 1 other, Zn] k[Zn K-M3 + 3 others, Zn] Δk[Zn K-M3 + 3 others, Zn] k[Ge K-L3 + 1 other, Ge] Δk[Ge K-L3 + 1 other, Ge] k[Ge K-M3 + 5 others, Ge] Δk[Ge K-M3 + 5 others, Ge]\nSub[ADM-6005a_1,1 of 100] 0.01715 0.01819 0.4763 0.006686 0.000985 0.002787 0.06969 0.001486 0.1757 0.001765 0.02775 0.0005049 0.02201 0.0005003 0.115 0.001682 0.06554 0.001036 0.0007427 0.0006747 0.003487 0.005247 0.1109 0.002677 0.1094 0.01578 0.2538 0.005234 0.268 0.01881\nSub[ADM-6005a_1,2 of 100] 0.01827 0.01828 0.4875 0.006735 0 0.002702 0.06966 0.001475 0.1821 0.00177 0.0287 0.0004998 0.02128 0.0005 0.1241 0.001674 0.06443 0.001028 0.0005619 0.000684 0.004611 0.005194 0.112 0.002762 0.1619 0.01567 0.2827 0.005347 0.2444 0.01864\nSub[ADM-6005a_1,3 of 100] 0.0322 0.01842 0.4923 0.00674 0.002764 0.00292 0.06944 0.001476 0.1761 0.001764 0.02897 0.0005068 0.02227 0.0005062 0.1194 0.001682 0.06353 0.001033 0.0001854 0.0007012 0.01708 0.005114 0.1142 0.002699 0.1215 0.01569 0.2502 0.00515 0.2289 0.01861\nSub[ADM-6005a_1,4 of 100] 0.0524 0.01805 0.4837 0.006707 0.003455 0.002792 0.06469 0.001468 0.1799 0.001769 0.02651 0.0004925 0.02136 0.0004991 0.122 0.001686 0.06291 0.001025 0.0004902 0.0007035 0.01035 0.00508 0.1069 0.002743 0.121 0.01569 0.2541 0.005246 0.2524 0.01896\nSub[ADM-6005a_1,5 of 100] 0.0002562 0.01767 0.487 0.006768 0 0.002727 0.07283 0.001479 0.1827 0.00178 0.02866 0.0005074 0.02227 0.0005078 0.1234 0.001689 0.06352 0.001038 0 0.0006952 0 0.004966 0.1189 0.002716 0.1116 0.01565 0.2709 0.005318 0.2589 0.01958\nSub[ADM-6005a_1,6 of 100] 0.02306 0.0181 0.4812 0.006723 0 0.002734 0.06618 0.001462 0.1806 0.001764 0.02709 0.0004969 0.02083 0.0004982 0.1226 0.001685 0.0649 0.001027 0 0.0006779 0.0002667 0.004972 0.1194 0.002748 0.0954 0.01498 0.2641 0.005218 0.278 0.01916\nSub[ADM-6005a_1,7 of 100] 0.005544 0.01804 0.485 0.006674 0 0.002763 0.06924 0.001466 0.1786 0.001756 0.0283 0.000503 0.021 0.000503 0.1219 0.001695 0.06693 0.001034 0.001133 0.0006931 0.006329 0.005147 0.1143 0.00276 0.1483 0.0159 0.2708 0.005258 0.2378 0.01838\nSub[ADM-6005a_1,8 of 100] 0.01364 0.01792 0.486 0.006724 0.001811 0.002872 0.0682 0.001485 0.1767 0.001759 0.0273 0.0004987 0.02101 0.0004993 0.1235 0.001689 0.06345 0.001028 0.001232 0.0007136 0.007105 0.005165 0.1097 0.002725 0.1297 0.01582 0.2737 0.005364 0.2913 0.01914\nSub[ADM-6005a_1,9 of 100] 0.03225 0.01788 0.4848 0.006746 0 0.00279 0.06824 0.001487 0.1793 0.001774 0.02782 0.0004993 0.02068 0.0004981 0.1235 0.001698 0.06417 0.001031 0 0.0006982 0 0.004931 0.1138 0.002688 0.1068 0.01582 0.2705 0.005279 0.2545 0.01895\nSub[ADM-6005a_1,10 of 100] 0.006674 0.01835 0.4837 0.006785 0.003991 0.002899 0.06693 0.001468 0.182 0.001776 0.02971 0.0005091 0.02143 0.0005028 0.1245 0.0017 0.06301 0.001039 0 0.0006824 0 0.005233 0.1128 0.002765 0.1246 0.01561 0.2642 0.005274 0.2996 0.01969","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Summary statistics.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"variable mean std hetero min q25 median q75 max\nk[Ti L3-M5 + 13 others, Ti] 0.02107 0.01601 0.8875 0 0.006446 0.01928 0.03279 0.05741\nk[O K-L3 + 1 other, SiO2] 0.4877 0.0102 1.524 0.4636 0.4812 0.4865 0.4949 0.5095\nk[Fe L3-M5 + 13 others, Fe] 0.001105 0.001439 0.514 0 0 0.0003555 0.00183 0.005188\nk[Zn L3-M5 + 13 others, Zn] 0.06813 0.002081 1.411 0.06273 0.06664 0.06842 0.0696 0.07283\nk[Ge L3-M5 + 15 others, Ge] 0.1793 0.00242 1.368 0.1722 0.1778 0.1795 0.181 0.1859\nk[Al K-L3 + 3 others, Al] 0.028 0.0007355 1.471 0.02651 0.02755 0.02797 0.02856 0.02993\nk[Si K-L3 + 3 others, Si] 0.02143 0.0006718 1.339 0.01995 0.021 0.02133 0.02193 0.02295\nk[Ca K-L3 + 3 others, CaF2] 0.1214 0.002626 1.557 0.115 0.1195 0.1213 0.123 0.1298\nk[Ti K-L3 + 3 others, Ti] 0.06433 0.001447 1.401 0.06133 0.06334 0.06433 0.06516 0.06773\nk[Fe K-L3 + 1 other, Fe] 0.0004635 0.0005114 0.7346 0 0 0.0003835 0.0007281 0.001958\nk[Fe K-M3 + 3 others, Fe] 0.003237 0.004005 0.7915 0 0 0.001806 0.005287 0.01708\nk[Zn K-L3 + 1 other, Zn] 0.1117 0.003733 1.37 0.1038 0.109 0.111 0.1141 0.1215\nk[Zn K-M3 + 3 others, Zn] 0.1228 0.02056 1.31 0.05468 0.1081 0.1216 0.1386 0.1675\nk[Ge K-L3 + 1 other, Ge] 0.2635 0.007333 1.395 0.2346 0.2589 0.2641 0.2686 0.2827\nk[Ge K-M3 + 5 others, Ge] 0.2705 0.02089 1.097 0.2229 0.256 0.2709 0.2832 0.3265","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Repeat for the 15 measured spectra.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"res= map(unks) do s\n  fit_spectrum(s, frs)\nend","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"15-element Vector{FilterFitResult{Float64}}:\n FitResult(ADM-6005a_1)\n FitResult(ADM-6005a_2)\n FitResult(ADM-6005a_3)\n FitResult(ADM-6005a_4)\n FitResult(ADM-6005a_5)\n FitResult(ADM-6005a_6)\n FitResult(ADM-6005a_7)\n FitResult(ADM-6005a_8)\n FitResult(ADM-6005a_9)\n FitResult(ADM-6005a_10)\n FitResult(ADM-6005a_11)\n FitResult(ADM-6005a_12)\n FitResult(ADM-6005a_13)\n FitResult(ADM-6005a_14)\n FitResult(ADM-6005a_15)","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Spectra k[Ti L3-M5 + 13 others, Ti] Δk[Ti L3-M5 + 13 others, Ti] k[O K-L3 + 1 other, SiO2] Δk[O K-L3 + 1 other, SiO2] k[Fe L3-M5 + 13 others, Fe] Δk[Fe L3-M5 + 13 others, Fe] k[Zn L3-M5 + 13 others, Zn] Δk[Zn L3-M5 + 13 others, Zn] k[Ge L3-M5 + 15 others, Ge] Δk[Ge L3-M5 + 15 others, Ge] k[Al K-L3 + 3 others, Al] Δk[Al K-L3 + 3 others, Al] k[Si K-L3 + 3 others, Si] Δk[Si K-L3 + 3 others, Si] k[Ca K-L3 + 3 others, CaF2] Δk[Ca K-L3 + 3 others, CaF2] k[Ti K-L3 + 3 others, Ti] Δk[Ti K-L3 + 3 others, Ti] k[Fe K-L3 + 1 other, Fe] Δk[Fe K-L3 + 1 other, Fe] k[Fe K-M3 + 3 others, Fe] Δk[Fe K-M3 + 3 others, Fe] k[Zn K-L3 + 1 other, Zn] Δk[Zn K-L3 + 1 other, Zn] k[Zn K-M3 + 3 others, Zn] Δk[Zn K-M3 + 3 others, Zn] k[Ge K-L3 + 1 other, Ge] Δk[Ge K-L3 + 1 other, Ge] k[Ge K-M3 + 5 others, Ge] Δk[Ge K-M3 + 5 others, Ge]\nADM-6005a_1 0.01964 0.001805 0.4876 0.0006729 0.0001275 0.0002801 0.06814 0.0001475 0.1793 0.0001769 0.028 5.002e-05 0.02143 5.017e-05 0.1214 0.0001687 0.06433 0.0001033 0.0002048 6.966e-05 0.001265 0.0005064 0.1117 0.0002725 0.1226 0.001569 0.2635 0.0005255 0.2701 0.001897\nADM-6005a_2 0.02053 0.001806 0.4863 0.0006728 0 0.0002776 0.06796 0.0001475 0.1797 0.000177 0.02793 5.002e-05 0.02146 5.012e-05 0.1214 0.0001687 0.06393 0.0001032 0.0003342 6.935e-05 0.001418 0.0005071 0.1115 0.0002728 0.1226 0.001568 0.2641 0.0005258 0.277 0.001901\nADM-6005a_3 0.02108 0.001805 0.4894 0.0006737 0.0002538 0.0002783 0.06801 0.0001477 0.1795 0.0001769 0.02805 5.003e-05 0.02136 5.011e-05 0.1216 0.0001689 0.06404 0.0001033 0.0002986 6.974e-05 0.0006342 0.0005059 0.1116 0.0002723 0.1155 0.001567 0.2623 0.0005252 0.2797 0.001901\nADM-6005a_4 0.01931 0.001807 0.488 0.0006737 0 0.0002786 0.06843 0.0001479 0.1796 0.0001771 0.02801 5.007e-05 0.02149 5.02e-05 0.1211 0.0001687 0.06402 0.0001032 0.0003314 6.985e-05 0.001286 0.0005073 0.1116 0.0002729 0.1204 0.001567 0.2636 0.0005254 0.2755 0.001903\nADM-6005a_5 0.01983 0.001807 0.488 0.0006734 0 0.0002782 0.06789 0.0001475 0.1793 0.0001769 0.02816 5.007e-05 0.02133 5.013e-05 0.1215 0.0001689 0.06406 0.0001032 0.0002726 6.967e-05 0.001403 0.0005061 0.1116 0.0002724 0.1207 0.001562 0.2625 0.0005253 0.2731 0.001898\nADM-6005a_6 0.02264 0.001805 0.4892 0.000673 0 0.0002779 0.06812 0.0001475 0.1792 0.000177 0.02814 5.01e-05 0.02142 5.017e-05 0.1209 0.0001686 0.06397 0.0001033 0.0002285 6.936e-05 0.001213 0.0005055 0.1111 0.0002723 0.122 0.001568 0.262 0.0005253 0.2777 0.001896\nADM-6005a_7 0.02164 0.001811 0.4897 0.0006747 0 0.0002782 0.06787 0.0001475 0.1795 0.000177 0.02795 5.004e-05 0.02148 5.013e-05 0.1215 0.0001689 0.0642 0.0001033 0.0003133 6.951e-05 0 0.0005048 0.1111 0.0002731 0.1214 0.001572 0.2636 0.0005267 0.2723 0.001897\nADM-6005a_8 0.01968 0.001808 0.4884 0.0006733 9.754e-05 0.0002781 0.06805 0.0001477 0.1796 0.000177 0.02809 5.011e-05 0.02154 5.02e-05 0.1215 0.0001687 0.06411 0.0001032 0.0002939 6.953e-05 0.0003188 0.0005084 0.1113 0.0002722 0.1223 0.001571 0.264 0.0005262 0.2774 0.001905\nADM-6005a_9 0.02081 0.00181 0.4885 0.0006735 0 0.0002785 0.06835 0.0001478 0.1792 0.0001771 0.02811 5.008e-05 0.02152 5.018e-05 0.1214 0.0001687 0.06402 0.0001032 0.000302 6.967e-05 0.001483 0.0005078 0.111 0.0002723 0.1181 0.00157 0.2615 0.0005259 0.2759 0.001897\nADM-6005a_10 0.02465 0.001805 0.4877 0.0006733 0.0001351 0.000279 0.06788 0.0001477 0.1798 0.0001771 0.02813 5.007e-05 0.02147 5.018e-05 0.1211 0.0001687 0.06386 0.0001031 0.0001826 6.964e-05 0.001759 0.0005073 0.1117 0.0002726 0.1244 0.001571 0.2628 0.0005256 0.2743 0.001905\nADM-6005a_11 0.02014 0.001804 0.4883 0.0006738 0.0002345 0.0002791 0.0678 0.0001476 0.1797 0.000177 0.02803 5.006e-05 0.02154 5.019e-05 0.1214 0.0001688 0.06397 0.0001031 0.0004916 6.947e-05 0.0008535 0.0005053 0.1115 0.0002721 0.1215 0.001565 0.2634 0.0005259 0.2711 0.001892\nADM-6005a_12 0.02042 0.001811 0.4899 0.0006747 0 0.0002787 0.06789 0.0001476 0.1796 0.0001771 0.02798 5.007e-05 0.02149 5.02e-05 0.1213 0.0001688 0.06378 0.0001032 0.0003361 6.939e-05 0.001099 0.0005068 0.1113 0.0002729 0.1166 0.001567 0.2625 0.0005262 0.2726 0.001897\nADM-6005a_13 0.01675 0.001812 0.4893 0.0006745 0.0002109 0.0002777 0.06837 0.0001478 0.1794 0.000177 0.02807 5.001e-05 0.02142 5.019e-05 0.1216 0.0001688 0.06395 0.0001032 0.0003101 6.96e-05 0 0.0005047 0.1113 0.0002727 0.1245 0.001567 0.2633 0.0005256 0.2786 0.001907\nADM-6005a_14 0.01856 0.001809 0.4895 0.0006741 0 0.0002776 0.06805 0.0001477 0.1798 0.000177 0.02794 5.001e-05 0.02152 5.015e-05 0.1215 0.0001689 0.06388 0.0001033 0.0003892 6.958e-05 0.0008041 0.0005066 0.1112 0.0002723 0.1213 0.001569 0.2629 0.0005254 0.2756 0.001896\nADM-6005a_15 0.01905 0.001808 0.4903 0.0006739 0 0.000277 0.06802 0.0001476 0.1799 0.0001772 0.02813 5.011e-05 0.02141 5.017e-05 0.1215 0.0001688 0.06409 0.0001032 0.0002762 6.947e-05 0.00149 0.0005059 0.1116 0.0002725 0.1209 0.001568 0.2632 0.0005258 0.2716 0.001898","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"Summary statistics.","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"variable mean std hetero min q25 median q75 max\nk[Ti L3-M5 + 13 others, Ti] 0.02031 0.001821 1.008 0.01675 0.01947 0.02014 0.02094 0.02465\nk[O K-L3 + 1 other, SiO2] 0.4887 0.001071 1.589 0.4863 0.488 0.4885 0.4894 0.4903\nk[Fe L3-M5 + 13 others, Fe] 7.062e-05 9.75e-05 0.3503 0 0 0 0.0001313 0.0002538\nk[Zn L3-M5 + 13 others, Zn] 0.06805 0.0001951 1.322 0.0678 0.06789 0.06802 0.06813 0.06843\nk[Ge L3-M5 + 15 others, Ge] 0.1795 0.0002331 1.317 0.1792 0.1793 0.1796 0.1797 0.1799\nk[Al K-L3 + 3 others, Al] 0.02805 7.811e-05 1.56 0.02793 0.02799 0.02805 0.02812 0.02816\nk[Si K-L3 + 3 others, Si] 0.02146 6.203e-05 1.236 0.02133 0.02142 0.02147 0.0215 0.02154\nk[Ca K-L3 + 3 others, CaF2] 0.1214 0.0002119 1.255 0.1209 0.1213 0.1214 0.1215 0.1216\nk[Ti K-L3 + 3 others, Ti] 0.06401 0.0001365 1.322 0.06378 0.06394 0.06402 0.06408 0.06433\nk[Fe K-L3 + 1 other, Fe] 0.0003043 7.438e-05 1.069 0.0001826 0.0002744 0.000302 0.0003328 0.0004916\nk[Fe K-M3 + 3 others, Fe] 0.001002 0.0005511 1.088 0 0.0007191 0.001213 0.001411 0.001759\nk[Zn K-L3 + 1 other, Zn] 0.1114 0.0002374 0.8712 0.111 0.1112 0.1115 0.1116 0.1117\nk[Zn K-M3 + 3 others, Zn] 0.121 0.00254 1.62 0.1155 0.1206 0.1214 0.1224 0.1245\nk[Ge K-L3 + 1 other, Ge] 0.263 0.0007443 1.416 0.2615 0.2625 0.2632 0.2635 0.2641\nk[Ge K-M3 + 5 others, Ge] 0.2748 0.002941 1.549 0.2701 0.2724 0.2755 0.2772 0.2797","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"@btime fit_spectrum(unks[1], frs)","category":"page"},{"location":"errorbars/","page":"Lovely Error Bars","title":"Lovely Error Bars","text":"410.900 μs (1043 allocations: 611.44 KiB)\nFitResult(ADM-6005a_1)","category":"page"},{"location":"methods/#![](NeXL_sm.png)Spectrum","page":"Methods","title":"(Image: )Spectrum","text":"","category":"section"},{"location":"methods/#Microanalytical-X-ray-Spectrum-Analysis","page":"Methods","title":"Microanalytical X-ray Spectrum Analysis","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"CurrentModule = NeXLSpectrum","category":"page"},{"location":"methods/#Spectrum-Manipulation","page":"Methods","title":"Spectrum Manipulation","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"See the Spectrum Methods page for the most used methods and details.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.property!\nNeXLSpectrum.duane_hunt\nNeXLSpectrum.sigma\nNeXLSpectrum.findsimilar\nNeXLSpectrum.multiscore\nNeXLSpectrum.multirank \nNeXLSpectrum.plot_compare\nNeXLSpectrum.apply\nNeXLSpectrum.loadmultispec\nNeXLUncertainties.uv\nNeXLSpectrum.χ²\nNeXLSpectrum.recalibrate\nNeXLSpectrum.shift\nNeXLSpectrum.offset\nNeXLSpectrum.dosenormalize\nNeXLSpectrum.extent\nNeXLSpectrum.characteristiccounts\nNeXLSpectrum.scale\nNeXLSpectrum.channelcount\nNeXLSpectrum.sumcounts\nNeXLSpectrum.shannon_entropy\nNeXLSpectrum.similarity\nNeXLSpectrum.fittedcontinuum","category":"page"},{"location":"methods/#NeXLSpectrum.property!","page":"Methods","title":"NeXLSpectrum.property!","text":"property!(spec::Spectrum, sym::Symbol, val::Any)\n\nUseful to broadcast properties over many spectra.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.duane_hunt","page":"Methods","title":"NeXLSpectrum.duane_hunt","text":"duane_hunt(spec::Spectrum)\n\nEstimates the Duane-Hunt limit (the energy at which the continuum goes to effectively zero.)\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.sigma","page":"Methods","title":"NeXLSpectrum.sigma","text":"sigma(spec::Spectrum, specs::AbstractArray{<:Spectrum}, chs::AbstractRange{<:Integer})::Vector{Float64}\n\nComputes on a channel-by-channel basis how much spec spectrum deviates from the mean of the other spectra in specs.  The result is expressed in terms of the standard deviation expected from count statistics alone.   Assuming spec varies only by count statistics we expect the result values have a mean 0.0 and a standard deviation of 1.0. \n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.findsimilar","page":"Methods","title":"NeXLSpectrum.findsimilar","text":"findsimilar(\n    specs::AbstractArray{Spectrum{T}}; \n    atol = nothing, \n    rtol=1.5, \n    minspecs=3\n)::Vector{Spectrum{T}}\nfindsimilar(\n    specs::AbstractArray{Spectrum{T}},\n    det::Detector,\n    elm::Element; \n    atol = nothing, \n    rtol=1.5, \n    minspecs = 3\n)::Vector{Spectrum{T}}\n\nFilters a collection of spectra for the ones most similar to the average by removing the least similar spectrum sequentially until all the remaining spectra are either:\n\nless than atol (if atol != nothing)\nless than rtol * median(others) (if rtol != nothing)\n\nwhen applying the 'similarity(...)` function to the spectrum and the sum of the other spectra.\n\nThis is useful for finding which of a set of replicate spectra are sufficiently similar  to each other.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.multiscore","page":"Methods","title":"NeXLSpectrum.multiscore","text":"multiscore(specs::AbstractArray{<:Spectrum}, e0=specs[1][:BeamEnergy])\n\nCompares each spectrum against the mean spectrum by comparing the 200 eV to 500 eV range with the [e0/2,e0/1.5] range. If all spectra are equivalent at low energies then all the scores will be close to zero.  A number less than zero means that the low energy region of the spectrum was depressed relative to the others.  A number more than zero means that the high energy region of the spectrum was elevated relative to the others.  The multi-score is sensitive to tilt and obstructions like surface texture which may make one spectrum's low energy be more absorbed than the  others. \n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.multirank","page":"Methods","title":"NeXLSpectrum.multirank","text":"multirank(specs::AbstractArray{<:Spectrum})::Float64\n\nA single number that compares the low and high energy portions of the spectra for similarity.  A multirank(...) score of zero means all the spectra are very similar and a large number means very different. A high score suggests that one or more of the spectra may suffer from additional low energy absorption due to surface roughness, an obstruction, sample tilt or other.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.plot_compare","page":"Methods","title":"NeXLSpectrum.plot_compare","text":"plot_compare(specs::AbstractArray{<:Spectrum}, mode=:Plot; xmin=100.0, xmax=1.0, palette = NeXLPalette)\n\nPlots a comparison of the channel-by-channel data from each individual spectrum relative to the dose-corrected mean of the other spectra.  Count statistics are taken into account so if the spectra agree to within count statistics we expect a mean of 0.0 and a standard deviation of 1.0 over all channels. Note: xmax is relative to the :BeamEnergy.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.apply","page":"Methods","title":"NeXLSpectrum.apply","text":"apply(filt::SavitzkyGolayFilter, spec::Spectrum, applyLLD=false)\n\nApplys a function to the channel data in spec (with/wo the low-level discriminator.) The function can only be a function of the counts data and can not change the energy scale or spectrum properties.  The result is a Spectrum.\n\nExample:\n\napply(SavitzkyGolayFilter{6,4}(),spec)\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.loadmultispec","page":"Methods","title":"NeXLSpectrum.loadmultispec","text":"loadmultispec(path::AbstractString, basefn::AbstractString; indexes=0:3, fnmapper::String = \"{1}[{2}].msa\")\n\nLoad multiple spectra using the basefn and fnmapper to determine which spectra to load.  The spectra should be related in the sense that they were all collected simulataneously so they have the same :RealTime, :BeamEnergy  and :LiveTime.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLUncertainties.uv","page":"Methods","title":"NeXLUncertainties.uv","text":"uv(spec::Spectrum, chs::AbstractRange{<:Integer}=eachindex(spec))::Vector{UncertainValue}\n\nConverts the count's data in a spectrum into an Vector{UncertainValue} assuming count statistics can be approximated by C ± √C. \n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.χ²","page":"Methods","title":"NeXLSpectrum.χ²","text":"χ²(s1::Spectrum{T}, s2::Spectrum{U}, chs)::T where {T<:Real, U <: Real}\nχ²(specs::AbstractArray{Spectrum{T}}, chs)::Matrix{T}\n\nComputes the dose corrected reduced χ² metric between s1 and s2 over the channels in chs.\n\nThe second form computes a matrix of χ² comparing each spectrum in the array to the others.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.recalibrate","page":"Methods","title":"NeXLSpectrum.recalibrate","text":"recalibrate(s::Spectrum{T}, es::LinearEnergyScale)\n\nAllows changing the energy scale on a spectrum from one LinearEnergyScale to another as though the spectrum were  measured on a different detector.  The algorith uses a FFT-base scheme to rescale and shift the spectral data. Ths scheme allows for fractional shifts of offset and fractional changes in the width.  It is limited in that the change in width must produce an integral number of channels in the resulting spectrum.  The algorithm  maintains the total spectrum integral so the new spectrum can be used for quantitative purposes. Plotting one spectrum over the other should maintain peak position but is likely to change the channel counts.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.shift","page":"Methods","title":"NeXLSpectrum.shift","text":"shift(s::Spectrum, ev::AbstractFloat)::Spectrum\n\nShift the entire spectrum along the energy axis by a specified number of ev by modifying the counts data.  This function can shift by a fractional number of channels.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.offset","page":"Methods","title":"NeXLSpectrum.offset","text":"offset(s::Spectrum, dcounts::Real)\n\nReturns a Spectrum like s but with dcounts added to each channel.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.dosenormalize","page":"Methods","title":"NeXLSpectrum.dosenormalize","text":"dosenormalize(spectrum::Spectrum{T}, dose=60.0)::Spectrum{T} where { T <: Real }\ndosenormalize(spectrum::Spectrum{T}, dose=60.0)::Spectrum{Float64} where { T <: Integer }\n\nCompute a spectrum which is spectrum rescaled to a live time times probe current equal to dose. Useful for setting spectra on an equivalent acquisition duration scale.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.extent","page":"Methods","title":"NeXLSpectrum.extent","text":"extent(xrayE::Float64, res::Resolution, ampl::Float64)\n\nCalculates the extent of the peak interval for an x-ray of the specified energy.\n\n\n\n\n\nextent(escape::EscapeArtifact, res::Resolution, ampl::Float64)::Tuple{2,Float64}\n\nThe extent of an escape artifact is determined by the resolution of the detector at the energy of the escape peak.\n\n\n\n\n\nextent(escape::ComptonArtifact, res::Resolution, ampl::Float64)::Tuple{2,Float64}\n\nThe extent of a Compton artifact is determined by the resolution of the detector at the energy of the Compton peak.\n\n\n\n\n\nextent(sf::SpectrumFeature, det::Detector, ampl::Float64)::Tuple{Float64, Float64}\n\nComputes the channel range encompassed by the specified set of x-ray transitions down to an intensity of ampl.  Relative line weights are taken into account.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.characteristiccounts","page":"Methods","title":"NeXLSpectrum.characteristiccounts","text":"characteristiccounts(ffr::FiterFitResult, strip)\n\nNumber of spectrum counts that were accounted for by the fitted elements with the strip Element(s) removed.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.scale","page":"Methods","title":"NeXLSpectrum.scale","text":"scale(det::Detector)\n\nEnergyScale associated with this detector.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.channelcount","page":"Methods","title":"NeXLSpectrum.channelcount","text":"channelcount(det::Detector)\n\nNumber of detector channels.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.sumcounts","page":"Methods","title":"NeXLSpectrum.sumcounts","text":"sumcounts(hss::HyperSpectrum, cis::CartesianIndices = CartesianIndices(hss))\n\nAn array containing the number of counts at each pixel.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.shannon_entropy","page":"Methods","title":"NeXLSpectrum.shannon_entropy","text":"shannon_entropy(spec::Spectrum)\n\nComputes a measure of the information content in a spectrum.  As there become more and more distinct values in a spectrum, this value approaches log2(nchannels(spec)).  This number reflects the number of bits necessary to encode the spectrum data with maximum efficiency.\n\nThis is inspired by John Colby's FLAME software which did something similar.  Although, to be honest, I don't know how his algorithm was implemented.\n\n\n\n\n\nshannon_entropy(img::AbstractArray{Gray{N0f8}})\n\nComputes the log2-entropy of the data in the image. The entropy(...) in Images.jl 24.1 is buggy and is removed in 25.0\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.similarity","page":"Methods","title":"NeXLSpectrum.similarity","text":"similarity(s1::Spectrum{T}, s2::Spectrum{T}, chs)::Float64 where {T<:Real}\nsimilarity(specs::AbstractArray{Spectrum{T}}, chs)::Vector{Float64}\nsimilarity(specs::AbstractArray{Spectrum}, minE::Float64=100.0)::Vector{Float64}\nsimilarity(specs::AbstractArray{<:Spectrum}, det::Detector, elm::Element)::Vector{Float64}\nsimilarity(specs::AbstractArray{Spectrum{T}}, det::Detector, mat::Material)::Vector{Float64}\n\nReturns a vector of similarity metrics which measure how similar the i-th Spectrum is to the other spectra. The mean reduced χ² statistic metric is such that if s1 and s2 differ by only count statistics  then the metric will be approximately unity.  If s1 and s2 vary due to probe current drift, sample  inhomogeneity, surface roughness or other non-count statistics related reasons then the metric will be  larger than one.\n\nThe first version covers all the channels between minE and the nominal beam energy. The third and fourth versions considers those channels representing peaks in a spectrum from the Material or Element on the Detector.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.fittedcontinuum","page":"Methods","title":"NeXLSpectrum.fittedcontinuum","text":"fittedcontinuum(     spec::Spectrum,     det::EDSDetector,     resp::AbstractArray{<:Real,2}; #     mode = :Global [ | :Local ] # Fit to all ROIs simultaneously (:Global) or to each roi independently (:Local)     minE::Float64 = 1.5e3,     maxE::Float64 = 0.95 * spec[:BeamEnergy],     width::Int = 20, # Width of ROI at each end of each patch of continuum that is matched     brem::Type{<:NeXLBremsstrahlung} = Castellano2004a,     mc::Type{<:MatrixCorrection} = Riveros1993,   )::Spectrum\n\nFit the continuum under the characteristic peaks by fitting the closest continuum ROIs.  The low energy peaks are fit using the continuum immediately higher in energy and the high energy peaks are fit using the continuum on both sides.\n\nmode = :Global [ | :Local ] Global fits the model to the data using a single scale factor. :Local tweaks the\n\nglobal model at ROIs above and below the characteristic peaks.\n\nTypically, :Global produces the overall best fit but :Local fits better around the characteristic peaks and is    better for modeling the continuum under the peaks.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Spectrum-Plotting","page":"Methods","title":"Spectrum Plotting","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Gadfly.plot( ::AbstractVector{Spectrum}; klms, edges, escapes, coincidences, autoklms, xmin, xmax, norm, yscale, ytransform, style, palette)","category":"page"},{"location":"methods/#Gadfly.plot-Tuple{AbstractVector{Spectrum}}","page":"Methods","title":"Gadfly.plot","text":"plot(\n    specs::Union{Spectrum...,AbstractVector{Spectrum{<:Real}}};\n    klms=[],\n    edges=[],\n\tescapes=[],\n\tcoincidences=[],\n    autoklms = false,\n    xmin=0.0,\n    xmax=missing,\n    norm=:None,\n    yscale=1.05,\n    ytransform = identity,\n\tstyle=NeXLSpectrumStyle,\n\tpalette=NeXLPalette\n)::Plot\n\nRequired:\n\nspecs::AbstractVector{Spectrum};\n\nNamed:\n\nklms = Union{Element, CharXRay}[ ]\nedges = Union{Element, AtomicSubShell}[ ]\nescapes = Union{Element, CharXRay}[ ],\ncoincidences = CharXRay[ ],\nautoklms = false # Add KLMs based on elements in spectra\nxmin = 0.0 # Min energy (eV)\nxmax = missing # Max energy (eV) (defaults to max(:BeamEnergy))\nnorm = NoScaling() | ScaleDoseWidth() | ScaleDose() | ScaleSum() | ScaleROISum() | ScalePeak() | (<: SpectrumScaling)()\nyscale = 1.05 # Fraction of max intensity for ymax over [max(lld,xmin):xmax]\nytransform = identity | log10 | sqrt | ??? # How to transform the counts data before plotting\nstyle=NeXLSpectrumStyle (or another Gadfly.style)\npalette = NeXLPalette | Colorant[ ... ] # Colors for spectra...\ncustomlayers = Gadfly.Layer[] # Allows additional plot layers to be added\n\nPlot a multiple spectra on a single plot using Gadfly.\n\n\n\n\n\n","category":"method"},{"location":"methods/","page":"Methods","title":"Methods","text":"These types define the different ways that spectra can be scaled when plotted using the Gadfly.plot(...) methods.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.SpectrumScaling\nNeXLSpectrum.NoScaling\nNeXLSpectrum.ScaleSum\nNeXLSpectrum.ScaleDose\nNeXLSpectrum.ScaleDoseWidth\nNeXLSpectrum.ScaleROISum\nNeXLSpectrum.ScalePeak\nNeXLSpectrum.ScaleWidth","category":"page"},{"location":"methods/#NeXLSpectrum.SpectrumScaling","page":"Methods","title":"NeXLSpectrum.SpectrumScaling","text":"SpectrumScaling types are designed to rescale spectrum data primarily for plotting.\n\nImplement\n\nBase.show(io::IO, scn::SpectrumScaling)\nscalefactor(sc::SpectrumScaling, spec::Spectrum)\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.NoScaling","page":"Methods","title":"NeXLSpectrum.NoScaling","text":"Don't scale the spectrum data.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.ScaleSum","page":"Methods","title":"NeXLSpectrum.ScaleSum","text":"Scale to a fixed total integral.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.ScaleDose","page":"Methods","title":"NeXLSpectrum.ScaleDose","text":"Scale to a constant dose (Counts/(nA⋅s)).   Requires a spectrum has both :ProbeCurrent & :LiveTime.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.ScaleDoseWidth","page":"Methods","title":"NeXLSpectrum.ScaleDoseWidth","text":"Scale to a constant dose⋅width (Counts/(nA⋅s/eV))  Requires a spectrum has both :ProbeCurrent & :LiveTime.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.ScaleROISum","page":"Methods","title":"NeXLSpectrum.ScaleROISum","text":"Scale to a default sum in the specified ROI.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.ScalePeak","page":"Methods","title":"NeXLSpectrum.ScalePeak","text":"Scale to a fixed peak intensity\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.ScaleWidth","page":"Methods","title":"NeXLSpectrum.ScaleWidth","text":"Scale to a constant dose⋅width (Counts/(nA⋅s/eV))  Requires a spectrum has both :ProbeCurrent & :LiveTime.\n\n\n\n\n\n","category":"type"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.NeXLSpectrumStyle","category":"page"},{"location":"methods/#NeXLSpectrum.NeXLSpectrumStyle","page":"Methods","title":"NeXLSpectrum.NeXLSpectrumStyle","text":"NeXLSpectrumStyle defines the default look-and-feel for Gadfly.plot(...) as applied to EDS spectra using the Gadfly.plot(...) functions implemented in  NeXLSpectrum.\n\n\n\n\n\n","category":"constant"},{"location":"methods/#Spectrum-Tabulation","page":"Methods","title":"Spectrum Tabulation","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLUncertainties.asa(::Type{DataFrame}, ::Spectrum; properties)\nNeXLUncertainties.asa(::Type{DataFrame}, ::AbstractArray{<:Spectrum})","category":"page"},{"location":"methods/#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, Spectrum}","page":"Methods","title":"NeXLUncertainties.asa","text":"NeXLUncertainties.asa(::Type{DataFrame}, spec::Spectrum; properties::Bool = false)\n\nConverts the spectrum energy and counts data into a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, AbstractArray{<:Spectrum}}","page":"Methods","title":"NeXLUncertainties.asa","text":"NeXLUncertainties.asa(::Type{DataFrame}, spec::AbstractArray{Spectrum})::DataFrame\n\nReturns a DataFrame that summarizes the list of spectra.\n\n\n\n\n\n","category":"method"},{"location":"methods/#HyperSpectrum-Manipulation","page":"Methods","title":"HyperSpectrum Manipulation","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.HyperSpectrum\nNeXLSpectrum.linescan\nNeXLSpectrum.block\nNeXLSpectrum.readrplraw\nNeXLSpectrum.readptx\nNeXLSpectrum.readhspy\nNeXLSpectrum.ishspy\nNeXLSpectrum.plane\nNeXLSpectrum.roiimage\nNeXLSpectrum.compress\nNeXLSpectrum.maxpixel\nNeXLSpectrum.colorize\nNeXLSpectrum.labeledimages\nNeXLSpectrum.labeledimage\nNeXLSpectrum.region\nNeXLSpectrum.indexofmaxpixel\nNeXLSpectrum.roiimages\nNeXLSpectrum.livetime!","category":"page"},{"location":"methods/#NeXLSpectrum.HyperSpectrum","page":"Methods","title":"NeXLSpectrum.HyperSpectrum","text":"HyperSpectrum(arr::Array{T<:Real}, energy::EnergyScale, props::Array{Symbol, Any})\n\nHyperSpectrum(energy::EnergyScale, props::Dict{Symbol,Any}, arr::Array{<:Real}; axisnames = ( \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\" ), fov = ( 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ), livetime=)\nHyperSpectrum(energy::EnergyScale, props::Dict{Symbol,Any}, arr::AxisArray)\nHyperSpectrum(energy::EnergyScale, props::Dict{Symbol,Any}, dims::NTuple{<:Integer}, depth::Int, type::Type{Real}; axisnames = ( \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\" ), fov = ( 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 )\n\nThe HyperSpectrum struct represents a multi-dimensional array of Spectrum objects.  The dimension of a HyperSpectrum may be 1 for a traverse or a line-scan, 2 for a spectrum image or >2 for time-series of spectrum images or multi-slice spectrum images.\n\nThe first constructor is used to create a HyperSpectrum from a raw Array of data.  The second to construct a HyperSpectrum from another HyperSpectrum or an AxisArray.  The third from a description of the intended contents.\n\naxisnames: A list of the names by which the axis can be referred\nfov: The full width of the dimension in mm.\n\nHyperSpectra differ from Array{Spectrum} in that the spectra in a HyperSpectrum must share properties like :ProbeCurrent and :BeamEnergy.  However, each pixel can have it's own livetime.  HyperSpectrum objects can refer  to line-scans (1D), spectrum images (2D), slice-and-view (3D), time sequenced images (3D), or higher dimension spectrum images.\n\nInternally, HyperSpectrum reinterpretes an Array{T<:Real, N+1} as an Array{Spectrum{T<:Real},N-1}.\n\nHyperSpectrum objects can be read from a RPL/RAW file (using readrplraw(filenamebase::AbstractString)) but can be constructed from any Array{<:Real}.\n\nHyperSpectrum objects can be indexed using the standard Julia array idioms including a single integer index or a CartesianIndex.  For example, to iterate over every spectrum in a HyperSpectrum\n\n% Construct a 21 row × 19 column spectrum image with 2048 channels of [0,255].\nhs = HyperSpectrum{es, props, (21,19), 2048, UInt8}\nfor idx in eachindex(hs)\n    spec = hs[idx]   % get a Spectrum representing the 2048 channels of data at idx\n    spec[22] = 1     % Set the 22nd channel to 1\nend\n% Indices into a HyperSpectrum are (row, column)\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.linescan","page":"Methods","title":"NeXLSpectrum.linescan","text":"linescan(hss::HyperSpectrum{T,2,3}, ci1::CartesianIndex{2}, ci2::CartesianIndex{2}, width::Int=1)\n\nExtract pixels from hss along the line from ci1 to ci2 as a 1D HyperSpectrum.  The width argument integrates the linescan along a line perpendicular to the primary axis. Only works on 2D SpectrumImages and for odd values of width.   The algorithm does double count the occasional pixel but the length of each perpendicular is maintained at width. The AxisArrays.axes(...) scaling is maintained so lengths on the linescan can be compared to lengths on the original map.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.block","page":"Methods","title":"NeXLSpectrum.block","text":"block(hss::HyperSpectrum{T,N,NP}, steps::NTuple{N, Int})::HyperSpectrum{T,N,NP} where {T<:Real, N, NP}\nblock(hss::HyperSpectrum{T,N,NP}, step::Int) where {T<:Real, N, NP}\n\nReduce the size of a HyperSpectrum by summing together blocks of adjacent pixels.  For example, steps=(4,4) would sum together blocks of 16 spectra in hss to form a single pixel in the resulting Hyperspectrum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.readrplraw","page":"Methods","title":"NeXLSpectrum.readrplraw","text":"readrplraw(rplfilename::AbstractString, rawfilename::AbstractString)\nreadrplraw(rplio::IO, rawio::IO)\n\nRead a RPL/RAW file pair from IO or filename into an Array obect.  The reader supports :bigendian, :littleendian ordering and :vector or :image alignment.  Since the Array can be very large it is beneficial to release and collected the associated memory when you are done with the data by assigning nothing to the variable (or allowing it to go out of scope) and then calling GC.gc() to force a garbage collection.\n\n* Ordering: The individual data items may be in `:littleendian` or `:bigendian`.\n** `:littleendian` => Intel/AMD and others\n** `:bigendian` => ARM/PowerPC/Motorola\n* Alignment:  The data in the file can be organized as `:vector` or `:image`.  However, the data will be\n\nreorganized into 'vector' format when returned as a Array.     **:vector => Spectrum/data vector as contiguous blocks by pixel     ** :image => Each channel of data organized in image planes     * Data types: signed/unsigned 8/16/32-bit integers or 16-bit/32-bit/64-bit floats\n\nreadrplraw(filenamebase::AbstractString)::Array{<:Real}\n\nRead the files filenamebase\".rpl\" and filenamebase\".raw\" into an Array.  Maintains the data type of the values in the RAW file.\n\nStandard LISPIX Parameters in .rpl File\n\n.rpl files consist of 9 lines.  Each line consists of a 'key'<tab>'value' where there is one and only one tab and possibly other space between the parameter name and parameter value. Parameter names are case-insensitive. The first line in the files is \"key<tab>value\".  Subsequent lines contain the keys and values described in this table.\n\nkey value description\nwidth 849 pixels per row       integer\nheight 846 rows                 integer\ndepth 4096 images or spec pts   integer\noffset 0 bytes to skip        integer\ndata-length 1 bytes per pixel      1, 2, 4, or 8\ndata-type unsigned signed, unsigned, or float\nbyte-order dont-care big-endian, little-endian, or dont-care\nrecord-by vector image, vector, or dont-care\n\nThis .rpl file indicates the image is 849 pixels wide and 846 pixels high, with 4096 levels in the depth dimension.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.readptx","page":"Methods","title":"NeXLSpectrum.readptx","text":"readptx(\n    fn::AbstractString, \n    scale::EnergyScale, # Energy scale for hyperspectrum\n    props::Dict{Symbol,Any},\n    nch::Int; # Number of channels in hyperspectrum\n    blocksize = 1,  # Size of blocks to sum to create averaged hyperspectrum\n    dets=[true,true,true,true], # Which detectors to include\n    frames=1:typemax(Int)) # which frames to include in hyperspectrum\nreadptx(\n    fn::AbstractString, \n    scale::EnergyScale, # Energy scale for hyperspectrum\n    nch::Int; # Number of channels in hyperspectrum\n    blocksize = 1,  # Size of blocks to sum to create averaged hyperspectrum\n    dets=[true,true,true,true], # Which detectors to include\n    frames=1:typemax(Int)) # which frames to include in hyperspectrum\n\nRead a SEMantics .ptx file into a HyperSpectrum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.readhspy","page":"Methods","title":"NeXLSpectrum.readhspy","text":"readhspy(filename::String, name=nothing)\n\nRead a HyperSpectrum from a HyperSpy-style HDF5 file.  The name argument allows the user to optionally specify an experiment to load.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.ishspy","page":"Methods","title":"NeXLSpectrum.ishspy","text":"ishspy(filename::String)::Bool\n\nIs the file a HyperSpy-style HDF5 file?\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.plane","page":"Methods","title":"NeXLSpectrum.plane","text":"plane(hss::HyperSpectrum, chs::AbstractUnitRange{<:Integer}, normalize=false)\n\nSums a contiguous range of data channels into an Array. The dimension of the result is one less than the dimension of the HyperSpectrum and is stored as a Float64 to ensure that not information is lost.\n\n\n\n\n\nplane(hss::HyperSpectrum, ch::Int, normalize=false)\n\nExtracts a single channel plane from a HyperSpectrum. The dimension of the result is one less than the dimension of the HyperSpectrum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.roiimage","page":"Methods","title":"NeXLSpectrum.roiimage","text":"roiimage(hss::HyperSpectrum, chs::AbstractUnitRange{<:Integer})\n\nCreate a count map from the specified contiguous range of channels. (Accounts for differences in :LiveTime between pixels.)\n\n\n\n\n\nroiimage(hss::HyperSpectrum, cxr::CharXRay)\n\nCreate a count map for the specified characteristic X-ray.  By default, integrates for one FWHM at cxr.  If hss[:Detector] is an EDSDetector, the FWHM is taken from it. Otherwise, a FWHM of 130 eV at Mn Kα is assumed.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.compress","page":"Methods","title":"NeXLSpectrum.compress","text":"compress(hss::HyperSpectrum)\n\nReturns a HyperSpectrum with smaller or equal storage space to hss without losing or truncating any counts  (note: AbstractFloat compresses to Float32 with loss of precision).  Can change the storage type and/or  reduce the depth of hss.  If there is nothing that can be done to reduce the size of hss then compress(hss)===hss.\n\nExample:\n\n hs = compress(hs) # Replace `hs` with a version that uses less memory (if possible).\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.maxpixel","page":"Methods","title":"NeXLSpectrum.maxpixel","text":"maxpixel(hss::HyperSpectrum, filt=ci->true)\nmaxpixel(hss::HyperSpectrum, cis::CartesianIndices, filt=ci->true)\nmaxpixel(hss::HyperSpectrum, mask::BitArray)\nminpixel(hss::HyperSpectrum, filt=ci->true)\nminpixel(hss::HyperSpectrum, cis::CartesianIndices, filt=ci->true)\nminpixel(hss::HyperSpectrum, mask::BitArray)\n\nCompute Bright's Max-Pixel derived signal for the entire HyperSpectrum or a rectanglar sub-region.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLCore.colorize","page":"Methods","title":"NeXLCore.colorize","text":"colorize(hss::HyperSpectrum, cxrs::AbstractVector{CharXRay}, normalize=:All)\n\nCreate RGB colorized images from up to three CharXRay which define channels over which the count signal is integrated. normalize=:All puts the intensities on a common scale using the roiimages(...) method.  Otherwise each image is scaled independently based on the brightest pixel.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.labeledimages","page":"Methods","title":"NeXLSpectrum.labeledimages","text":"labeledimages(labels::AbstractVector{<:AbstractString}, images::AbstractVector{<:AbstractArray}; ncols=3, halign = hleft)\n\nCreate a matrix of labeled images.  Useful in Weave, Juno or Jupyter.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.labeledimage","page":"Methods","title":"NeXLSpectrum.labeledimage","text":"labeledimage(label::String, image::Array)\n\nDisplays a string label below an image.  Useful in Weave, Juno or Jupyter.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.region","page":"Methods","title":"NeXLSpectrum.region","text":"region(hss::HyperSpectrum{T, N}, ranges::AbstractRange...)::HyperSpectrum where {T<:Real,N}\n\nCreates a view of a HyperSpectrum to represent the range of pixels within the hss HyperSpectrum.  Does not copy the data or properties so any modifications to the region are also made to hss.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.indexofmaxpixel","page":"Methods","title":"NeXLSpectrum.indexofmaxpixel","text":"indexofmaxpixel(hss::HyperSpectrum, ch::Int) # at channel `ch`\nindexofmaxpixel(hss::HyperSpectrum) # all channels\nindexofmaxpixel(hss::HyperSpectrum, ch::Int, cis::CartesianIndices)\nindexofmaxpixel(hss::HyperSpectrum, cis::CartesianIndices)\n\nFind the indices producing the maximum value in data[ch] or data[:] within 'cis' or full spatial dimensions.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.roiimages","page":"Methods","title":"NeXLSpectrum.roiimages","text":"roiimages(hss::HyperSpectrum, achs::AbstractVector{<:AbstractUnitRange{<:Integer}})\n\nCreate an array of Gray images representing the intensity in each range of channels in in achs.  They are normalized such the the most intense pixel in any of them defines white. (Accounts for differences in :LiveTime between pixels.)\n\n\n\n\n\nroiimages(hss::HyperSpectrum, cxrs::AbstractVector{CharXRay})\n\nCreate an array of Gray images representing the intensity in each of the CharXRay lines in cxrs.  They are normalized such the the most intense pixel in any of them defines white. By default, integrates for one FWHM at cxr.  If hss[:Detector] is an EDSDetector, the FWHM  is taken from it.   Otherwise, a FWHM of 130 eV at Mn Kα is assumed.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.livetime!","page":"Methods","title":"NeXLSpectrum.livetime!","text":"livetime!(hss::HyperSpectrum, lt::AbstractFloat, idx...)\nlivetime!(hss::HyperSpectrum{T,N}, lt::AbstractFloat) # All pixels to lt\n\nSet the livetime on a per pixel basis.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Fitting-Filter","page":"Methods","title":"Fitting Filter","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Core methods for constructing FilterFitPackets and fitting spectra.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.reference\nNeXLSpectrum.references\nNeXLSpectrum.FilterFitPacket\nNeXLSpectrum.suitability\nNeXLSpectrum.suitablefor\nNeXLSpectrum.fit_spectrum\nNeXLSpectrum.FilteredReference\nNeXLSpectrum.spectra\nNeXLCore.elms\nNeXLSpectrum.missingReferences\nNeXLSpectrum.BasicFitResult\nNeXLSpectrum.FilterFitResult\nNeXLSpectrum.kratios\nNeXLSpectrum.spectrum\nNeXLSpectrum.residual\nNeXLSpectrum.filteredresidual\nNeXLUncertainties.extract\nNeXLSpectrum.fit_spectra","category":"page"},{"location":"methods/#NeXLSpectrum.reference","page":"Methods","title":"NeXLSpectrum.reference","text":"reference( elm::Element, spec::Spectrum, mat::Material=spec[:Composition]; pc = nothing, lt = nothing, e0 = nothing, coating = nothing)::ReferencePacket\nreference(els::AbstractVector{Element}, spec::Spectrum, mat::Material = spec[:Composition]; pc = nothing, lt = nothing, e0 = nothing, coating = nothing)::Vector{ReferencePacket}\n\nConstruct a ReferencePacket from a Spectrum collected from the specified Material for the specified Element. Often used with references(...) to build FilterFitPackets.\n\nOptional named arguments pc, lt, e0, coating allow you to specify the probe current, live time, beam energy and sample coating.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.references","page":"Methods","title":"NeXLSpectrum.references","text":"references(refs::AbstractVector{ReferencePacket}, det::EDSDetector)::FilterFitPacket\nreferences(refs::AbstractVector{ReferencePacket}, fwhm::Float64)::FilterFitPacket\n\nConstructs a FilterFitPacket from a vector of ReferencePackets.  Each ReferencePacket represents a  single ROI for an element.  It is possible more than one ReferencePacket might be defined for an  elemental ROI.  In this case, the ReferencePacket with the lower index will take preference over later ones.  This allows you to fill in only the missing elemental ROIs using spectra collected from  alternative materials.  For example, a spectrum from F₂Fe is suitable for the Fe K-lines but not the  Fe L-lines. So we might specify F₂Fe first to specify the references for the Fe K-lines and then fill  in the L-lines with a spectrum from pure Fe.\n\n\n\n\n\nreferences(refs::Vector{DirectRefInit}, det::Detector, resp::Matrix{Float64}; minE=0.5e3 )\n\nUse along with direct(...) to build a collection of direct fitting references.\n\nExample:\n\n> detu = matching(unk, 132.0, 110)\n> resp = detectorresponse(detu, SDDEfficiency(ModeledWindow(MoxtekAP33())))\n> drefs = references([ \n      direct(n\"O\", stds[1], mat\"Al2O3\"),\n      direct(n\"Al\", stds[1], mat\"Al2O3\"),\n      direct(n\"Ba\", stds[2], mat\"BaF2\"),\n      direct(n\"Ca\", stds[3], mat\"CaF2\"),\n      direct(n\"Fe\", stds[4], mat\"Fe\"),\n      direct(n\"Si\", stds[5], mat\"Si\") ],\n      detu, resp\n  )\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.FilterFitPacket","page":"Methods","title":"NeXLSpectrum.FilterFitPacket","text":"Represents the processed spectral data necessary to efficiently filter-fit one or more unknown spectra. A FilterFitPacket{S<:Detector, T<:AbstractFloat} contains the data necessary to filter the unknown and to  apply pre-filtered references.  The type T <: AbstractFloat allows you to specify the bit-depth used to perform subsequent calculations using this FilterFitPacket.  Float32 uses less memory and is a little faster than Float64.  If there are duplicate FilteredReference for an elemental ROI, the preference  is for the first one.  This allows you to fill in unavailable \"FilteredReference\" elemental ROIs with more  general ones.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.suitability","page":"Methods","title":"NeXLSpectrum.suitability","text":"suitability(elm::Element, mats::AbstractSet{<:Material}, det::Detector; maxE=30.0e3)\nsuitability(elm::Element, det::Detector; maxE=30.0e3, minC=0.1)\n\nTabulates the characteristic X-ray peaks for the Element for which there are suitable materials  in mats for the specified detector.  The second form uses a default set of Materials in the file NeXLCore \"standards.txt\".\n\nThis function is helpful for determining which Materials are suitable to act as  fitting standards for the specified Element.  It shows how NeXLSpectrum will break up the  characteristic peaks associated with elm into contiguous regions each of which will be  fit independently. NeXLSpectrum attempts to break each element into as many independent  regions as possible dependent on the resolution of the specified EDSDetector.  If there is an interference between one of the other elements in the Material and elm then this peak will not be suitable as a fitting standard.  However, it can be used as a  similar standard.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.suitablefor","page":"Methods","title":"NeXLSpectrum.suitablefor","text":"suitablefor(\n    elm::Element, \n    matOrElms::Union{Material, AbstractSet{Element}}, \n    det::Detector; \n    maxE::Float64 = 1.0e6, \n    ampl::Float64 = 1.0e-5,\n    warnme::Bool = true\n)::Vector{Tuple{Vector{CharXRay}, UnitRange{Int64}}}\n\nGiven a material or collection of Element which ROIs for element elm is the material a suitable reference on the detector det?   This function provides informational, warning and error messages depending upon the suitability of the material. \n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.fit_spectrum","page":"Methods","title":"NeXLSpectrum.fit_spectrum","text":"fit_spectrum(\n    hs::Spectrum|HyperSpectrum,\n    vq::VectorQuant{S <: Detector, T <: AbstractFloat},\n    zero = x -> max(Base.zero(T), x)\n)\n\nFit the spectrum or hyper-spectrum using the vector-quant algorithm. The function zero is applied to the resultant k-ratios before they are returned.  The default simply sets negative k-ratios to 0.0.  zero=identity would leave the negative k-ratios as such.\n\n\n\n\n\nfit_spectrum(unk::Spectrum{T}, drefs::DirectReferences)::DirectFitResult{T} where { T <: Real }\n\nFits the direct references to the unknown spectrum returning a DirectFitResult struct containing k-ratios and other output quantities from the fit.\n\nSurprisingly, this function requires that unk[:Composition] is defined as a Material with an estimate of the composition of the material from which unk was collected.  This information is necessary to model the continuum background.  Yes, this seems circular (and it is.)  One option is to perform a filter-fit first, quantify the filter fit and then use this as your estimate.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.FilteredReference","page":"Methods","title":"NeXLSpectrum.FilteredReference","text":"FilteredReference\n\nRepresents the filtered reference spectrum over an ROI. Carries the minimal data necessary to support filter-fitting a single region-of-interest (continguous range of channles) and computing useful output statistics.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.spectra","page":"Methods","title":"NeXLSpectrum.spectra","text":"Returns a tuple containing the unfiltered spectra associated with the references.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLCore.elms","page":"Methods","title":"NeXLCore.elms","text":"elms(spec::Spectrum, withcoating = false)::Set{Element}\n\nReturns a set of the elements associated with this spectrum. withcoating determines whether the coating elements are also added.\n\n\n\n\n\nA list of elements for which there are filtered references.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.missingReferences","page":"Methods","title":"NeXLSpectrum.missingReferences","text":"missingReferences(ffp::FilterFitPacket, elms::Vector{Element}, e0::Float64, ampl=1.0e-5)\n\nReturns a Vector{Tuple{Vector{CharXRay}, UnitRange{Int64}}} containing the ROIs for which a  FilteredReference is missing from the FilterFitPacket.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.BasicFitResult","page":"Methods","title":"NeXLSpectrum.BasicFitResult","text":"A measured set of correlated k-ratios.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.FilterFitResult","page":"Methods","title":"NeXLSpectrum.FilterFitResult","text":"FilterFitResult\n\nRepresents the result of fitting a FilteredUnknownW to a FilteredUnknown.\n\nStruct elements\n\nlabel::UnknownLabel  # Identifies the unknown\nkratios::UncertainValues # Labeled with ReferenceLabel objects\nroi::UnitRange{Int} # Range of channels fit\nraw::Vector{T} # Raw spectrum data\nresidual::Deferred # Residual spectrum\npeakback::Deferred # {Dict{ReferenceLabel,NTuple{3,Float64}}} with peak counts, background counts and counts/(nAs)\n\nUse asa(DataFrame, ffr::FilterFitResult) to summarize in tabular form.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.kratios","page":"Methods","title":"NeXLSpectrum.kratios","text":"kratios(ffr::FitResult)::Vector{KRatio}\n\nThe k-ratios associated with each CharXRayLabel as a vector 'KRatio' objects.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.spectrum","page":"Methods","title":"NeXLSpectrum.spectrum","text":"spectrum(ffr::FilterFitResult)::Spectrum\n\nReturns the original unknown spectrum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.residual","page":"Methods","title":"NeXLSpectrum.residual","text":"residual(ffr::FilterFitResult)::Spectrum\n\nA Spectrum containing the histogram representing the unknown spectrum minus the fitted characteristic peaks shapes times the best fit coefficient.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.filteredresidual","page":"Methods","title":"NeXLSpectrum.filteredresidual","text":"filteredresidual(fit::FilterFitResult, unk::FilteredUnknown, ffs::AbstractVector{FilteredReference})::Vector{Float64}\n\nComputes the difference between the best fit and the unknown filtered spectral data.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLUncertainties.extract","page":"Methods","title":"NeXLUncertainties.extract","text":"extract(fd::FilteredReference{T}, roi::UnitRange{Int})::Vector{T} where { T <: AbstractFloat }\nextract(fd::FilteredUnknown, roi::UnitRange{Int})::Vector{T} where { T <: AbstractFloat }\n\nExtract the filtered data representing the specified range.  roi must fully encompass the filtered data in fd.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.fit_spectra","page":"Methods","title":"NeXLSpectrum.fit_spectra","text":"fit_spectrum(spec::Spectrum, ffp::FilterFitPacket)::FilterFitResult\nfit_spectrum(specs::AbstractVector{<:Spectrum}, ffp::FilterFitPacket)::Vector{FilterFitResult}\nfit_spectra(specs::AbstractVector{<:Spectrum}, ffp::FilterFitPacket)::Vector{FilterFitResult}\n\nFit a Spectrum or a vector of Spectrum using the specified FilterFitPacket.  The result is a FilterFitResult structure which contains k-ratios, residuals, etc. \n\nfit_spectrum(hs::HyperSpectrum, ffp::FilterFitPacket; mode::Symbol=:Fast, zero = x -> max(0.0, x))::Array{KRatios}\n\nmode = :Fast - Uses precomputed, filtered \"vector\" fit method.  No uncertainties are available.\nmode = :Intermediate - Uses an optimized full fit without refits for negative k-ratios.\nmode = :Full - Uses the full single spectrum fit algorithm including refitting when one or more k-ratio is less than zero.\n\nPerforms a filtered fit on a hyperspectrum returning an Array{KRatios}.\n\nSelecting a mode:   :Fast is good for generating k-ratio maps or exploratory analysis of a k-ratio map. :Full is best when a   quantitative map of a high count hyperspectrum is desired.  Fit results for major elements are similar for   all three but differ for minor and trace elements.  Particularly when a k-ratio is slightly negative. This   negative k-ratio can effect the other k-ratios.  :Fast also works less well when many elements (>>10) (particularly   interfering elements) are included in the fit. Unfortunately, :Intermediate and :Full slow down when many elements   are fit - O(n(elements)²).\n\nThe following timing on a 512 x 512 x 2048 hyperspectrum fitting 21 elements with 33 distinct ROIs on a fast 6-core  laptop with 16 GiB memory give a relative feel for the speed of each algorithm.  Yes, :Fast is approximately 30 ×  faster than :Intermediate and used almost 80x less memory.  (64-bit references, 32-bit references use about 1/2  the memory and take about 4/5 the time.)\n\nmode= Threads Run time (s) Allocations Allocated (GiB) GC time\n:Fast 6 11.4 2.11 M 4.72 3.0%\n:Intermediate 6 342.7 13.11 M 364.4 4.2%\n:Full 6 574.6 6.2 G 862.9 5.5%\n:Fast 1 25.5 2.1 M 4.72 1.8%\n:Intermediate 1 1064.6 13.1 M 364.4 0.9%\n:Full 1 2186.2 6.2 G 862.1 2.8%\n\n\n\n\n\n","category":"function"},{"location":"methods/#Filter-Fit-Tabulation","page":"Methods","title":"Filter Fit Tabulation","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLUncertainties.asa(::Type{DataFrame}, ::FilterFitPacket)\nNeXLUncertainties.asa(::Type{DataFrame}, ::AbstractVector{<:FitResult}; charOnly, withUnc, format)\nNeXLUncertainties.asa(::Type{DataFrame}, ::FilterFitResult; charOnly, material, columns, mc, fc)\nNeXLUncertainties.asa(::Type{DataFrame}, ::FitResult; withUnc)","category":"page"},{"location":"methods/#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, FilterFitPacket}","page":"Methods","title":"NeXLUncertainties.asa","text":"NeXLUncertainties.asa(::Type{DataFrame}, ffp::FilterFitPacket)\n\nSummarize the FilteredReference structs within a FilterFitPacket as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, AbstractVector{<:FitResult}}","page":"Methods","title":"NeXLUncertainties.asa","text":"NeXLUncertainties.asa(::Type{DataFrame}, ffrs::AbstractVector{<:FitResult}; charOnly = true, withUnc = false, format = :normal # :pivot or :long)\n\nReturn generic FitResult as a DataFrame.\n\nFormat:\n\n:normal - One row per spectrum, one column per k-ratio\n:pivot - One row per ROI, one column per spectrum (optional: column for 1σ uncertainty on k-ratio)\n:long - One row per spectrum, feature, measured k-ratio\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, FilterFitResult}","page":"Methods","title":"NeXLUncertainties.asa","text":"NeXLUncertainties.asa(\n    ::Type{DataFrame}, \n    ffr::FilterFitResult; \n    charOnly::Bool=true, \n    material=nothing,\n    mc = XPP, fc=ReedFluorescence,\n    columns = ( :counts, ) # Selected from ( :roi, :peakback, :counts, :dose )\n)::DataFrame\n\nTabulate details about each region-of-interest in the 'FilterFitResult' in a 'DataFrame'.\n\nIf charOnly then only display characteristic X-ray data (not escapes etc.)\nIf material is a Material then the computed k-ratio (KCalc) will also be tabulated along with kmeas/kcalc (KoKCalc).\ncolumns - Select optional column outputs (see below)\n\nColumns:\n\nSpectrum : UnknownLabel - Identifies the fit spectrum\nFeature  : Label - Identifies the fit feature (Vector{CharXRay} or other)\nReference: String - Name of reference against which :Spectrum was fit over :Feature\nK : Float64 - The multiplicative fit constant\ndK : Float64 - The 1σ uncertainty in :K\n:Start : Int - Start index for fit channels (:roi ∈ columns)\n:Stop : Int - Stop index for fit channels  (:roi ∈ columns)\n:Counts : Float64 - Total counts in characteristic peak (peak-back) (:peakback || :counts ∈ columns)\n:Back : Float64 - Total counts in background under the characteristic peak (:peakback ∈ columns)\n:PtoB : Float64 - Peak-to-Background assuming 10 eV/channel (:peakback ∈ columns)\n:KCalc : Float64 - Computed k-ratio assuming a composition. (Requires material argument to be specified.)\n:KoKcalc : Float64 - Ratio of measured/computed k-ratio.  (Requires material argument to be specified.)\n:LiveTime : Float64 - Acquisiton live time (s) (:dose ∈ columns)\n:ProbeCurrent : Float64 - Probe current (nA) (:dose ∈ columns)\n:DeadPct : Float64 - Dead time in ProbeCurrent (:dose ∈ columns)\n:RefCountsPernAs : Float64 - Estimated counts in :Reference in :Feature per unit dose.  (:counts ∈ columns)\n:CountsPernAs : Float64 - Estimated counts in :Spectrum in :Feature per unit dose.  (:counts ∈ columns)\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLUncertainties.asa-Tuple{Type{DataFrames.DataFrame}, FitResult}","page":"Methods","title":"NeXLUncertainties.asa","text":"NeXLUncertainties.asa(::Type{DataFrame}, fr::FitResult; withUnc = false)\n\nSummarize the ROI and k-ratio data within a FitResult structure as a DataFrame. \n\n\n\n\n\n","category":"method"},{"location":"methods/#Filter-Fit-Plotting","page":"Methods","title":"Filter Fit Plotting","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Gadfly.plot(vq::VectorQuant, chs::UnitRange)\nGadfly.plot(ff::TopHatFilter, fr::FilteredReference)\nGadfly.plot(fr::FilteredReference; palette) \nGadfly.plot(ffp::FilterFitPacket; kwargs...)\nGadfly.plot(ffr::FilterFitResult, roi::Union{Nothing, AbstractUnitRange{<:Integer}}; palette, style, xmax, comp, det, resp, yscale)","category":"page"},{"location":"methods/#Gadfly.plot-Tuple{VectorQuant, UnitRange}","page":"Methods","title":"Gadfly.plot","text":"Gadfly.plot(vq::VectorQuant, chs::UnitRange)\n\nPlots the \"vectors\" used to quantify various elements/regions-of-interest over the range of channels specified.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Gadfly.plot-Tuple{TopHatFilter, FilteredReference}","page":"Methods","title":"Gadfly.plot","text":"plot(ff::TopHatFilter, fr::FilteredReference)\n\nPlot a color map showing the filter data relevant to filtering the specified FilteredReference.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Gadfly.plot-Tuple{FilteredReference}","page":"Methods","title":"Gadfly.plot","text":"Gadfly.plot(fr::FilteredReference; palette = NeXLPalette))\n\nPlot a filtered reference spectrum.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Gadfly.plot-Tuple{FilterFitPacket}","page":"Methods","title":"Gadfly.plot","text":"Gadfly.plot(ffp::FilterFitPacket; kwargs...)\n\nPlots the reference spectra which were used to construct a FilterFitPacket.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Gadfly.plot-Tuple{FilterFitResult, Union{Nothing, AbstractUnitRange{<:Integer}}}","page":"Methods","title":"Gadfly.plot","text":"Gadfly.plot(\n    ffr::FilterFitResult,\n    roi::Union{Nothing,AbstractUnitRange{<:Integer}} = nothing;\n    palette = NeXLPalette,\n    style = NeXLSpectrumStyle,\n    xmax::Union{AbstractFloat, Nothing} = nothing,\n    comp::Union{Material, Nothing} = nothing,\n    det::Union{EDSDetector, Nothing} = nothing,\n    resp::Union{AbstractArray{<:AbstractFloat,2},Nothing} = nothing,\n    yscale = 1.0\n)\n\nPlot the sample spectrum, the residual and fit regions-of-interests and the associated k-ratios.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Advanced-Filter-Fitting","page":"Methods","title":"Advanced Filter Fitting","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.TopHatFilter\nNeXLSpectrum.ConstantWidthFilter\nNeXLSpectrum.GaussianFilter\nNeXLSpectrum.VariableWidthFilter\nNeXLSpectrum.tophatfilter\nNeXLSpectrum.buildfilter\nNeXLSpectrum.FilteredUnknownW\nNeXLSpectrum.filterfit\nNeXLSpectrum.isvisible\nNeXLSpectrum.ReferenceLabel\nNeXLSpectrum.SpectrumFeature\nNeXLSpectrum.CharXRayLabel\nNeXLSpectrum.EscapeLabel\nNeXLSpectrum.UnknownLabel\nNeXLSpectrum.charXRayLabels\nNeXLSpectrum.direct\nNeXLSpectrum.detect\nNeXLSpectrum.filterreference\n","category":"page"},{"location":"methods/#NeXLSpectrum.TopHatFilter","page":"Methods","title":"NeXLSpectrum.TopHatFilter","text":"The TopHatFilter{T <: AbstractFloat} struct represents a zero-sum symmetric second-derivative-like filter that when  applied to spectral data has the property of suppressing constant and slowly varying signals (like the continuum) while retaining a linear signal for faster changing signals like the characteristic peaks.\n\nSee\n\nF. H. Schamber Proc Symposium of \"X-ray Fluorscence Analysis on Environmental Samples\" Chapel Hill 1976 T Dzubay Ed.\nP. Statham Anal Chem 49 no 14 Dec 1977\n\nThe TopHatFilter struct optimizes the memory and CPU use when applying top-hat filters to spectrum data.\n\nThe easiest way to implement a top-hat filter is as matrix F.  The rows represent the filters.  The product of the filter and the data vector is the filtered spectrum.  The product of the filter times a diagnonal matrix constructed from the data times the transpose of the filter is the covariance of the filtered data.  The diagonal matrix constructed from the spectrum data is the covariance matrix associated with the spectrum data because the channels in the spectrum data are independent (thus the matrix is diagnonal) and the magnitude equals the counts in each channels because the spectrum data is nominally Poissonian and in the large number limit, the variance of a Poissonian random variable is the number itself (σ=sqrt(N) => Var = N)\n\nNotes on memory and code optimization: The filter matrix is banded diagonal.  Approximately, 2.5% of the elements are non-zero.  This suggest use of the BandedMatrix type.  The most expensive operation is calculating F⋅D⋅Fᵀ, the covariance matrix of the filtered data. D is a diagonal matrix and so computing each element in F⋅D⋅Fᵀ reduces to a sum over a single variable. Furthermore, the weighted least squares fit doesn't require the full F⋅D⋅Fᵀ, just diag(F⋅D⋅Fᵀ).  However, it turns out that we can do better implementing our own banded matrix type largely because D is fully diagonal and the matrix product F⋅D⋅Fᵀ reduces down to a sum over a single variable.  The product F⋅d and F⋅D⋅Fᵀ are readily implemented as element-by-element multiplies and sums.  Thus storing the filter as offsets and row filters is efficient in both memory and CPU use.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.ConstantWidthFilter","page":"Methods","title":"NeXLSpectrum.ConstantWidthFilter","text":"ConstantWidthFilter\n\nA top-hat filter that has constant width determined by FWHM at Mn Kα for all channels.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.GaussianFilter","page":"Methods","title":"NeXLSpectrum.GaussianFilter","text":"GaussianFilter\n\nA Gaussian-shaped filter that varies in width with the FWHM of the detector.  The Gaussian is offset to ensure the sum of the filter elements is zero.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.VariableWidthFilter","page":"Methods","title":"NeXLSpectrum.VariableWidthFilter","text":"VariableWidthFilter\n\nA top-hat filter that varies in width with the FWHM of the detector.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.tophatfilter","page":"Methods","title":"NeXLSpectrum.tophatfilter","text":"tophatfilter(\n    charLabel::Union{CharXRayLabel,EscapeLabel, ReferenceLabel}\n    filt::TopHatFilter{T},\n    scale::T = one(T),\n    tol::T = (T==Float32 ? 1.0f-5 : 1.0e-6)\n)::FilteredReference\n\nFor filtering an ROI on a reference spectrum. Process a portion of a Spectrum with the specified filter.  Use a simple edge-based background model.\n\ntophatfilter(\n    labels::AbstractVector{ReferenceLabel},\n    filt::TopHatFilter{T},\n    scale::T = one(T),\n    tol::T = (T==Float32 ? 1.0f-5 : 1.0e-6)\n)::Vector{FilteredReference{T}}\n\n\n\n\n\ntophatfilter(spec::Spectrum, filt::TopHatFilter{T}, scale::T = one(T))::FilteredUnknown where { T <: AbstractFloat }\n\nFor filtering the unknown spectrum. Defaults to the weighted fitting model.\n\n\n\n\n\ntophatfilter(::Type{FilteredUnknownW}, spec::Spectrum, thf::TopHatFilter, scale::Float64=1.0, tol::Float64 = 1.0e-4)::FilteredUnknownW\n\nFor filtering the unknown spectrum. Process the full Spectrum with the specified filter for use with the weighted least squares model.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.buildfilter","page":"Methods","title":"NeXLSpectrum.buildfilter","text":"buildfilter(\n    [ ::Type{T} = Float64],\n    ty::Type{<:TopHatFilterType},\n    det::Detector,\n    a::AbstractFloat = 1.0, # Top\n    b::AbstractFloat = 2.0,  # Base\n)\nbuildfilter(::Type{T}, det::Detector, a::AbstractFloat = 1.0, b::AbstractFloat = 2.0) where { T<:AbstractFloat }\nbuildfilter(det::Detector, a::AbstractFloat = 1.0, b::AbstractFloat = 2.0)::TopHatFilter{Float64}\nbuildfilter(ty::Type{<:TopHatFilterType}, det::Detector, a::AbstractFloat = 1.0, b::AbstractFloat = 2.0)::TopHatFilter{Float64}\n\nBuild a top-hat filter for the specified detector with the specified top and base parameters.  The default element type is Float64 and the default shape model (TopHatFilterType) is VariableWidthFilter.\n\n\n\n\n\nbuildfilter(::Type{GaussianFilter}, det::Detector, a::AbstractFloat=1.0, b::AbstractFloat=6.0)::TopHatFilter\n\nBuild a top-hat filter with Gaussian shape whose width varies with the detector's resolution as a function of X-ray energy for the specified detector with the specified top and base parameters. The a parameter corresponds to the filter width relative to the detector resolution expressed as Gaussian width.  So a=1 is a filter whose width equals the detector resolution at each energy.  The b parameter is the extent of the filter in Gaussian widths.  The default a=1, b=5 corresponds to a  filter that has the same resolution as the detector and an extent of 2.5 Gaussian widths above and below the center channel.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.FilteredUnknownW","page":"Methods","title":"NeXLSpectrum.FilteredUnknownW","text":"FilteredUnknownW\n\nRepresents the unknown in a filter fit using the weighted fitting model.  This is an approximation that produces over optimistic resulting covariance matrix.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.filterfit","page":"Methods","title":"NeXLSpectrum.filterfit","text":"filterfit(unk::FilteredUnknownW, ffs::AbstractVector{FilteredReference}, forcezeros = true)::FilterFitResult\n\nFilter fit the unknown against ffs, an array of FilteredReference and return the result as an FilterFitResult object. By default use the generalized LLSQ fitting (pseudo-inverse implementation).\n\nThis function is designed to reperform the fit if one or more k-ratio is less-than-or-equal-to zero.  The FilteredReference corresponding to the negative value is removed from the fit and the fit is reperformed. How the non-positive value is handled is determine by forcezeros. If forcezeros=true, then the returned k-ratio for the non-positive value will be set to zero (but the uncertainty remains the fitted one).  However, if forcezeros=false, then the final non-positive k-ratio is returned along with the associated uncertainty.  forcezeros=false is better when a number of fit k-ratio sets are combined to produce an averaged k-ratio with reduced uncertainty. forcezeros=true would bias the result positive.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.isvisible","page":"Methods","title":"NeXLSpectrum.isvisible","text":"isvisible(cxrs::AbstractVector{<:SpectrumFeature}, det::Detector)\n\nReturns the characteristic x-rays that are visible on the specified detector (ie. Between the LLD and the maximum channel).\n\n\n\n\n\nisvisible(sf::SpectrumFeature, det::Detector)\n\nIs sf visible on the specified Detector?\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.ReferenceLabel","page":"Methods","title":"NeXLSpectrum.ReferenceLabel","text":"ReferenceLabel\n\nA label associated with reference spectra.  The label encapsulates the original spectrum and the range of channels represented by this reference object.  structs that extend ReferenceLabel should have .roi, .spectrum and \".hash\"  fields.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.SpectrumFeature","page":"Methods","title":"NeXLSpectrum.SpectrumFeature","text":"SpectrumFeature\n\nA union representing the different type of peak-like features (helpful and harmful) that can appear in a spectrum.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.CharXRayLabel","page":"Methods","title":"NeXLSpectrum.CharXRayLabel","text":"CharXRayLabel\n\nA ReferenceLabel that represents a reference spectrum or reference properties associated with a set of  characteristic x-rays (CharXRay) objects over a contiguous range of spectrum channels.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.EscapeLabel","page":"Methods","title":"NeXLSpectrum.EscapeLabel","text":"EscapeLabel\n\nA ReferenceLabel<:FilteredLabel that Represents a reference spectrum associated with an escape peak from a set of characteristic x-rays (CharXRay) objects over a contiguous range of spectrum channels.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.UnknownLabel","page":"Methods","title":"NeXLSpectrum.UnknownLabel","text":"UnknownLabel\n\nA Label that represents the unknown spectrum.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.charXRayLabels","page":"Methods","title":"NeXLSpectrum.charXRayLabels","text":"charXRayLabels(#\n  spec::Spectrum, #\n  elm::Element, #\n  allElms::AbstractSet{Element}, #\n  det::Detector, #\n  ampl::Float64, #\n  maxE::Float64=1.0e6)::Vector{SpectrumFeature}\n\nCreates a vector of CharXRayLabel objects associated with 'elm' for a spectrum containing the elements 'allElms' assuming that it was collected on 'det'.  ROIs in which other elements from 'allElms' interfere with 'elm' will not be included.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.direct","page":"Methods","title":"NeXLSpectrum.direct","text":"direct(elm::Element, spec::Spectrum, mat::Material=spec[:Composition])\ndirect(elm::Element, specfile::String, mat::Material)\ndirect(elm::Element, specfile::String)\n\nConstruct a struct to represent a direct-fit reference. Use with references(...) to construct a reference set which may be used to fit multiple references to an unknown spectrum using a \"direct\" linear fit.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.detect","page":"Methods","title":"NeXLSpectrum.detect","text":"detect(emitted::Dict{<:XRay,<:Real}, det::EDSDetector, response::Matrix{Float64}; noise=false)\n\nReturns a Spectrum as though the intensities in emitted were detected on the specified detector. noise=true will add Poisson noise to the resulting measured Spectrum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.filterreference","page":"Methods","title":"NeXLSpectrum.filterreference","text":"filterreference(\n    filt::TopHatFilter{T},\n    spec::Spectrum,\n    elm::Element,\n    allElms::[AbstractSet{Element}|Material]\n    props::Dict{Symbol,<:Any} = Dict{Symbol,Any}(),\n    withEsc::Bool = false,\n)\nfilterreferences(\n    filt::TopHatFilter,\n    refs::Tuple{Spectrum,Element,Material}...;\n    props::Dict{Symbol,<:Any} = Dict{Symbol,Any}(),\n    withEsc::Bool = false,\n)\n\n\n\n\n\n","category":"function"},{"location":"methods/#Matrix-Correction","page":"Methods","title":"Matrix Correction","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLMatrixCorrection.quantify\nNeXLMatrixCorrection.estimatecoating","category":"page"},{"location":"methods/#NeXLMatrixCorrection.quantify","page":"Methods","title":"NeXLMatrixCorrection.quantify","text":"NeXLMatrixCorrection.quantify(\n    ffr::FitResult,\n    iteration::Iteration = Iteration(mc=XPP, fc=ReedFluorescence, cc=Coating);\n    strip::AbstractVector{Element} = Element[],\n    kro::KRatioOptimizer = SimpleKRatioOptimizer(1.5),\n    coating::Union{Nothing, Pair{CharXRay, <:Material}}=nothing\n)::IterationResult\n\nFacilitates converting FilterFitResult or BasicFitResult objects into estimates of composition by extracting k-ratios from measured spectra and applying matrix correction algorithms.\n\n\n\n\n\nNeXLMatrixCorrection.quantify(\n    spec::Union{Spectrum,AbstractVector{<:Spectrum}},\n    ffp::FilterFitPacket;\n    strip::AbstractVector{Element} = Element[],\n    iteration::Iteration = Iteration(mc=XPP, fc=ReedFluorescence, cc=Coating),\n    kro::KRatioOptimizer = SimpleKRatioOptimizer(1.5),\n    coating::Union{Nothing, Pair{CharXRay, <:Material}}=nothing\n)::IterationResult\n\nFailitates quantifying spectra.  First filter fits and then matrix corrects.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLMatrixCorrection.estimatecoating","page":"Methods","title":"NeXLMatrixCorrection.estimatecoating","text":"NeXLMatrixCorrection.estimatecoating(fr::FitResult, substrate::Material, coating::Material, cxr::CharXRay, mc::Type{<:MatrixCorrection}=XPP)::Film\n\nEstimate the mass-thickness of coating on bulk substrate using the X-ray cxr for which there is KRatio in fr.  The result is assigned to the properties of fr so that it can be account for in the matrix correction process.\n\nThis method is intended for use on standards where the substrate composition is known a priori.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Standardization","page":"Methods","title":"Standardization","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.extractStandards\nNeXLCore.standardize\n","category":"page"},{"location":"methods/#NeXLSpectrum.extractStandards","page":"Methods","title":"NeXLSpectrum.extractStandards","text":"extractStandards(ffr::FitResult, elm::Element, mat::Material)::Vector{KRatio}\n\nExtract a Vector{KRatio} for elm::Element from a ffr::FilterFitResult measured from mat::Material. \n\n\n\n\n\nextractStandards(ffr::FitResult, cxrs::AbstractVector{CharXRay}, mat::Material)::Vector{KRatio}\n\nExtract a KRatio for the CharXRay from a FilterFitResult associated with the Material.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLCore.standardize","page":"Methods","title":"NeXLCore.standardize","text":"NeXLCore.standardize(ffr::FilterFitResult{T}, standard::FilterFitResult{T}, material::Material, els=elms(material))::FilterFitResult{T}\nNeXLCore.standardize(ffrs::Vector{FilterFitResult{T}}, standard::FilterFitResult{T}, material::Material, els=elms(material))::Vector{FilterFitResult{T}}\nNeXLCore.standardize(ffr::FilterFitResult{T}, standards::AbstractArray{KRatio})::FilterFitResult{T}\nNeXLCore.standardize(ffrs::Vector{FilterFitResult{T}}, standards::AbstractArray{KRatio})::Vector{FilterFitResult{T}}\n\nApply the standard KRatios to the FilterFitResult producing a re-standardized FilterFitResult.\n\n\n\n\n\n","category":"function"},{"location":"methods/#EDS-Detectors","page":"Methods","title":"EDS Detectors","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.Detector\nNeXLSpectrum.EDSDetector\nNeXLSpectrum.resolution\nNeXLSpectrum.Resolution\nNeXLSpectrum.simpleEDSwICC\nNeXLSpectrum.MnKaResolution\nNeXLSpectrum.matches\nNeXLSpectrum.TabulatedWindow\nNeXLSpectrum.DirectReference\nNeXLSpectrum.BerylliumWindow\nNeXLSpectrum.AmptekC2\nNeXLSpectrum.DirectFitResult\nNeXLSpectrum.WindowType\nNeXLSpectrum.DirectReferences\nNeXLSpectrum.AbstractWindow\nNeXLSpectrum.NoWindow\nNeXLSpectrum.ModeledWindow\nNeXLSpectrum.AmptekC1","category":"page"},{"location":"methods/#NeXLSpectrum.Detector","page":"Methods","title":"NeXLSpectrum.Detector","text":"Detector\n\nAn abstract type defining the characteristics of an X-ray detector.\n\nImplements:\n\nchannelcount(det::Detector)::Int\nscale(det::Detector)::EnergyScale\nresolution(eV::Float64, det::Detector)::Float64 # FWHM at eV\nenergy(ch::Int, det::Detector)::Float64\nchannel(eV::Float64, det::Detector)::Int\nprofile(energy::Float64, xrayE::Float64, det::Detector)\nlld(det::Detector)::Int\nisvisible(sf::SpectrumFeature, det::Detector)\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.EDSDetector","page":"Methods","title":"NeXLSpectrum.EDSDetector","text":"EDSDetector\n\nTypes extending EDSDetector must have member variables\n\nchannelcount::Int # Number of channels\nscale::EnergyScale # Detector calibration funtion\nresolution::Resolution # Detector lineshape function\nlld::Int # low level discriminator\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.resolution","page":"Methods","title":"NeXLSpectrum.resolution","text":"resolution(eV::Float64, res::Resolution)\nresolution(eV::Float64, det::EDSDetector)\n\nThe FWHM at eV for the <:Resolution model.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.Resolution","page":"Methods","title":"NeXLSpectrum.Resolution","text":"Resolution\n\nAn abstract type describing the channel dependence of the resolution of an EDS detector.\n\nImplements:\n\nresolution(eV::Float64, res::Resolution)::Float # Resolution at specified energy\nprofile(energy::Float64, xrayE::Float64, res::Resolution) # Amplitude for a signal at the specified energy at the specified energy\nextent(xrayE::Float64, res::Resolution, ampl::Float64)::Tuple{2,Float} # The range of channels over which the signal exceeds ampl\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.simpleEDSwICC","page":"Methods","title":"NeXLSpectrum.simpleEDSwICC","text":"simpleEDSwICC(chCount::Integer, width::Float64, offset::Float64, fwhmatmnka::Float64, lld::Int=channel(150.0 eV))\n\nConstruct simple model of an EDS detector with incomplete charge collection at low X-ray energies.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.MnKaResolution","page":"Methods","title":"NeXLSpectrum.MnKaResolution","text":"MnKaResolution\n\nUses Chuck Fiori's simple function relating the FWHM at eV to the FWHM at another energy.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.matches","page":"Methods","title":"NeXLSpectrum.matches","text":"matches(spec::Spectrum, det::Detector, tol::Float64 = 1.0)::Bool\nmatches(spec1::Spectrum, spec2::Spectrum, tol::Float64 = 1.0)::Bool\n\nDoes the calibration of the Spectrum (approximately) match the calibration of the Detector or the other Spectrum?\n\n\n\n\n\nmatches(cxrl::CharXRayLabel, std::KRatio)\nmatches(cxrl::CharXRayLabel, std::StandardLabel)\n\nDoes the measured CharXRayLabel match the standard?\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.TabulatedWindow","page":"Methods","title":"NeXLSpectrum.TabulatedWindow","text":"TabulatedWindow(wt::WindowType)\n\nConstruct a model of the window transmission based on vendor-supplied tabulations of transparency. At the end of the user supplied data, the transmission function is extended by matching the ModeledWindow with the tabulation.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.DirectReference","page":"Methods","title":"NeXLSpectrum.DirectReference","text":"A DirectReference represents the data extracted from a reference spectrum necessary to perform a  \"direct\" (background-eliminated direct fit).\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.BerylliumWindow","page":"Methods","title":"NeXLSpectrum.BerylliumWindow","text":"BerylliumWindow(thickness)\n\nCreate a window of pure Be of the specified thickness (in cm)\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.AmptekC2","page":"Methods","title":"NeXLSpectrum.AmptekC2","text":"Create modeled windows for the Ametek C2 Si₃N₄ windows according to the specifications here:     https://www.amptek.com/products/accessories-for-xrf-eds/c-series-low-energy-x-ray-windows#Specifications   \n\nLight transparent window often used for SEM detectors.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.DirectFitResult","page":"Methods","title":"NeXLSpectrum.DirectFitResult","text":"DirectFitResult contains the result of a direct fit of a DirectReferences to an unknown spectrum.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.WindowType","page":"Methods","title":"NeXLSpectrum.WindowType","text":"WindowType is the abstract type for models or types of X-ray windows.  These types distinguish between the window type and the implementation.  Often, there are both tabulated transmission functions from the vendor and calculated transmission functions based on the construction of the window. Use the TabulatedWindow or ModeledWindow to instantiate AbstractWindow which implements the transmission(wnd::AbstractWindow, energy::Float64, angle::Float64 = π / 2) method.\n\nPredefined WindowTypes are MoxtekAP33, MoxtekAP5, AmptekC1, AmptekC2, BerylliumWindow.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.DirectReferences","page":"Methods","title":"NeXLSpectrum.DirectReferences","text":"A DirectReferences is a packet of DirectReference and detector information.  It can be used to fit the corresponding peaks in an \"unknown\" spectrum.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.AbstractWindow","page":"Methods","title":"NeXLSpectrum.AbstractWindow","text":"AbstractWindow is the base type for TabulatedWindow, ModeledWindow and NoWindow. You can view the window transmission function using Gadfly and the method:\n\nplot(wind::Union{AbstractWindow, AbstractArray{<:AbstractWindow}}; xmax=20.0e3, angle=π/2, style=NeXLSpectrumStyle)\n\nWindow types are identified by types based on WindowType like MoxtekAP33, MoxtekAP5, AmptekC1, AmptekC2, BerylliumWindow.\n\nAn implementation of an AbstractWindow is instantiate using code like TabulatedWindow(MoxtekAP33()) or ModeledWindow(AmptekC1()). In addition, there is a NoWindow() type that implements a 100% transparent window.\n\nAbstractWindow types primarily implement NeXLCore.transmission(wnd::AbstractWindow, energy::Float64, angle::Float64 = π / 2)\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.NoWindow","page":"Methods","title":"NeXLSpectrum.NoWindow","text":"NoWindow\n\nA 100% transparent window.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.ModeledWindow","page":"Methods","title":"NeXLSpectrum.ModeledWindow","text":"ModeledWindow(wt::WindowType)\n\nThis type models a window using the materials and thicknesses provided by the vendor. If accomodates grids by a simplistic mechanism of assuming an open area.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.AmptekC1","page":"Methods","title":"NeXLSpectrum.AmptekC1","text":"Create modeled windows for the Ametek C1 Si₃N₄ windows according to the specifications here:     https://www.amptek.com/products/accessories-for-xrf-eds/c-series-low-energy-x-ray-windows#Specifications   \n\nLight-tight (solar-blind) window. Often used for environmental XRF units.\n\n\n\n\n\n","category":"type"},{"location":"methods/#EDS-Detector-Plotting","page":"Methods","title":"EDS Detector Plotting","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Gadfly.plot(deteff::DetectorEfficiency)\nGadfly.plot(deteff::DetectorEfficiency, emax)","category":"page"},{"location":"methods/#Gadfly.plot-Tuple{DetectorEfficiency}","page":"Methods","title":"Gadfly.plot","text":"Gadfly.plot(deteff::Union{DetectorEfficiency,AbstractVector{DetectorEfficiency}}, emax = 20.0e3)\n\nPlots the detector efficiency function assuming the detector is perpendicular to the incident X-rays.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Gadfly.plot-Tuple{DetectorEfficiency, Any}","page":"Methods","title":"Gadfly.plot","text":"Gadfly.plot(deteff::Union{DetectorEfficiency,AbstractVector{DetectorEfficiency}}, emax = 20.0e3)\n\nPlots the detector efficiency function assuming the detector is perpendicular to the incident X-rays.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Energy-Axis-Scales-for-EDS-Detectors","page":"Methods","title":"Energy Axis Scales for EDS Detectors","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Structures and functions that implement the energy scale functions for EDS detectors.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.EnergyScale\nNeXLSpectrum.LinearEnergyScale\nNeXLSpectrum.PolyEnergyScale\nNeXLSpectrum.fwhm\nNeXLSpectrum.gaussianwidth\nNeXLSpectrum.resolution_to_fwhm","category":"page"},{"location":"methods/#NeXLSpectrum.EnergyScale","page":"Methods","title":"NeXLSpectrum.EnergyScale","text":"EnergyScale\n\nAn EnergyScale is a way of representing the energy axis associated with X-ray data. The scale may be linear, polynomial or ??? to handle the various different non-linearities that happen with EDS detectors plus we can also handle WDS wavescans.\n\nImplements:\n\nchannel(::Type{Float64}, eV::AbstractFloat, sc::EnergyScale)::Float64\nenergy(ch::Int, sc::EnergyScale)::Float64\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.LinearEnergyScale","page":"Methods","title":"NeXLSpectrum.LinearEnergyScale","text":"LinearEnergyScale\n\nAn EnergyScale implementation parameterized by channel width and offset.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.PolyEnergyScale","page":"Methods","title":"NeXLSpectrum.PolyEnergyScale","text":"PolyEnergyScale\n\nAn energy scale based on a polynomial function of the channel index.\n\n\n\n\n\n","category":"type"},{"location":"methods/#NeXLSpectrum.fwhm","page":"Methods","title":"NeXLSpectrum.fwhm","text":"fwhm(gauss::Float64)\n\nConverts Gaussian width to full-width half-max.  See also gaussianwidth\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.gaussianwidth","page":"Methods","title":"NeXLSpectrum.gaussianwidth","text":"gaussianwidth(fwhm::Float64)\n\nConverts full-width half-max to Gaussian width.  See also fwhm(...)\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.resolution_to_fwhm","page":"Methods","title":"NeXLSpectrum.resolution_to_fwhm","text":"resolution_to_fwhm(::Type{MnKaResolution}, res::Float64, eV::Float64)\n\nGiven the FWHM at res predict the resolution at Mn Kα.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Multi-Detector-Functions","page":"Methods","title":"Multi-Detector Functions","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Functions for interpreting and manipulating spectr collected on multiple detectors simultaneously.","category":"page"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.multicompare\nNeXLSpectrum.multimean\nNeXLSpectrum.multisum\nNeXLSpectrum.plot_multicompare","category":"page"},{"location":"methods/#NeXLSpectrum.multicompare","page":"Methods","title":"NeXLSpectrum.multicompare","text":"multicompare(specs::AbstractArray{Spectrum{T}}) where {T <: Real}\n\nCompares the intensity for the spectra in specs against the mean intensity on a channel-by-channel basis.  Compute the ratio for each channel in each  spectrum of the spectrum intensity over the mean intensity for that channel. You expect the ratio to be unity when the spectra are identical and deviate from unity when the spectra are different. \n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.multimean","page":"Methods","title":"NeXLSpectrum.multimean","text":"multimean(specs::Spectrum{T})::Spectrum{T} where {T <: Real}\n\nAverage on a channel-by-channel basis spectra collected from multiple detectors simultaneously from the same electrons interacting with the same material for  the real-time.  The detectors should be calibrated close to identically to maintain the detector resolution and peak positions.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.multisum","page":"Methods","title":"NeXLSpectrum.multisum","text":"multisum(specs::Spectrum{T})::Spectrum{T} where {T <: Real}\n\nSum together spectra collected from multiple detectors simultaneously from the same electrons interacting with the same material for the real-time.   The detectors should be calibrated close to identically to maintain the detector resolution and peak positions.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.plot_multicompare","page":"Methods","title":"NeXLSpectrum.plot_multicompare","text":"plot_multicompare(specs::AbstractArray{Spectrum{T}}; minE=200.0, maxE=0.5*specs[1][:BeamEnergy]) where { T<: Real}\n\nCompare spectra collected simultaneously on multiple detectors in a single acquisition.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Bremsstrahlung","page":"Methods","title":"Bremsstrahlung","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.continuumrois\nNeXLSpectrum.generated\nNeXLSpectrum.emitted\nNeXLSpectrum.fitcontinuum\nNeXLSpectrum.detectorresponse\nNeXLCore.weight\nNeXLSpectrum.extents\nNeXLSpectrum.profile\nNeXLSpectrum.subtractcontinuum\nNeXLSpectrum.heterogeneity","category":"page"},{"location":"methods/#NeXLSpectrum.continuumrois","page":"Methods","title":"NeXLSpectrum.continuumrois","text":"continuumrois(elems, det::EDSDetector, minE::Float64, maxE::Float64)\n\nCompute the ROIs for the contiguous continuum regions for the specified elements elems on an EDSDetector for the specified range of energies.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.generated","page":"Methods","title":"NeXLSpectrum.generated","text":"generated(cm::ContinuumModel, ea::Float64)\n\nCompute the intensity of the measured continuum generated from the material and conditions specified in the continuum model object at the specified measured energy ea.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.emitted","page":"Methods","title":"NeXLSpectrum.emitted","text":"emitted(cm::ContinuumModel, ea::Float64)\n\nCompute the intensity of the measured continuum emitted from the material and conditions specified in the continuum model object at the specified measured energy ea.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.fitcontinuum","page":"Methods","title":"NeXLSpectrum.fitcontinuum","text":"fitcontinuum(\n  spec::Spectrum,\n  resp::AbstractArray,\n  rois::Vector{UnitRange};\n  brem::Type{<:NeXLBremsstrahlung} = Castellano2004a,\n  mc::Type{<:MatricCorrection} = Riveros1993,\n)\n\nFit a continuum model to the specified range of channels (`rois`).  The `resp` argument is a matrix which describes\n\nthe detector response on a channel-by-channel basis.  It can be calculated from an EDSDetector and an DetectorEfficiency using resp = NeXLSpectrum.detectorresponse(det, eff).  The Spectrum object must have the :Composition, :BeamEnergy and :TakeOffAngle properties defined.\n\n\n\n\n\nfitcontinuum(\n  spec::Spectrum,\n  det::EDSDetector,\n  resp::AbstractArray{<:Real,2}; #\n  minE::Float64 = 1.5e3,\n  maxE::Float64 = 0.95 * spec[:BeamEnergy],\n  brem::Type{<:NeXLBremsstrahlung} = Castellano2004a,\n  mc::Type{<:MatrixCorrection} = Riveros1993,\n)\n\nFit the continuum from ROIs determined from the data within the spectrum (:Composition, :BeamEnergy & :TakeOffAngle). The ROIs are computed using continuumrois(...) and each roi is fit seperately.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.detectorresponse","page":"Methods","title":"NeXLSpectrum.detectorresponse","text":"detectorresponse(det::EDSDetector, eff::DetectorEfficiency, incidence::Float64=π/2)::AbstractMatrix\n\nBuild a matrix which models the detector response including aspects like the detector efficiency, the resolution, the escape peaks.  All the warts that can be modeled within a linear model but not things like coincidence peaks that are non-linear.  This function can (!should!) be specialized for more sophisticated detector models that include more warts.\n\nIt also dicretizes the input energies on the same scale as the EDSDetector (thus it is square.)  This is reasonable when the detector channel width is much less than the resolution.\n\nExample:\n\ngenint = computegeneratedintensity(....) # Either characteristic or Bremsstrahlung...\ndet = simpleEDS(4096, 5.0, 0.0, 132.0, 10)\neff = SDDEfficiency(AP33Tabulation(); thickness=0.0370, deadlayer=30.0e-7, entrance=Film(pure(n\"Al\"), 10.0e-7))\nresp = detectorresponse(det, eff)\n# finally compute the measured signal\nmeasured = resp*genint\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLCore.weight","page":"Methods","title":"NeXLCore.weight","text":"weight(esc::EscapeArtifact, factor=0.01)\n\nThe weight of an EscapeArtifact which is factor * weight(esc.xray).\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.extents","page":"Methods","title":"NeXLSpectrum.extents","text":"extents(cxrs::AbstractVector{<:SpectrumFeature},det::Detector,ampl::Float64)::Vector{UnitRange{Int}}\n\nDetermine the contiguous ranges of channels over which the specified collection of X-rays will be measured on the specified detector.  The ampl determines the extent of each peak.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.profile","page":"Methods","title":"NeXLSpectrum.profile","text":"profile(energy::Float64, xrayE::Float64, res::Resolution)\n\nCalculates a Gaussian profile for an X-ray of xrayE (eV) for a detector with the specified resolution.  Maintains normalization to a sum of unity.\n\n\n\n\n\nprofile(ch::Int, xrayE::Float64, det::EDSDetector)\n\nCalculates the profile for an X-ray of xrayE (eV) for a detector with the specified resolution.  Performs a crude integration to account for the channel width.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.subtractcontinuum","page":"Methods","title":"NeXLSpectrum.subtractcontinuum","text":"subtractcontinuum(\n  spec::Spectrum,\n  det::EDSDetector,\n  resp::AbstractArray{<:Real,2}; #\n  minE::Float64 = 1.5e3,\n  maxE::Float64 = 0.95 * spec[:BeamEnergy],\n  brem::Type{<:NeXLBremsstrahlung} = Castellano2004a,\n  mc::Type{<:MatrixCorrection} = Riveros1993,\n)::Spectrum\n\nComputes the characteristic-only spectrum by subtracting the continuum.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.heterogeneity","page":"Methods","title":"NeXLSpectrum.heterogeneity","text":"heterogeneity(ffrs::Vector{FilterFitResult}, lbl::ReferenceLabel)\n\nComputes the ratio of the standard deviation of the measured values over the mean calculated uncertainty from the fit.  A value near 1 means the sample appears homogeneous and a value greater than 1 means the sample appears heterogeneous.\n\n\n\n\n\n","category":"function"},{"location":"methods/#Utility","page":"Methods","title":"Utility","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"NeXLSpectrum.drawline\nNeXLSpectrum.shannon_entropy(::AbstractArray{ColorTypes.Gray{FixedPointNumbers.N0f8}})\nNeXLSpectrum.readSEManticsImage\nNeXLCore.requiredbutmissing\nNeXLCore.hasminrequired\nNeXLSpectrum.annotate\nNeXLSpectrum.simulate","category":"page"},{"location":"methods/#NeXLSpectrum.drawline","page":"Methods","title":"NeXLSpectrum.drawline","text":"drawline(func::Function, ci1::CartesianIndex{2}, ci2::CartesianIndex{2}, eachstep::Bool=false)\n\nAt each step along the line from ci1 to ci2 call func with a single argument, the row, column coordinates of the pixel as a Tuple{Int, Int}.\n\nIf eachstep=true then func is called once when the row changes and once when the column changes.  When eachstep=false then func is called less frequently and both row and col may change between calls.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.shannon_entropy-Tuple{AbstractArray{Gray{FixedPointNumbers.N0f8}}}","page":"Methods","title":"NeXLSpectrum.shannon_entropy","text":"shannon_entropy(img::AbstractArray{Gray{N0f8}})\n\nComputes the log2-entropy of the data in the image. The entropy(...) in Images.jl 24.1 is buggy and is removed in 25.0\n\n\n\n\n\n","category":"method"},{"location":"methods/#NeXLSpectrum.readSEManticsImage","page":"Methods","title":"NeXLSpectrum.readSEManticsImage","text":"readSEManticsImage(fn::AbstractString)\n\nRead a SEMantics PNG image and the create an ImageAxes (AxisArray) which associates :x, :y coordinates with the image axes according to the X, Y and FOV in the images.txt file in the same directory.\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLCore.requiredbutmissing","page":"Methods","title":"NeXLCore.requiredbutmissing","text":"NeXLCore.requiredbutmissing(ty::Type, spec::Spectrum)\n\nWhich properties are missing from spec but are required for the algorithm ty?\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLCore.hasminrequired","page":"Methods","title":"NeXLCore.hasminrequired","text":"NeXLCore.hasminrequired(ty::Type, spec::Spectrum)\n\nDoes spec have the necessary property items for the algorithm ty?\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.annotate","page":"Methods","title":"NeXLSpectrum.annotate","text":"annotate(\n    img::AxisArray; \n    scale::Bool = true,\n    coords::Union{Nothing, AbstractArray{<:AbstractDict{Symbol, <:AbstractFloat}}} = nothing,\n    spectra::Union{Nothing, <:AbstractArray{<:Spectrum}} = nothing,\n    thumbnails::Union{Nothing, AbstractArray{<:AxisArray}}=nothing,\n    labelcoords::Bool = true,\n    labelthumbnails::Bool = true,\n    marker::Colorant = HSVA(60, 1, 1, 0.3) \n)\n\nAdd annotations like scale-bars, acquisition points, image areas to an image and display the result.\n\ncoords and spectra display as circles (with/without numeric labels).\nthumbnails display as rectangles overlaying the image\nscale displays as a scale-bar in the upper-right corner\nmarker is the color of the annotations which is by-default slightly transparent\n\n\n\n\n\n","category":"function"},{"location":"methods/#NeXLSpectrum.simulate","page":"Methods","title":"NeXLSpectrum.simulate","text":"\"   simulate(comp::Material, dose::Float64, e0::Float64, θtoa::Float64, Ω::Float64, det::Detector, resp::Matrix{Float64}; noise=false, vargs...)\n\nCompute a simulated X-ray spectrum for the specified composition material.\n\nArguments:\n\ncomp: The Material\ndose: The electron dose in nA⋅s \ne0:   The beam energy in eV\nθtoa: The take-off angle in radians\nΩ:    The detector solid angle in steradians\ndet:  The detector model\nresp: The detector response\n\nReturns a Spectrum struct.\n\n\n\n\n\nsimulate(\n    comp::Material, \n    dose::Float64, \n    e0::Float64, \n    θtoa::Float64, \n    Ω::Float64, \n    det::Detector, \n    resp::Matrix{Float64}; \n    noise=false, \n    vargs...\n)\n\nCompute a simulated X-ray spectrum for the specified composition material.\n\nArguments:\n\ncomp: The Material\ndose: The electron dose in nA⋅s \ne0:   The beam energy in eV\nθtoa: The take-off angle in radians\nΩ:    The detector solid angle in steradians\ndet:  The detector model\nresp: The detector response\n\nReturns a Spectrum struct.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#![](NeXL_sm.png)Spectrum","page":"Spectrum Methods","title":"(Image: )Spectrum","text":"","category":"section"},{"location":"spectrum/#spectrum_methods","page":"Spectrum Methods","title":"Working with Spectrum objects","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"CurrentModule = NeXLSpectrum","category":"page"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"The Spectrum type represents a single spectrum with associated properties. The channel data is indexed like a Vector.  The property data is indexed using Symbol objects.  A set of spectrum properties are defined in the library and the user can create additional ones.","category":"page"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"In addition to the Vector-like properties, the Spectrum associates energy bins with each channel.  The energy bins are continuous, non-overlapping and monotonic.  Functions like energy(...) maps channel index to energies and channel(...) to make energies to channel index.  ","category":"page"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"Spectrum","category":"page"},{"location":"spectrum/#NeXLSpectrum.Spectrum","page":"Spectrum Methods","title":"NeXLSpectrum.Spectrum","text":"Spectrum{T<:Real} <: AbstractVector{T}\n\nSpectrum(energy::EnergyScale, data::Vector{<:Real}, props::Dict{Symbol,Any})\n\nConstruct a structure to hold spectrum data (energy scale, counts and metadata).\n\nSee NeXLSpectrum.EnergyScale or NeXLSpectrum.LinearEnergyScale\n\nExample:\n\njulia> spec = Spectrum(LinearEnergyScale(0.0,10.0),\n                 collect(1:1024),\n                 Dict{Symbol,Any}(:BeamEnergy=>10.0e3, :LiveTime=>30.0))\n                                                                              ** 1024.0\n                                                                       *********\n                                                               *****************\n                                                        ************************\n                                                 *******************************\n                                          **************************************\n                                   *********************************************\n                            ****************************************************\n                     ***********************************************************\n              ******************************************************************\n       *************************************************************************\n******************************************************************************** 10.0 keV\nSpectrum[3062][10.0 keV, Unknown, 525000.0 counts]\n\nSpectra are usually loaded from disk using:\n\ns1 = loadspectrum(joinpath(path,\"ADM-6005a_1.msa\")) # Auto-detects the file type (supports ISO/EMSA, Bruker, ASPEX, ??? files)\n  *                                                                                                  128860.0\n  *\n  *\n  *\n  *\n  *\n  *     *\n  *     *\n  *     *\n  * ** **\n  * ** *****        **  **\n**************************************************************************************************** 20.0 keV\nSpectrum{Float64}[ADM-6005a_1, -484.20818 + 5.01716⋅ch eV, 4096 ch, 20.0 keV, Unknown, 6.81e6 counts]\n\nSpectrum implements indexing using various different mechanisms.  If spec is a Spectrum then\n\nspec[123] # will return the number of counts in channel 123\nspec[123:222] # will return a Vector of counts from channel 123:222\nspec[134.] # will return the number of counts in the channel at energy 134.0 eV\nspec[134.0:270.0] # will return a Vector of counts for channels with energies between 134.0 eV and 270.0 eV\nspec[n\"Ca L3-M5\"] # Counts in the channel at the Ca L3-M5 characteristic X-ray energy\nspec[:Comment] # will return the meta-data item named :Comment\n\nBasic spectrum math is supported using the operators *, /, ÷, +, and -.  If s1, s2 and s3 are Spectrum objects then:\n\n2*s1 # A Spectrum containing twice as many counts in each channel\n2.0*s1 # A Spectrum containing twice as many counts in each channel\ns1/2.0 # A spectrum containing half as many counts in each channel\ns1÷2 # A spectrum containing half as many counts in each channel (Only works for Spectrum{<:Integer})\ns1 + s2 # A Spectrum containing channel-by-channel sum of counts in s1 and s1 and common properties.\ns1 - s2 # The channel-by-channel difference\n\nSpectrum metadata is identified by a Symbol. These Symbols are used within NeXLSpectrum. You can create others  to associate other data items with a Spectrum.\n\n:BeamEnergy    # In eV\n:Elevation     # In radians\n:TakeOffAngle  # In radians (Detector position)\n:Azimuthal     # In radians (Detector position)\n:WorkingDistance # In cm (not mm!!!!)\n:LiveTime      # In seconds\n:RealTime      # In seconds\n:DeadFraction  # Fractional\n:ProbeCurrent  # In nano-amps\n:Name          # A `String`\n:Owner         # A `String`\n:Sample        # Description of the sample\n:StagePosition # A Dict{Symbol,Real} with entries :X, :Y, :Z, :R, :T, B: in cm and degrees\n:Comment       # A `String`\n:Composition   # A `Material` (known composition, not measured)\n:Elements      # A collection of elements in the material like `[ n\"Fe\", n\"Ca\", n\"Si\" ]`\n:Detector      # A Detector like a BasicEDS or another EDSDetector\n:Filename      # Source filename\n:Coating       # A `Film` or `Film[]` (eg. 10 nm of C|Au etc.)\n:AcquisitionTime # Date and time of acquisition (`DateTime` struct)\n:Signature     # Dict{Element,Real} with the \"particle signature\"\n:SolidAngle    # Detector solid angle is steradians (area/dist²)\n\nSpectrum Image items:\n\n:ImageRotation # Rotation of the primary scan direction from the :X axis towards the :Y axis in radians\n\nLess common items:\n\n:ImageMag\t   # Magnification (assuming a 3.5\" image) of the first image\n:ImageZoom     # Additional zoom for second image in a two image TIFF\n:Operator      # Analyst in ASPEX TIFF files\n:Image1, :Image2 ... # Images associated with the spectrum\n:BrukerThroughtput # Nominal throughtput setting on a Bruker detector\n:DetectorSerialNumber # EDS detector serial number\n:DetectorModel # Vendor model name\n:DetectorThickness # Thickness of detector active area\n:DeadLayerThickness # Thickness of Si dead layer on the entrance surface of the detector\n:Window        # Window construction details\n:DetectorSolidAngle # Collection solid angle of the X-ray detector\n:ChamberPressure # Vacuum presure in the sample chamber\n:ChamberAtmosphere # Nominally the composition of the residual gas in the chamber\n\nXRF related items:\n\n:BeamEnergy  # Accelarating voltage within X-ray tube (eV)\n:XRFTubeAnode    # Element from which the X-ray tube is constructed\n:ProbeCurrent  # Electron current in the X-ray tube\n:XRFTubeIncidentAngle # Incident angle of electron beam in tube\n:XRFTubeTakeOffAngle # Take-off angle from tube\n:XRFExcitationAngle # Angle of incidence of the X-ray beam on the sample\n:XRFDetectionAngle # Angle of the detector relative to the sample\n:XRFExcitationPathLength # Distance from X-ray source to sample\n:XRFDetectionPathLength # Distance from the sample to the X-ray detector\n:XRFSampleTilt    #  Additional tilt of the sample\n:XRFTubeWindow   # Construction of the tube window\n\nNot all spectra will define all properties.  Algorithms can define the NeXLCore.minproperties(ty::Type) method to specify which properties are required by an algorithm of ty::Type.  Then hasminrequired and requiredbutmissing methods will determine whether a Spectrum or Dict{Symbol,Any} is suitable for an algorithm.\n\n\n\n\n\n","category":"type"},{"location":"spectrum/#Acccessing-Properties","page":"Spectrum Methods","title":"Acccessing Properties","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"Most properties are accessed using spec[:Symbol] notation.  Some combined or special properties have special methods.","category":"page"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"dose\nelms(::Spectrum)","category":"page"},{"location":"spectrum/#NeXLSpectrum.dose","page":"Spectrum Methods","title":"NeXLSpectrum.dose","text":"dose(spec::Spectrum, def=missing)\ndose(props::Dict{Symbol, Any}, def=missing)\n\nThe probe dose in nA⋅s and is equals spec[:LiveTime]⋅spec[:ProbeCurrent].\n\n\n\n\n\ndose(hss::HyperSpectrum) # Average dose per pixel\ndose(hss::HyperSpectrum, idx...) # Dose for the `idx` pixel\n\nReturns the product of the probe current and the live-time on a per pixel basis.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLCore.elms-Tuple{Spectrum}","page":"Spectrum Methods","title":"NeXLCore.elms","text":"elms(spec::Spectrum, withcoating = false)::Set{Element}\n\nReturns a set of the elements associated with this spectrum. withcoating determines whether the coating elements are also added.\n\n\n\n\n\n","category":"method"},{"location":"spectrum/#Displaying-Spectrum-Data","page":"Spectrum Methods","title":"Displaying Spectrum Data","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"asa\nBase.keys\nBase.haskey\nGadfly.plot","category":"page"},{"location":"spectrum/#NeXLUncertainties.asa","page":"Spectrum Methods","title":"NeXLUncertainties.asa","text":"NeXLUncertainties.asa(::Type{DataFrame}, spec::Spectrum; properties::Bool = false)\n\nConverts the spectrum energy and counts data into a DataFrame.\n\n\n\n\n\nNeXLUncertainties.asa(::Type{DataFrame}, spec::AbstractArray{Spectrum})::DataFrame\n\nReturns a DataFrame that summarizes the list of spectra.\n\n\n\n\n\nNeXLUncertainties.asa(::Type{DataFrame}, spec::AbstractDict{Element, Spectrum})::DataFrame\n\nReturns a DataFrame that summarizes a dictionary of standard spectra.\n\n\n\n\n\nNeXLUncertainties.asa(::Type{DataFrame}, ffrs::AbstractVector{<:FitResult}; charOnly = true, withUnc = false, format = :normal # :pivot or :long)\n\nReturn generic FitResult as a DataFrame.\n\nFormat:\n\n:normal - One row per spectrum, one column per k-ratio\n:pivot - One row per ROI, one column per spectrum (optional: column for 1σ uncertainty on k-ratio)\n:long - One row per spectrum, feature, measured k-ratio\n\n\n\n\n\nNeXLUncertainties.asa(::Type{DataFrame}, fr::FitResult; withUnc = false)\n\nSummarize the ROI and k-ratio data within a FitResult structure as a DataFrame. \n\n\n\n\n\nNeXLUncertainties.asa(\n    ::Type{DataFrame}, \n    ffr::FilterFitResult; \n    charOnly::Bool=true, \n    material=nothing,\n    mc = XPP, fc=ReedFluorescence,\n    columns = ( :counts, ) # Selected from ( :roi, :peakback, :counts, :dose )\n)::DataFrame\n\nTabulate details about each region-of-interest in the 'FilterFitResult' in a 'DataFrame'.\n\nIf charOnly then only display characteristic X-ray data (not escapes etc.)\nIf material is a Material then the computed k-ratio (KCalc) will also be tabulated along with kmeas/kcalc (KoKCalc).\ncolumns - Select optional column outputs (see below)\n\nColumns:\n\nSpectrum : UnknownLabel - Identifies the fit spectrum\nFeature  : Label - Identifies the fit feature (Vector{CharXRay} or other)\nReference: String - Name of reference against which :Spectrum was fit over :Feature\nK : Float64 - The multiplicative fit constant\ndK : Float64 - The 1σ uncertainty in :K\n:Start : Int - Start index for fit channels (:roi ∈ columns)\n:Stop : Int - Stop index for fit channels  (:roi ∈ columns)\n:Counts : Float64 - Total counts in characteristic peak (peak-back) (:peakback || :counts ∈ columns)\n:Back : Float64 - Total counts in background under the characteristic peak (:peakback ∈ columns)\n:PtoB : Float64 - Peak-to-Background assuming 10 eV/channel (:peakback ∈ columns)\n:KCalc : Float64 - Computed k-ratio assuming a composition. (Requires material argument to be specified.)\n:KoKcalc : Float64 - Ratio of measured/computed k-ratio.  (Requires material argument to be specified.)\n:LiveTime : Float64 - Acquisiton live time (s) (:dose ∈ columns)\n:ProbeCurrent : Float64 - Probe current (nA) (:dose ∈ columns)\n:DeadPct : Float64 - Dead time in ProbeCurrent (:dose ∈ columns)\n:RefCountsPernAs : Float64 - Estimated counts in :Reference in :Feature per unit dose.  (:counts ∈ columns)\n:CountsPernAs : Float64 - Estimated counts in :Spectrum in :Feature per unit dose.  (:counts ∈ columns)\n\n\n\n\n\nNeXLUncertainties.asa(::Type{DataFrame}, ffp::FilterFitPacket)\n\nSummarize the FilteredReference structs within a FilterFitPacket as a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#Base.keys","page":"Spectrum Methods","title":"Base.keys","text":"Base.keys(spec::Spectrum)\n\nReturn the defined properties as a set of Symbols.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#Base.haskey","page":"Spectrum Methods","title":"Base.haskey","text":"Base.haskey(spec::Spectrum, sym::Symbol)\n\nIs the specified key defined?\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#Gadfly.plot","page":"Spectrum Methods","title":"Gadfly.plot","text":"plot(\n    specs::Union{Spectrum...,AbstractVector{Spectrum{<:Real}}};\n    klms=[],\n    edges=[],\n\tescapes=[],\n\tcoincidences=[],\n    autoklms = false,\n    xmin=0.0,\n    xmax=missing,\n    norm=:None,\n    yscale=1.05,\n    ytransform = identity,\n\tstyle=NeXLSpectrumStyle,\n\tpalette=NeXLPalette\n)::Plot\n\nRequired:\n\nspecs::AbstractVector{Spectrum};\n\nNamed:\n\nklms = Union{Element, CharXRay}[ ]\nedges = Union{Element, AtomicSubShell}[ ]\nescapes = Union{Element, CharXRay}[ ],\ncoincidences = CharXRay[ ],\nautoklms = false # Add KLMs based on elements in spectra\nxmin = 0.0 # Min energy (eV)\nxmax = missing # Max energy (eV) (defaults to max(:BeamEnergy))\nnorm = NoScaling() | ScaleDoseWidth() | ScaleDose() | ScaleSum() | ScaleROISum() | ScalePeak() | (<: SpectrumScaling)()\nyscale = 1.05 # Fraction of max intensity for ymax over [max(lld,xmin):xmax]\nytransform = identity | log10 | sqrt | ??? # How to transform the counts data before plotting\nstyle=NeXLSpectrumStyle (or another Gadfly.style)\npalette = NeXLPalette | Colorant[ ... ] # Colors for spectra...\ncustomlayers = Gadfly.Layer[] # Allows additional plot layers to be added\n\nPlot a multiple spectra on a single plot using Gadfly.\n\n\n\n\n\nGadfly.plot(\n    ffr::FilterFitResult,\n    roi::Union{Nothing,AbstractUnitRange{<:Integer}} = nothing;\n    palette = NeXLPalette,\n    style = NeXLSpectrumStyle,\n    xmax::Union{AbstractFloat, Nothing} = nothing,\n    comp::Union{Material, Nothing} = nothing,\n    det::Union{EDSDetector, Nothing} = nothing,\n    resp::Union{AbstractArray{<:AbstractFloat,2},Nothing} = nothing,\n    yscale = 1.0\n)\n\nPlot the sample spectrum, the residual and fit regions-of-interests and the associated k-ratios.\n\n\n\n\n\nGadfly.plot(fr::FilteredReference; palette = NeXLPalette))\n\nPlot a filtered reference spectrum.\n\n\n\n\n\nplot(ff::TopHatFilter, fr::FilteredReference)\n\nPlot a color map showing the filter data relevant to filtering the specified FilteredReference.\n\n\n\n\n\nGadfly.plot(vq::VectorQuant, chs::UnitRange)\n\nPlots the \"vectors\" used to quantify various elements/regions-of-interest over the range of channels specified.\n\n\n\n\n\nGadfly.plot(deteff::Union{DetectorEfficiency,AbstractVector{DetectorEfficiency}}, emax = 20.0e3)\n\nPlots the detector efficiency function assuming the detector is perpendicular to the incident X-rays.\n\n\n\n\n\nGadfly.plot(ffp::FilterFitPacket; kwargs...)\n\nPlots the reference spectra which were used to construct a FilterFitPacket.\n\n\n\n\n\nplot(wind::Union{AbstractWindow, AbstractArray{<:AbstractWindow}}; xmax=20.0e3, angle=π/2, style=NeXLSpectrumStyle)\n\nPlot the window transmission function.\n\n\n\n\n\nGadfly.plot(\n    dfr::DirectFitResult,\n    roi::Union{Nothing,AbstractUnitRange{<:Integer}} = nothing;\n    palette = NeXLPalette,\n    style = NeXLSpectrumStyle,\n    xmax::Union{AbstractFloat, Nothing} = nothing,\n    comp::Union{Material, Nothing} = nothing,\n    det::Union{EDSDetector, Nothing} = nothing,\n    resp::Union{AbstractArray{<:AbstractFloat,2},Nothing} = nothing,\n    yscale = 1.0\n)\n\nPlot the sample spectrum, the residual and fit regions-of-interests and the associated k-ratios.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#Energy-Scale-Functions","page":"Spectrum Methods","title":"Energy Scale Functions","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"These functions handle mapping channel index to energies and vice versa.","category":"page"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"NeXLCore.energy\nchannel\nrangeofenergies\nchannelwidth\nenergyscale","category":"page"},{"location":"spectrum/#NeXLCore.energy","page":"Spectrum Methods","title":"NeXLCore.energy","text":"NeXLCore.energy(ch::Integer, sc::EnergyScale)\nNeXLCore.energy(ch::Int, spec::Spectrum)\nNeXLCore.energy(ch::Int, det::EDSDetector)\n\nReturns the energy (in eV) for the low energy side of the bin representing the ch-th channel.\n\nExample:\n\nles = LinearEnergyScale(3.0, 10.1)\nenergy(101,lsc) == 10.1*101 + 3.0\nenergy(101,lsc) - energy(100,lsc) == 10.1\npes = PolyEnergyScale([ 3.0, 10.1, 0.001])\nenergy(101,pes) ==  3.0 + 10.0*101 + 0.001*101^2\n\n\n\n\n\nNeXLCore.energy(ch::Int, spec::Spectrum)::Float64\n\nWhat energy is associated with ch in spec?\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.channel","page":"Spectrum Methods","title":"NeXLSpectrum.channel","text":"channel(::Type{Float64}, eV::AbstractFloat, sc::EnergyScale)::Float64\n\nReturns the fractional-channel index of the specified energy X-ray (in eV).\n\nchannel(eV::AbstractFloat, sc::EnergyScale)::Int\nchannel(eV::Float64, spec::Spectrum)::Int\nchannel(eV::Float64, det::EDSDetector)::Int\n\nReturns the integer index of the channel for the specified energy X-ray (in eV).\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.rangeofenergies","page":"Spectrum Methods","title":"NeXLSpectrum.rangeofenergies","text":"rangeofenergies(ch::Integer, spec::Spectrum)\n\nReturns the low and high energy extremes for the channels ch.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.channelwidth","page":"Spectrum Methods","title":"NeXLSpectrum.channelwidth","text":"channelwidth(ch::Int, spec::Spectrum)::Float64\nchannelwidth(ch::Int, spec::HyperSpectrum)::Float64\n\nReturns the width of the ch channel in eV.\n\nchannelwidth(spec::Spectrum)::Float64\n\nReturns the mean channel width.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.energyscale","page":"Spectrum Methods","title":"NeXLSpectrum.energyscale","text":"energyscale(es::EnergyScale, channels)\nenergyscale(det::EDSDetector)\n\nComputes the energy associated with a range of channel indexes and returns it as an Array.\n\n\n\n\n\nenergyscale(spec::Spectrum)\nenergyscale(spec::Spectrum, chs::AbstractRange{<:Integer})\n\nReturns an array with the bin-by-bin energies\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#Extracting-the-Counts-Data","page":"Spectrum Methods","title":"Extracting the Counts Data","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"The channel data in a Spectrum object spec can be get/set using standard Array indexing techniques.","category":"page"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"> spec[123]\n> spec[123:345]\n> spec[1234.0] # Channel containing energy 1234.0 eV\n> spec[123] = 99","category":"page"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"Alternatively, the counts(...) method can be used.","category":"page"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"counts","category":"page"},{"location":"spectrum/#NeXLSpectrum.counts","page":"Spectrum Methods","title":"NeXLSpectrum.counts","text":"counts(spec::Spectrum, ::Type{T}, applyLLD=false)::Vector{T} where {T<:Number}\ncounts(spec::Spectrum, channels::AbstractUnitRange{<:Integer}, ::Type{T}, applyLLD=false)::Vector{T} where {T<:Number}\n\nCreates a copy of the spectrum counts data as the specified Number type. If the spectrum has a :Detector property then the detector's lld (low-level discriminator) and applyLLD=true then the lld is applied to the result by setting all channels less-than-or-equal to det.lld to zero. This method throws an error if the counts data cannot be converted without loss to the type T.\n\n\n\n\n\ncounts(hss::HyperSpectrum{T, N, NP})::Array{T,NP}\n\nCreates type-friendly view of the counts data array.  Use of this function helps to avoid performance penalties associated with boxing/unboxing the counts data.\n\ncounts(hss::HyperSpectrum{T, N, NP}, ci::CartesianIndex)::Vector{T}\n\nAccess the counts data associated with the pixel ci.\n\ncounts(hss::HyperSpectrum{T, N, NP}, ci::CartesianIndex, ch::Int)::T\n\nAccess the counts data at the pixel represented by ci and the channel represented by ch.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"counts(...) can apply the :LLD property to zero counts below a specified channel.","category":"page"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"lld","category":"page"},{"location":"spectrum/#NeXLSpectrum.lld","page":"Spectrum Methods","title":"NeXLSpectrum.lld","text":"lld(det::EDSDetector)\n\nLow level detection limit in channels.  Channels at or below this value will be zeroed when the lld is applied.\n\n\n\n\n\nlld(spec::Spectrum)\n\nGets the low-level discriminator associated with this spectrum if there is one.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#Defining-Detectors","page":"Spectrum Methods","title":"Defining Detectors","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"Build a detector to match the data in a Spectrum.","category":"page"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"simpleEDS\nmatching","category":"page"},{"location":"spectrum/#NeXLSpectrum.simpleEDS","page":"Spectrum Methods","title":"NeXLSpectrum.simpleEDS","text":"simpleEDS(chCount::Integer, width::Float64, offset::Float64, fwhmatmnka::Float64, lld::Int = channel(150.0 eV))\n\nConstruct simple model of an EDS detector.\n\n\n\n\n\nsimpleEDS(spec::Spectrum, fwhmatmnka::Float64)\n\nBuild a EDSDetector object for this spectrum with the specified FWHM at Mn Kα.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.matching","page":"Spectrum Methods","title":"NeXLSpectrum.matching","text":"matching(spec::Spectrum, resMnKa::Float64, lld::Int=1, minByFam::Dict{Shell,Element} = Dict())::BasicEDS\n\nBuild an EDSDetector to match the channel count and energy scale in this spectrum.\n\n\n\n\n\nmatching(spec::HyperSpectrum, resMnKa::Float64, lld::Int=1)::BasicEDS\n\nBuild an EDSDetector to match the channel count and energy scale in this spectrum.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#Statistical-Sub-Sampling","page":"Spectrum Methods","title":"Statistical Sub-Sampling","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"NeXLSpectrum.subdivide\nNeXLSpectrum.subsample\n","category":"page"},{"location":"spectrum/#NeXLSpectrum.subdivide","page":"Spectrum Methods","title":"NeXLSpectrum.subdivide","text":"subdivide(spec::Spectrum, n::Int)::Vector{Spectrum}\n\nSplits the event data in one spectrum into n spectra by assigning each event to a pseudo-random choice of one of the n result spectra.  Produces n spectra that act as though the original spectrum was collected in n time intervals of LiveTime/n.  This is quite slow because it needs to call rand() for each count in the spectrum (not just each channel).\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.subsample","page":"Spectrum Methods","title":"NeXLSpectrum.subsample","text":"subsample(spec::Spectrum, frac::Float64)\n\nSubsample the counts data in a spectrum according to a statistically valid algorithm.  Returns spec if frac>=1.0.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#Processing-Channel-Data","page":"Spectrum Methods","title":"Processing Channel Data","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"kratio\nintegrate\nestimatebackground\nmodelBackground\nextractcharacteristic\npeak\nbackground\npeaktobackground\nestkratio","category":"page"},{"location":"spectrum/#NeXLSpectrum.kratio","page":"Spectrum Methods","title":"NeXLSpectrum.kratio","text":"kratio(unk::Spectrum, std::Spectrum, back1::AbstractUnitRange{<:Integer}, peak::AbstractUnitRange{<:Integer}, back2::AbstractUnitRange{<:Integer})::UncertainValue\nkratio(unk::Spectrum, std::Spectrum, back1::StepRangeLen{Float64}, peak::StepRangeLen{Float64}, back2::StepRangeLen{Float64})::UncertainValue\n\nThe k-ratio of unk relative to std corrected for dose.  Requires that unk and std have the properties :LiveTime and :ProbeCurrent defined.\n\n\n\n\n\nkratio(ffr::FitResult, cxr::CharXRay)::KRatio\n\nExtract the k-ratio associated with the specified CharXRay (zero if not measured)\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.integrate","page":"Spectrum Methods","title":"NeXLSpectrum.integrate","text":"integrate(spec::Spectrum, channels::AbstractUnitRange{<:Integer})\nintegrate(spec::Spectrum, energyRange::StepRangeLen{Float64})\n\nSums all the counts in the specified channels.  No background correction.  The energyRange version includes the fractional contributions from partial channels when the energies don't perfectly map to channels.\n\nintegrate(spec::Spectrum, back1::AbstractUnitRange{<:Integer}, peak::AbstractUnitRange{<:Integer}, back2::AbstractUnitRange{<:Integer})::UncertainValue\nintegrate(spec::Spectrum, back1::StepRangeLen{Float64}, peak::StepRangeLen{Float64}, back2::StepRangeLen{Float64})::UncertainValue\n\nSums all the counts in the specified channels with background correction using the background intervals.\n\nintegrate(spec::Spectrum)\n\nTotal integral of all counts from the LLD to the beam energy\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.estimatebackground","page":"Spectrum Methods","title":"NeXLSpectrum.estimatebackground","text":"estimatebackground(data::AbstractArray{Float64}, channel::Int, width::Int=5, order::Int=2)\n\nReturns the tangent to the a quadratic fit to the counts data centered at channel with width\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.modelBackground","page":"Spectrum Methods","title":"NeXLSpectrum.modelBackground","text":"modelBackground(spec::Spectrum, chs::AbstractUnitRange{<:Integer}, ash::AtomicSubShell)\n\nspec: A spectrum containing a peak centered on chs chs:  A range of channels containing a peak ash:  The edge (as an AtomicSubShell)\n\nA simple model for modeling the background under a characteristic x-ray peak. The model fits a line to low and high energy background regions around firsr(chs) and last(chs). If the low energy line extended out to the edge energy is larger than the high energy line at the same energy, then a negative going edge is fit between the two. Otherwise a line is fit between the low energy side and the high energy side. This model only works when there are no peak interference over the range chs.\n\nmodelBackground(spec::Spectrum, chs::AbstractUnitRange{<:Integer})\nmodelBackground(spec::Spectrum, chs::AbstractUnitRange{<:Integer}, ash::AtomicSubShell)\n\nspec: A spectrum containing a peak centered on chs chs:  A range of channels containing a peak ash:  The largest edge within the range of channels chs associated with the characteristic peak\n\nA simple model for modeling the background under a characteristic x-ray peak. The model fits a line between the  low and high energy background regions around first(chs) and last(chs). This model only works when there are no peak interference over the range chs.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.extractcharacteristic","page":"Spectrum Methods","title":"NeXLSpectrum.extractcharacteristic","text":"extractcharacteristic(spec::Spectrum, lowBack::AbstractUnitRange{<:Integer}, highBack::AbstractUnitRange{<:Integer})::Vector{Float64}\n\nExtract the characteristic intensity for the peak located within chs with an edge at ash.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.peak","page":"Spectrum Methods","title":"NeXLSpectrum.peak","text":"peak(spec::Spectrum, chs::AbstractUnitRange{<:Integer}, ash::AtomicSubShell)::Float64\n\nEstimates the peak intensity for the characteristic X-ray in the specified range of channels.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.background","page":"Spectrum Methods","title":"NeXLSpectrum.background","text":"background(spec::Spectrum, chs::AbstractUnitRange{<:Integer}, ash::AtomicSubShell)::Float64\n\nEstimates the background intensity for the characteristic X-ray in the specified range of channels.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.peaktobackground","page":"Spectrum Methods","title":"NeXLSpectrum.peaktobackground","text":"peaktobackground(spec::Spectrum, chs::AbstractUnitRange{<:Integer}, ash::AtomicSubShell)::Float64\n\nEstimates the peak-to-background ratio for the characteristic X-ray intensity in the specified range of channels which encompass the specified AtomicSubShell.\n\n\n\n\n\npeaktobackground(ffr::FilterFitResult, backwidth::Float64=10.0)::Float64\n\nThe peak-to-background ratio as determined from the raw and residual spectra integrated over the fit region-of-interest and scaled to backwidth eV of continuum (nominally 10 eV).\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.estkratio","page":"Spectrum Methods","title":"NeXLSpectrum.estkratio","text":"estkratio(unk::Spectrum, std::Spectrum, chs::AbstractUnitRange{<:Integer})\n\nEstimates the k-ratio from niave models of peak and background intensity.  Only works if the peak is not interfered.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#Miscellaneous-Functions","page":"Spectrum Methods","title":"Miscellaneous Functions","text":"","category":"section"},{"location":"spectrum/","page":"Spectrum Methods","title":"Spectrum Methods","text":"details\ncommonproperties\nmaxspectrum\nBase.findmax","category":"page"},{"location":"spectrum/#NeXLSpectrum.details","page":"Spectrum Methods","title":"NeXLSpectrum.details","text":"details(io, spec::Spectrum)\ndetails(spec::Spectrum)::String\n\nOutputs a description of the data in the spectrum.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.commonproperties","page":"Spectrum Methods","title":"NeXLSpectrum.commonproperties","text":"commonproperties(specs::AbstractArray{Spectrum})\ncommonproperties(props1::Dict{Symbol,Any}, props2::Dict{Symbol,Any})\n\nReturn the properties that are held in common by all the spectra.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#NeXLSpectrum.maxspectrum","page":"Spectrum Methods","title":"NeXLSpectrum.maxspectrum","text":"maxspectrum(specs::AbstractArray{Spectrum{T}})::Spectrum{T} where T<:Real\n\nCompute the max-pixel spectrum for the specified spectra.\n\n\n\n\n\n","category":"function"},{"location":"spectrum/#Base.findmax","page":"Spectrum Methods","title":"Base.findmax","text":"Base.findmax(spec::Spectrum, chs::AbstractRange{<:Integer})\nBase.findmax(spec::Spectrum)\n\nReturns the (maximum intensity, channel index) over the specified range of channels\n\n\n\n\n\n","category":"function"},{"location":"hyperspectrum/#![](NeXL_sm.png)Spectrum","page":"HyperSpectrum Methods","title":"(Image: )Spectrum","text":"","category":"section"},{"location":"hyperspectrum/#hyperspectrum_methods","page":"HyperSpectrum Methods","title":"Working with HyperSpectrum objects","text":"","category":"section"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"HyperSpectrum{T<:Real, N, NP} <: AbstractArray{Spectrum{T}, N} represents an N-dimensional array of Spectrum{T} which share common properties. N = 1 represents a line scan, N = 2 represents a spectrum image, N = 3 can represent a slice-and-view type hyperspectrum cube or a time series of spectrum images.  Higher N are also possible.","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"To construct an empty HyperSpectrum use","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"hs = HyperSpectrum(\n    energy::EnergyScale,\n    props::Dict{Symbol,Any},\n    dims::Tuple,\n    depth::Int,\n    type::Type{<:Real};\n    axisnames = ( \"Y\", \"X\", \"Z\", \"A\", \"B\", \"C\" ), \n    fov = ( 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ),\n    offset = ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ), #\n    stagemap::Type{<:StageMapping}=DefaultStageMapping\n)","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"To construct a HyperSpectrum from an existing array of (N+1) dimensions.  The first dimension is the channel data like (ch, Y, X, ...)","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"hs = HyperSpectrum(\n    energy::EnergyScale, \n    props::Dict{Symbol,Any}, \n    arr::Array{<:Real};\n    axisnames = ( \"Y\", \"X\", \"Z\", \"A\", \"B\", \"C\" ), #\n    fov = [ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], #\n    offset = zeros(length(fov)), #\n    stagemap::Type{<:StageMapping}=DefaultStageMapping, #\n    livetime=fill(get(props, :LiveTime, 1.0), size(arr)[2:end]...)\n)","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"We will assume a 2D hyperspectrum (\"spectrum image\") for these examples.","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"The Spectrum representing individual pixels in a HyperSpectrum are accessed using","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"hs[10,20]  # access the 10th row, 20th column","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"To index energy planes within the HyperSpectrum you can use","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"plane(\n    hss::HyperSpectrum{T, N, NP},\n    chs::AbstractUnitRange{<:Integer},\n    normalize = false,\n)","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"which sums over chs and optionally normalizes to the brightest pixel. Alternatively,","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"plane(\n    hss::HyperSpectrum{T, N, NP},\n    cxr::CharXRay,\n    normalize = false,\n)","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"will extract one FWHM centered on cxr.  Like plane(hss,n\"Fe K-L3\").","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"To extract HyperSpectrum data items representing regions from the HyperSpectrum","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"hs[10:20,20:30] # extract a HyperSpectrum representing the 10th to 20th row and 20th to 30th columns.\nhs[10:2:20,20:2:30] # extract a HyperSpectrum representing every other pixel in the 10th to 20th row and 20th to 30th columns.","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"To extract a linescan from within a 2D HyperSpectrum","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"linescan(hss::HyperSpectrum{T,2,3}, ci1::CartesianIndex{2}, ci2::CartesianIndex{2}, width::Int=1)","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"Mostly, a HyperSpectrum acts like an Array{Spectrum} and you can view and process the  individual spectra this way.  However, this is often inefficient as a new Spectrum datum must be allocated each coordinate.  There are functions designed to operate more efficiently on the channel data.","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"sum(hs) # Produce a sum spectrum\nmaxpixel(hs) # produce a Bright's max-pixel spectrum","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"To find out which pixel contains the max-pixel for each channel in the HyperSpectrum","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"indexofmaxpixel(hss::HyperSpectrum) # An array of CartesianIndices\nindexofmaxpixel(hss::HyperSpectrum, ch::Int) # A CartesianIndices for channel `ch`","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"To visualize planes within the HyperSpectrum as images","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"hss[n\"Fe K-L3\"]  # A FWHM ROI around the Fe K-L3 transition\nroiimage(hss::HyperSpectrum, chs::AbstractUnitRange{<:Integer})","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"For an RGB image of up to three lines","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"colorize(hss::HyperSpectrum, cxrs::AbstractVector{CharXRay}, normalize=:All)\ncolorize(hs, [ n\"Fe K-L3\", n\"Si K-L3\", n\"Al K-L3\" ])","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"Quantifying HyperSpectra is like quantifying spectra.   There is a specialization  of fit_spectrum(...) and quantify(...) optimized for hyper-spectra.","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"fit_spectra(\n    hs::HyperSpectrum,\n    ffp::FilterFitPacket{S, T};\n    mode::Symbol = :Fast[|:Intermediate|:Full]\n    zero = x -> max(Base.zero(T), x),\n    sigma = Base.zero(T)\n)::Array{KRatios}","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":":Fast uses a highly optimized but less precise algorithm that works for up to  approximately 15 to 20 elements.  :Intermediate and :Full perform the slower weighted filtered least-square fit.  :Intermediate sets k-ratios less than zero to zero but doesn't refit, while :Full removes k-ratios that are less than zero  and refits.","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"To convert the Array{KRatios} from fit_spectra to Array{Material}","category":"page"},{"location":"hyperspectrum/","page":"HyperSpectrum Methods","title":"HyperSpectrum Methods","text":"NeXLMatrixCorrection.quantify(\n    measured::AbstractVector{<:KRatios};\n    mc::Type{<:MatrixCorrection} = XPP,\n    fc::Type{<:FluorescenceCorrection} = NullFluorescence,\n    cc::Type{<:CoatingCorrection} = NullCoating,\n    kro::KRatioOptimizer = SimpleKRatioOptimizer(1.5),\n    coating::Union{Nothing, Pair{CharXRay, <:Material}}=nothing\n)","category":"page"},{"location":"XRFspectra/#Fitting-a-Stainless-Steel-XRF-Spectrum","page":"Fitting XRF Spectra","title":"Fitting a Stainless Steel XRF Spectrum","text":"","category":"section"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"Load the necessary libraries.","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"using NeXLSpectrum\nusing Gadfly           # For plotting. I've added spectrum support.\nusing DataFrames, Latexify       # For tables.","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"Load the spectra from EMSA files.","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"path = joinpath(@__DIR__, \"XRF Stainless\")\n# We use map to apply `readEMSA` to each of the files\nspecs = steel, fe, ni, cr, ti, si, s, sn = map(fn->loadspectrum(joinpath(path, fn)), (\n  \"Steel_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Fe_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Ni_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Cr_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Ti_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Si_50kv_50_ma_Rh_vac_D1.msa\",\n  \"S_50kv_50_ma_Rh_vac_D1.msa\",\n  \"Sn_50kv_50_ma_Rh_vac_D1.msa\",));","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"Name BeamEnergy ProbeCurrent LiveTime RealTime Coating Integral Material\nSteel50kv50maRhvacD1 missing missing 120 131.9 nothing 6.536e+06 missing\nFe50kv50maRhvacD1 missing missing 120 134.8 nothing 7.644e+06 missing\nNi50kv50maRhvacD1 missing missing 120 137.7 nothing 8.487e+06 missing\nCr50kv50maRhvacD1 missing missing 120 131.7 nothing 6.578e+06 missing\nTi50kv50maRhvacD1 missing missing 120 128 nothing 5.087e+06 missing\nSi50kv50maRhvacD1 missing missing 120 121 nothing 1.862e+06 missing\nS50kv50maRhvacD1 missing missing 120 122.2 nothing 2.455e+06 missing\nSn50kv50maRhvacD1 missing missing 120 121.5 nothing 2.099e+06 missing","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"plot(specs..., xmax=25.0e3,klms=[n\"Fe\",n\"Cr\",n\"Ni\",n\"Ti\", n\"Si\",n\"S\", n\"Mo\", n\"Rh\"])","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"(Image: )","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"display(plot(steel,xmax=25.0e3, yscale=1.1,klms=[n\"Fe\",n\"Cr\",n\"Ni\",n\"Ti\", n\"Si\",n\"S\", n\"Mo\", n\"Rh\"]))\ndisplay(plot(steel,xmax=25.0e3, yscale=0.01,klms=[n\"Fe\",n\"Cr\",n\"Ni\",n\"Ti\", n\"Si\",n\"S\", n\"Mo\", n\"Rh\"]))","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"(Image: ) (Image: )","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"Build the filtered references which will be fit to the steel unknown.","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"# This Dict defines which is the lowest z element which can be measured for the K, L, M, N shells\nfirstelm = Dict(KShell=>n\"Na\", LShell=>n\"Zn\", MShell=>n\"Sm\", NShell=>n\"Og\")\n# Build a detector to match the steel spectrum\ndet = matching(steel, steel[:FWHMMnKa], 120, firstelm)\n# Build a 'VariableWidthFilter' top-hat filter to suit the detector\nfilt = buildfilter(VariableWidthFilter,det)\nrefdata = (\n  # ( spectrum, element, material ), # The ordering of `refdata` allows us to splat it into `filterreference(...)`\n  ( fe, n\"Fe\", mat\"Fe\" ),\n  ( cr, n\"Cr\", mat\"Cr\" ),\n  ( ni, n\"Ni\", mat\"Ni\" ),\n  ( ti, n\"Ti\", mat\"Ti\" ),\n  ( si, n\"Si\", mat\"Si\" ),\n  ( s, n\"S\", mat\"S\" ),\n  ( sn, n\"Sn\", mat\"Sn\" ),\n)\n# Some necessary properties are missing from the spectra so provide them.\nxtra = Dict{Symbol,Any}(:BeamEnergy=>40.0e3, :ProbeCurrent=>1.0, :Detector=>det)\nrefs = mapreduce(append!, refdata) do (sp, el, mat)\n  filterreference(filt, sp, el, mat, props=xtra)\nend\n# Merge the missing properties into the unknown too.\nmerge!(steel.properties, xtra)\nres = fit_spectrum(steel, filt, refs, false)\n# Tabulate the results","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"FitResult(Steel_50kv_50_ma_Rh_vac_D1)","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"Spectrum Feature Reference K dK Counts RefCountsPernAs CountsPernAs\nSteel50kv50maRhvacD1 k[Cr K-L3 + 5 others, Unspecified] Cr50kv50maRhvacD1 0.2356 0.0002151 1.23e+06 4.351e+04 1.025e+04\nSteel50kv50maRhvacD1 k[Fe K-L3 + 1 other, Unspecified] Fe50kv50maRhvacD1 0.557 0.0003218 3.034e+06 4.541e+04 2.529e+04\nSteel50kv50maRhvacD1 k[Fe K-M3 + 3 others, Unspecified] Fe50kv50maRhvacD1 0.5712 0.001038 4.536e+05 6619 3781\nSteel50kv50maRhvacD1 k[Ni K-L3 + 1 other, Unspecified] Ni50kv50maRhvacD1 0.0488 0.0001035 2.995e+05 5.114e+04 2496\nSteel50kv50maRhvacD1 k[Ni K-M3 + 3 others, Unspecified] Ni50kv50maRhvacD1 0.04948 0.0003118 4.4e+04 7413 366.8\nSteel50kv50maRhvacD1 k[S K-L3 + 3 others, Unspecified] S50kv50maRhvacD1 0.005651 0.000116 5796 8550 48.31\nSteel50kv50maRhvacD1 k[Si K-L3 + 3 others, Unspecified] Si50kv50maRhvacD1 0.002306 0.000114 974.2 3521 8.12\nSteel50kv50maRhvacD1 k[Sn K-L3 + 1 other, Unspecified] Sn50kv50maRhvacD1 -1.2e-05 0.001518 -0.2306 160.2 -0.001922\nSteel50kv50maRhvacD1 k[Sn K-M3 + 9 others, Unspecified] Sn50kv50maRhvacD1 -0.001964 0.006831 -5.949 25.25 -0.04959\nSteel50kv50maRhvacD1 k[Sn L3-M5 + 27 others, Unspecified] Sn50kv50maRhvacD1 -2.336e-05 0.000195 -15.65 5585 -0.1305\nSteel50kv50maRhvacD1 k[Ti K-L3 + 3 others, Unspecified] Ti50kv50maRhvacD1 0.004754 4.537e-05 1.763e+04 3.091e+04 146.9","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"Plot the residual spectrum.  Note that Mo and Rh were not fit and so there remain significant peaks between 16 and 20 keV.","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"plot(res)","category":"page"},{"location":"XRFspectra/","page":"Fitting XRF Spectra","title":"Fitting XRF Spectra","text":"(Image: )","category":"page"},{"location":"precompile/#Precompiling-NeXLSpectrum","page":"Precompilation","title":"Precompiling NeXLSpectrum","text":"","category":"section"},{"location":"precompile/","page":"Precompilation","title":"Precompilation","text":"Unfortunately, when you first start a Julia REPL (or Jupyter/Pluto notebook or Weave document) to work with NeXLSpectrum,  Julia needs to load and compile many libraries.  This can be tediously slow particularly if you add Gadfly and DataFrames into the mix.","category":"page"},{"location":"precompile/","page":"Precompilation","title":"Precompilation","text":"To mitigate this, it is useful to using PackageCompiler to create a sysimage containing compiled versions of NeXLUncertainties, NeXLCore, NeXLSpectrum, Gadfly and DataFrames.","category":"page"},{"location":"precompile/","page":"Precompilation","title":"Precompilation","text":"This process takes time (about 10 minutes on my laptop) but makes Julia much more responsive.","category":"page"},{"location":"precompile/","page":"Precompilation","title":"Precompilation","text":"Here is the secret incantation.","category":"page"},{"location":"precompile/","page":"Precompilation","title":"Precompilation","text":"using PackageCompiler, NeXLSpectrum\nPackageCompiler.create_sysimage(\n    [ \"Gadfly\", \"DataFrames\", \"BoteSalvatICX\", \"FFAST\", \"NeXLUncertainties\", \"NeXLCore\", \"NeXLMatrixCorrection\", \"NeXLSpectrum\" ]; \n    sysimage_path=joinpath(homedir(), \".julia\", \"NeXLSysimage.dll\"),\n    precompile_execution_file=joinpath(pkgdir(NeXLSpectrum),\"scripts\", \"precompile.jl\"))","category":"page"},{"location":"precompile/","page":"Precompilation","title":"Precompilation","text":"where precompile.jl provides additional usage data to help ensure that the right functions are included.","category":"page"},{"location":"precompile/","page":"Precompilation","title":"Precompilation","text":"But this alone isn't enough.  Now you need to tell Julia that you want to load this sysimage.  For this you need to add the -J argument when you invoke julia.  Something like this","category":"page"},{"location":"precompile/","page":"Precompilation","title":"Precompilation","text":"> julia -J/$HOME$/.julia/NeXLSysmage.dll","category":"page"},{"location":"precompile/","page":"Precompilation","title":"Precompilation","text":"where #HOME is the path in which .julia is located.","category":"page"},{"location":"precompile/","page":"Precompilation","title":"Precompilation","text":"It is worthwhile to understand the limitations associated with PackageCompiler and sysimages.","category":"page"},{"location":"K412fit/#k412fits","page":"Fitting K412 (flexible API)","title":"Quantifying K412 using NeXLSpectrum and NeXLMatrixCorrection","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"This document demonstrates the low-level API for filter fitting spectra.  It is more flexible than the higher- level API but much more complex.  In most situations, the high level API discussed here is more appropriate.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Use the NeXLSpectrum to load, plot, fit and report the quantification of a set of K412 spectra.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Loading NeXLSpectrum also automatically makes NeXLCore and NeXLUncertainties available.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Loading the Gadfly library adds plotting support to NeXLSpectrum.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"using NeXLSpectrum              # Provides spectrum reading and fitting tools\nusing NeXLMatrixCorrection      # Provides `quant` to convert k-ratios to mass fraction.\nusing Gadfly                    # Plotting\nusing DataFrames, Latexify      # Tables","category":"page"},{"location":"K412fit/#Read-in-the-Spectra","page":"Fitting K412 (flexible API)","title":"Read in the Spectra","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"path = joinpath(@__DIR__,\"K412 spectra\")\n# Load a single spectrum\nfe = loadspectrum(joinpath(path, \"Fe std.msa\"))\n# Create a detector model to match it\ndet = matching(fe, 132.0, 10)\n# Now load all the spectra using this detector\nunks = (i->loadspectrum(joinpath(path, \"III-E K412[$i][4].msa\"),det)).(0:4)\nal2o3 = loadspectrum(joinpath(path, \"Al2O3 std.msa\"),det)\ncaf2 = loadspectrum(joinpath(path, \"CaF2 std.msa\"),det)\nfe = loadspectrum(joinpath(path, \"Fe std.msa\"),det)\nmgo = loadspectrum(joinpath(path, \"MgO std.msa\"),det)\nsio2 = loadspectrum(joinpath(path, \"SiO2 std.msa\"),det)\n# Add carbon coating\nforeach(s->s[:Coating]=Film(pure(n\"C\"), 30.0e-7), unks)\nforeach(s->s[:Coating]=Film(pure(n\"C\"), 10.0e-7), (al2o3, caf2, mgo, sio2));","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Table: The spectra","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Name BeamEnergy ProbeCurrent LiveTime RealTime Coating Integral Material\nIII-E K412[0][all] 2e+04 1.114 235.5 286.3 30.0 nm of Pure C 8.079e+06 K412\nIII-E K412[1][all] 2e+04 1.114 235.4 286.2 30.0 nm of Pure C 8.077e+06 K412\nIII-E K412[2][all] 2e+04 1.112 235.5 286.3 30.0 nm of Pure C 8.084e+06 K412\nIII-E K412[3][all] 2e+04 1.11 235.4 286.3 30.0 nm of Pure C 8.087e+06 K412\nIII-E K412[4][all] 2e+04 1.11 235.4 286.2 30.0 nm of Pure C 8.081e+06 K412\nAl2O3 std 2e+04 1.11 1172 1491 10.0 nm of Pure C 4.974e+07 Al2O3\nCaF2 std 2e+04 1.11 1176 1456 10.0 nm of Pure C 4.406e+07 CaF2\nFe std 2e+04 1.11 1171 1529 nothing 5.445e+07 Fe\nMgO std 2e+04 1.106 1176 1496 10.0 nm of Pure C 4.985e+07 MgO\nSiO2 std 2e+04 1.11 1173 1470 10.0 nm of Pure C 4.665e+07 SiO2","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Notice that the spectra all have 1) live-time (:LiveTime); 2) probe-current (:ProbeCurrent); 3) take-off angle (:TakeOffAngle); 4) beam energy (:BeamEnergy); and detector (:Detector) properties defined.  These properties are necessary for extracting the k-ratios and estimating the composition.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"sio2[:LiveTime], sio2[:ProbeCurrent], sio2[:TakeOffAngle], sio2[:BeamEnergy], sio2[:Detector]","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"(1173.1648, 1.10989, 0.6108652381980153, 20000.0, BasicEDS[4096 chs, 1.6303\n2 + 9.99856⋅ch eV, 132.0 eV @ Mn K-L3, 10 ch LLD, [Be,Sc,Ba,Pu]])","category":"page"},{"location":"K412fit/#The-Unknowns","page":"Fitting K412 (flexible API)","title":"The Unknowns","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"display(plot(unks..., klms=[n\"O\",n\"Mg\",n\"Al\",n\"Si\",n\"Ca\",n\"Fe\"], xmax=8.0e3))","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"(Image: )","category":"page"},{"location":"K412fit/#The-Reference-Spectra","page":"Fitting K412 (flexible API)","title":"The Reference Spectra","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Build a convenient structure so it is easy to appreciate the necessary information and to splat it into filteredReference.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"refs = (\n  # spectrum, element, composition\n  ( al2o3, n\"Al\", mat\"Al2O3\" ), #\n  ( mgo,   n\"Mg\", mat\"MgO\" ),   #\n  ( fe,    n\"Fe\", mat\"Fe\" ),    #\n  ( sio2,  n\"Si\", mat\"SiO2\" ),  #\n  ( sio2,  n\"O\",  mat\"SiO2\" ),  #\n  ( caf2,  n\"Ca\", mat\"CaF2\" ), )\ndisplay(plot(al2o3, caf2, fe, mgo, sio2, klms=collect( ref[2] for ref in refs), xmax=8.0e3))","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"(Image: )","category":"page"},{"location":"K412fit/#Pre-filter-the-Reference-Spectra","page":"Fitting K412 (flexible API)","title":"Pre-filter the Reference Spectra","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"# Build a top-hat filter\nfilt = buildfilter(NeXLSpectrum.GaussianFilter,det)\n# Filter all the reference spectra\nfrs = mapreduce(ref->filterreference(filt, ref..., withEsc=true), append!, refs)\n# frs is now a FilteredReference[] used to fit the unknowns.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"12-element Vector{FilteredReference{Float64}}:\n Reference[k[Al K-L3 + 3 others, Al2O3]]\n Reference[k[Mg K-L3 + 1 other, MgO]]\n Reference[k[Fe L3-M5 + 13 others, Fe]]\n Reference[k[Fe K-L3 + 1 other, Fe]]\n Reference[k[Fe K-M3 + 3 others, Fe]]\n Reference[Ecs[Fe K-L3 + 1 other]]\n Reference[Ecs[Fe K-M3 + 3 others]]\n Reference[k[Si K-L3 + 3 others, SiO2]]\n Reference[k[O K-L3 + 1 other, SiO2]]\n Reference[k[Ca K-L3 + 3 others, CaF2]]\n Reference[Ecs[Ca K-L3 + 1 other]]\n Reference[Ecs[Ca K-M3 + 1 other]]","category":"page"},{"location":"K412fit/#Fit-the-Pre-Filtered-References-to-the-Unknowns","page":"Fitting K412 (flexible API)","title":"Fit the Pre-Filtered References to the Unknowns","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"res= [ fit_spectrum(unk,filt,frs,false) for unk in unks ]","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"5-element Vector{FilterFitResult{Float64}}:\n FitResult(III-E K412[0][all])\n FitResult(III-E K412[1][all])\n FitResult(III-E K412[2][all])\n FitResult(III-E K412[3][all])\n FitResult(III-E K412[4][all])","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Spectra k[O K-L3 + 1 other, SiO2] k[Fe L3-M5 + 13 others, Fe] k[Mg K-L3 + 1 other, MgO] k[Al K-L3 + 3 others, Al2O3] k[Si K-L3 + 3 others, SiO2] k[Ca K-L3 + 3 others, CaF2] k[Fe K-L3 + 1 other, Fe] k[Fe K-M3 + 3 others, Fe]\nIII-E K412[0][all] 0.6422 0.03929 0.1469 0.06716 0.3506 0.1925 0.06714 0.06744\nIII-E K412[1][all] 0.6449 0.03921 0.1468 0.06666 0.3496 0.1918 0.06718 0.06544\nIII-E K412[2][all] 0.6451 0.03969 0.1472 0.067 0.3505 0.1925 0.06687 0.06622\nIII-E K412[3][all] 0.6497 0.03846 0.1477 0.06705 0.351 0.1929 0.06706 0.06702\nIII-E K412[4][all] 0.6482 0.03854 0.1476 0.06722 0.3517 0.1922 0.06696 0.06577","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Let's take a look at a residual spectrum by plotting one of the FilterFitResult objects.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"plot(res[1])","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"(Image: )","category":"page"},{"location":"K412fit/#Quantify-the-k-ratios-by-Matrix-Correction","page":"Fitting K412 (flexible API)","title":"Quantify the k-ratios by Matrix Correction","text":"","category":"section"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"quant = quantify.(res)","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"5-element Vector{IterationResult}:\n Converged to III-E K412[0][all][O=0.4745,Mg=0.1170,Al=0.0488,Si=0.2081,Ca=\n0.1090,Fe=0.0810] in 8 steps.\n Converged to III-E K412[1][all][O=0.4754,Mg=0.1170,Al=0.0484,Si=0.2075,Ca=\n0.1086,Fe=0.0811] in 8 steps.\n Converged to III-E K412[2][all][O=0.4761,Mg=0.1172,Al=0.0486,Si=0.2080,Ca=\n0.1090,Fe=0.0807] in 8 steps.\n Converged to III-E K412[3][all][O=0.4788,Mg=0.1176,Al=0.0487,Si=0.2083,Ca=\n0.1093,Fe=0.0809] in 9 steps.\n Converged to III-E K412[4][all][O=0.4776,Mg=0.1175,Al=0.0488,Si=0.2087,Ca=\n0.1089,Fe=0.0808] in 9 steps.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Material O Mg Al Si Ca Fe Total\nIII-E K412[0][all] 0.4745 0.117 0.04876 0.2081 0.109 0.081 1.038\nIII-E K412[1][all] 0.4754 0.117 0.04842 0.2075 0.1086 0.08106 1.038\nIII-E K412[2][all] 0.4761 0.1172 0.04865 0.208 0.109 0.08069 1.04\nIII-E K412[3][all] 0.4788 0.1176 0.0487 0.2083 0.1093 0.08093 1.044\nIII-E K412[4][all] 0.4776 0.1175 0.04881 0.2087 0.1089 0.0808 1.042","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Finally plot the results as mass fractions.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"plot(quant, known=unks[1][:Composition])","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"(Image: )","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Plot the difference from the SRM value.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"plot(quant, known=unks[1][:Composition], delta=true)","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"(Image: )","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"Plot the difference from the mean value for each element.","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"plot(quant, delta=true)","category":"page"},{"location":"K412fit/","page":"Fitting K412 (flexible API)","title":"Fitting K412 (flexible API)","text":"(Image: )","category":"page"},{"location":"k412refs/#k412refs","page":"Fitting K412 (simple API)","title":"Quantifying K412 using NeXLSpectrum and NeXLMatrixCorrection","text":"","category":"section"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"This document demonstrates the high-level API for filter fitting spectra.  This API is less flexible than the low-level API discussed here.","category":"page"},{"location":"k412refs/#Libraries","page":"Fitting K412 (simple API)","title":"Libraries","text":"","category":"section"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Use the NeXLSpectrum to load, plot, fit and report the quantification of a set of K412 spectra.","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Loading NeXLSpectrum also automatically makes NeXLCore and NeXLUncertainties available.","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Loading the Gadfly library adds plotting support to NeXLSpectrum.","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"using NeXLSpectrum              # Provides spectrum reading and fitting tools\nusing NeXLMatrixCorrection      # Provides `quant` to convert k-ratios to mass fraction.\nusing Gadfly                    # Plotting\nusing DataFrames, Latexify      # Tables","category":"page"},{"location":"k412refs/#The-reference-and-references-functions","page":"Fitting K412 (simple API)","title":"The reference and references functions","text":"","category":"section"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Use the reference and references functions to build the filtered references.","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"# Where to find the files relative to this script file.\npath = joinpath(@__DIR__, \"K412 spectra\")\n\nrefs = references(\n  [\n    # Specify a reference for iron (arg 1), in \"Fe std.msa\" (arg2) that is pure iron (arg3).\n    reference(n\"Fe\", joinpath(path, \"Fe std.msa\"), mat\"Fe\"),\n    # specify a conductive surface coating layer using the `coating` named argument\n    reference(n\"Si\", joinpath(path, \"SiO2 std.msa\"), mat\"SiO2\", coating = Film(pure(n\"C\"), 10.0e-7)),\n    reference(n\"O\", joinpath(path, \"SiO2 std.msa\"), mat\"SiO2\", coating = Film(pure(n\"C\"), 10.0e-7)),\n    reference(n\"Ca\", joinpath(path, \"CaF2 std.msa\"), mat\"CaF2\", coating = Film(pure(n\"C\"), 10.0e-7)),\n    # Read the composition from the spectrum file's ##D2STDCMP tag\n    reference(n\"Mg\", joinpath(path, \"MgO std.msa\"), coating = Film(pure(n\"C\"), 10.0e-7)),\n    # Read the conductive coating from the spectrum file's ##CONDCOATING tag\n    reference(n\"Al\", joinpath(path, \"Al2O3 std.msa\"), mat\"Al2O3\"),\n  ],\n  132.0  # Detector resolution at Mn Kα (eV)\n)","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"References[\n\tBasicEDS[4096 chs, 1.63032 + 9.99856⋅ch eV, 132.0 eV @ Mn K-L3, 1 ch LLD, \n[Be,Sc,Ba,Pu]], \n\tk[Fe L3-M5 + 13 others, Fe],\n\tk[Fe K-L3 + 1 other, Fe],\n\tk[Fe K-M3 + 3 others, Fe],\n\tk[Si K-L3 + 3 others, SiO2],\n\tk[O K-L3 + 1 other, SiO2],\n\tk[Ca K-L3 + 3 others, CaF2],\n\tk[Mg K-L3 + 1 other, MgO],\n\tk[Al K-L3 + 3 others, Al2O3],\n]","category":"page"},{"location":"k412refs/#Load-the-Unknowns","page":"Fitting K412 (simple API)","title":"Load the Unknowns","text":"","category":"section"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"# Now load all the unknown spectra and assign a carbon coating`\nunks = map(0:4) do i \n    s = loadspectrum(joinpath(path, \"III-E K412[$i][4].msa\"))\n    # assign a carbon coating\n    s[:Coating] = Film(pure(n\"C\"), 30.0e-7)\n    s\nend","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"5-element Vector{Spectrum{Float64}}:\n Spectrum{Float64}[III-E K412[0][all], 1.63032 + 9.99856⋅ch eV, 4096 ch, 20\n.0 keV, K412, 8.08e6 counts]\n Spectrum{Float64}[III-E K412[1][all], 1.63032 + 9.99856⋅ch eV, 4096 ch, 20\n.0 keV, K412, 8.08e6 counts]\n Spectrum{Float64}[III-E K412[2][all], 1.63032 + 9.99856⋅ch eV, 4096 ch, 20\n.0 keV, K412, 8.08e6 counts]\n Spectrum{Float64}[III-E K412[3][all], 1.63032 + 9.99856⋅ch eV, 4096 ch, 20\n.0 keV, K412, 8.09e6 counts]\n Spectrum{Float64}[III-E K412[4][all], 1.63032 + 9.99856⋅ch eV, 4096 ch, 20\n.0 keV, K412, 8.08e6 counts]","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Table: The spectra","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Name BeamEnergy ProbeCurrent LiveTime RealTime Coating Integral Material\nIII-E K412[0][all] 2e+04 1.114 235.5 286.3 30.0 nm of Pure C 8.08e+06 K412\nIII-E K412[1][all] 2e+04 1.114 235.4 286.2 30.0 nm of Pure C 8.077e+06 K412\nIII-E K412[2][all] 2e+04 1.112 235.5 286.3 30.0 nm of Pure C 8.084e+06 K412\nIII-E K412[3][all] 2e+04 1.11 235.4 286.3 30.0 nm of Pure C 8.087e+06 K412\nIII-E K412[4][all] 2e+04 1.11 235.4 286.2 30.0 nm of Pure C 8.081e+06 K412\nFe std 2e+04 1.11 1171 1529 nothing 5.445e+07 Fe\nFe std 2e+04 1.11 1171 1529 nothing 5.445e+07 Fe\nFe std 2e+04 1.11 1171 1529 nothing 5.445e+07 Fe\nSiO2 std 2e+04 1.11 1173 1470 10.0 nm of Pure C 4.665e+07 SiO2\nSiO2 std 2e+04 1.11 1173 1470 10.0 nm of Pure C 4.665e+07 SiO2\nCaF2 std 2e+04 1.11 1176 1456 10.0 nm of Pure C 4.406e+07 CaF2\nMgO std 2e+04 1.106 1176 1496 10.0 nm of Pure C 4.985e+07 MgO\nAl2O3 std 2e+04 1.11 1172 1491 10.0 nm of Pure Carbon 4.974e+07 Al2O3","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Notice that the spectra all have 1) live-time (:LiveTime); 2) probe-current (:ProbeCurrent); 3) take-off angle (:TakeOffAngle); 4) beam energy (:BeamEnergy); and detector (:Detector) properties defined.  These properties are necessary for extracting the k-ratios and estimating the composition.","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"u=unks[1]\nu[:LiveTime], u[:ProbeCurrent], u[:TakeOffAngle], u[:BeamEnergy], u[:Coating]","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"(235.48403, 1.11355, 0.6108652381980153, 20000.0, 30.0 nm of Pure C)","category":"page"},{"location":"k412refs/#The-Unknowns","page":"Fitting K412 (simple API)","title":"The Unknowns","text":"","category":"section"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"display(plot(unks..., klms=[n\"O\",n\"Mg\",n\"Al\",n\"Si\",n\"Ca\",n\"Fe\"], xmax=8.0e3))","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"(Image: )","category":"page"},{"location":"k412refs/#The-Reference-Spectra","page":"Fitting K412 (simple API)","title":"The Reference Spectra","text":"","category":"section"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Plot the reference spectra...","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"plot(spectra(refs)..., klms=collect(elms(refs)), xmax=8.0e3)","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"(Image: )","category":"page"},{"location":"k412refs/#Fit-the-Pre-Filtered-References-to-the-Unknowns","page":"Fitting K412 (simple API)","title":"Fit the Pre-Filtered References to the Unknowns","text":"","category":"section"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"res= [ fit_spectrum(u,refs) for u in unks ]","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"5-element Vector{FilterFitResult{Float64}}:\n FitResult(III-E K412[0][all])\n FitResult(III-E K412[1][all])\n FitResult(III-E K412[2][all])\n FitResult(III-E K412[3][all])\n FitResult(III-E K412[4][all])","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Spectra k[O K-L3 + 1 other, SiO2] k[Fe L3-M5 + 13 others, Fe] k[Mg K-L3 + 1 other, MgO] k[Al K-L3 + 3 others, Al2O3] k[Si K-L3 + 3 others, SiO2] k[Ca K-L3 + 3 others, CaF2] k[Fe K-L3 + 1 other, Fe] k[Fe K-M3 + 3 others, Fe]\nIII-E K412[0][all] 0.6536 0.04191 0.1476 0.06699 0.3507 0.1922 0.06683 0.06684\nIII-E K412[1][all] 0.6554 0.04156 0.1475 0.06675 0.3499 0.1916 0.06708 0.06738\nIII-E K412[2][all] 0.656 0.04191 0.1479 0.06709 0.3511 0.1922 0.06688 0.06704\nIII-E K412[3][all] 0.6604 0.04146 0.1481 0.06716 0.3519 0.1925 0.06682 0.0678\nIII-E K412[4][all] 0.6588 0.04081 0.1482 0.06728 0.3518 0.1922 0.06694 0.06648","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Let's take a look at a residual spectrum by plotting one of the FilterFitResult objects.","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"plot(res[1])","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"(Image: )","category":"page"},{"location":"k412refs/#Quantify-the-k-ratios-by-Matrix-Correction","page":"Fitting K412 (simple API)","title":"Quantify the k-ratios by Matrix Correction","text":"","category":"section"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"quant = quantify.(res)","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"5-element Vector{IterationResult}:\n Converged to III-E K412[0][all][O=0.4805,Mg=0.1176,Al=0.0487,Si=0.2081,Ca=\n0.1089,Fe=0.0806] in 9 steps.\n Converged to III-E K412[1][all][O=0.4809,Mg=0.1176,Al=0.0485,Si=0.2077,Ca=\n0.1085,Fe=0.0810] in 8 steps.\n Converged to III-E K412[2][all][O=0.4818,Mg=0.1179,Al=0.0487,Si=0.2084,Ca=\n0.1089,Fe=0.0807] in 9 steps.\n Converged to III-E K412[3][all][O=0.4844,Mg=0.1180,Al=0.0488,Si=0.2088,Ca=\n0.1090,Fe=0.0807] in 8 steps.\n Converged to III-E K412[4][all][O=0.4833,Mg=0.1181,Al=0.0489,Si=0.2088,Ca=\n0.1089,Fe=0.0808] in 8 steps.","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Material O Mg Al Si Ca Fe Total\nIII-E K412[0][all] 0.4805 0.1176 0.04865 0.2081 0.1089 0.08065 1.044\nIII-E K412[1][all] 0.4809 0.1176 0.0485 0.2077 0.1085 0.08095 1.044\nIII-E K412[2][all] 0.4818 0.1179 0.04873 0.2084 0.1089 0.08072 1.046\nIII-E K412[3][all] 0.4844 0.118 0.04878 0.2088 0.109 0.08066 1.05\nIII-E K412[4][all] 0.4833 0.1181 0.04887 0.2088 0.1089 0.0808 1.049","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Finally plot the results as mass fractions.","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"plot(quant, known=unks[1][:Composition])","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"(Image: )","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Plot the difference from the SRM value.","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"plot(quant, known=unks[1][:Composition], delta=true)","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"(Image: )","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"Plot the difference from the mean value for each element.","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"plot(quant, delta=true)","category":"page"},{"location":"k412refs/","page":"Fitting K412 (simple API)","title":"Fitting K412 (simple API)","text":"(Image: )","category":"page"},{"location":"#![](NeXL_sm.png)Spectrum-Part-of-the-NeXL-X-ray-Microanalysis-Library","page":"Home","title":"(Image: )Spectrum - Part of the NeXL X-ray Microanalysis Library","text":"","category":"section"},{"location":"#Installing-NeXLSpectrum.jl","page":"Home","title":"Installing NeXLSpectrum.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NeXLSpectrum is available throught the standard Julia registry and can be installed using the standard package manager.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add NeXLSpectrum","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"NeXLSpectrum\")","category":"page"},{"location":"#Microanalytical-X-ray-Spectrum-Analysis","page":"Home","title":"Microanalytical X-ray Spectrum Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NeXLSpectrum is a library of tools for manipulating EDS spectrum within the NeXL framework. NeXLSpectrum depends on NeXLUncertainties, NeXLCore and NeXLMatrixCorrection and loading NeXLSpectrum will also make these libraries available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Primarily, NeXLSpectrum","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implements the Spectrum type to represent individual EDS spectra\nReads Spectrum objects from disk files (or other streams) in EMSA, Bruker and ASPEX formats\nWrites Spectrum objects to a disk file in EMSA format\nProvides utilities and other low level tools to interogate and manipulate Spectrum objects\nImplements the HyperSpectrum type to represent hyper-spectra (linescan, image, cube, ...)\nThe individual pixels in a hyper-spectrum are visible as Spectrum objects\nReads HyperSpectrum objects from LISPIX-style RPL/RAW files\nWrites HyperSpectrum objects to RPL/RAW files\nProvides data types to define detector properties\nExtends Gadfly.jl to plot spectra and spectrum-related items\nProvides algorithms to perform Schamber-style filter-fitting of spectra\nImplements a basic weighted LLSQ fit algorithm\nFits characteristic, escape, Compton and other features\nImplements a 'vector-based' quick-quant algorithm for processing hyper-spectra","category":"page"}]
}
