<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HyperSpectrum Methods · NeXLSpectrum.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">
<script src="https://pages.nist.gov/nist-header-footer/js/jquery-1.9.0.min.js" type="text/javascript" defer="defer"></script>
<script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>
</head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="NeXLSpectrum.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">NeXLSpectrum.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../spectrum/">Spectrum Methods</a></li><li class="is-active"><a class="tocitem" href>HyperSpectrum Methods</a><ul class="internal"><li><a class="tocitem" href="#hyperspectrum_methods"><span>Working with HyperSpectrum objects</span></a></li></ul></li><li><a class="tocitem" href="../k412refs/">Fitting K412 (simple API)</a></li><li><a class="tocitem" href="../K412fit/">Fitting K412 (flexible API)</a></li><li><a class="tocitem" href="../K412quick/">Fitting K412 (quick fit)</a></li><li><a class="tocitem" href="../XRFspectra/">Fitting XRF Spectra</a></li><li><a class="tocitem" href="../errorbars/">Lovely Error Bars</a></li><li><a class="tocitem" href="../continuummodel/">Modeling the Continuum</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><a class="tocitem" href="../precompile/">Precompilation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>HyperSpectrum Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>HyperSpectrum Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/usnistgov/NeXLSpectrum.jl/blob/master/docs/src/hyperspectrum.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="![](NeXL_sm.png)Spectrum"><a class="docs-heading-anchor" href="#![](NeXL_sm.png)Spectrum"><img src="../NeXL_sm.png" alt/>Spectrum</a><a id="![](NeXL_sm.png)Spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#![](NeXL_sm.png)Spectrum" title="Permalink"></a></h1><h2 id="hyperspectrum_methods"><a class="docs-heading-anchor" href="#hyperspectrum_methods">Working with HyperSpectrum objects</a><a id="hyperspectrum_methods-1"></a><a class="docs-heading-anchor-permalink" href="#hyperspectrum_methods" title="Permalink"></a></h2><p><code>HyperSpectrum{T&lt;:Real, N, NP} &lt;: AbstractArray{Spectrum{T}, N}</code> represents an N-dimensional array of <code>Spectrum{T}</code> which share common properties. N = 1 represents a line scan, N = 2 represents a spectrum image, N = 3 can represent a slice-and-view type hyperspectrum cube or a time series of spectrum images.  Higher N are also possible.</p><p>To construct an empty <code>HyperSpectrum</code> use</p><pre><code class="language-julia hljs">hs = HyperSpectrum(
    energy::EnergyScale,
    props::Dict{Symbol,Any},
    dims::Tuple,
    depth::Int,
    type::Type{&lt;:Real};
    axisnames = ( &quot;Y&quot;, &quot;X&quot;, &quot;Z&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ), 
    fov = ( 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ),
    offset = ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ), #
    stagemap::Type{&lt;:StageMapping}=DefaultStageMapping
)</code></pre><p>To construct a <code>HyperSpectrum</code> from an existing array of (N+1) dimensions.  The first dimension is the channel data like (ch, Y, X, ...)</p><pre><code class="language-julia hljs">hs = HyperSpectrum(
    energy::EnergyScale, 
    props::Dict{Symbol,Any}, 
    arr::Array{&lt;:Real};
    axisnames = ( &quot;Y&quot;, &quot;X&quot;, &quot;Z&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ), #
    fov = [ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ], #
    offset = zeros(length(fov)), #
    stagemap::Type{&lt;:StageMapping}=DefaultStageMapping, #
    livetime=fill(get(props, :LiveTime, 1.0), size(arr)[2:end]...)
)</code></pre><p>We will assume a 2D hyperspectrum (&quot;spectrum image&quot;) for these examples.</p><p>The <code>Spectrum</code> representing individual pixels in a <code>HyperSpectrum</code> are accessed using</p><pre><code class="language-julia hljs">hs[10,20]  # access the 10th row, 20th column</code></pre><p>To index energy planes within the <code>HyperSpectrum</code> you can use</p><pre><code class="language-julia hljs">plane(
    hss::HyperSpectrum{T, N, NP},
    chs::AbstractUnitRange{&lt;:Integer},
    normalize = false,
)</code></pre><p>which sums over <code>chs</code> and optionally normalizes to the brightest pixel. Alternatively,</p><pre><code class="language-julia hljs">plane(
    hss::HyperSpectrum{T, N, NP},
    cxr::CharXRay,
    normalize = false,
)</code></pre><p>will extract one FWHM centered on <code>cxr</code>.  Like <code>plane(hss,n&quot;Fe K-L3&quot;)</code>.</p><p>To extract <code>HyperSpectrum</code> data items representing regions from the <code>HyperSpectrum</code></p><pre><code class="language-julia hljs">hs[10:20,20:30] # extract a HyperSpectrum representing the 10th to 20th row and 20th to 30th columns.
hs[10:2:20,20:2:30] # extract a HyperSpectrum representing every other pixel in the 10th to 20th row and 20th to 30th columns.</code></pre><p>To extract a linescan from within a 2D <code>HyperSpectrum</code></p><pre><code class="language-julia hljs">linescan(hss::HyperSpectrum{T,2,3}, ci1::CartesianIndex{2}, ci2::CartesianIndex{2}, width::Int=1)</code></pre><p>Mostly, a <code>HyperSpectrum</code> acts like an <code>Array{Spectrum}</code> and you can view and process the  individual spectra this way.  However, this is often inefficient as a new <code>Spectrum</code> datum must be allocated each coordinate.  There are functions designed to operate more efficiently on the channel data.</p><pre><code class="language-julia hljs">sum(hs) # Produce a sum spectrum
maxpixel(hs) # produce a Bright&#39;s max-pixel spectrum</code></pre><p>To find out which pixel contains the max-pixel for each channel in the <code>HyperSpectrum</code></p><pre><code class="language-julia hljs">indexofmaxpixel(hss::HyperSpectrum) # An array of CartesianIndices
indexofmaxpixel(hss::HyperSpectrum, ch::Int) # A CartesianIndices for channel `ch`</code></pre><p>To visualize planes within the <code>HyperSpectrum</code> as images</p><pre><code class="language-julia hljs">hss[n&quot;Fe K-L3&quot;]  # A FWHM ROI around the Fe K-L3 transition
roiimage(hss::HyperSpectrum, chs::AbstractUnitRange{&lt;:Integer})</code></pre><p>For an RGB image of up to three lines</p><pre><code class="language-julia hljs">colorize(hss::HyperSpectrum, cxrs::AbstractVector{CharXRay}, normalize=:All)
colorize(hs, [ n&quot;Fe K-L3&quot;, n&quot;Si K-L3&quot;, n&quot;Al K-L3&quot; ])</code></pre><p>Quantifying <code>HyperSpectra</code> is like quantifying spectra.   There is a specialization  of <code>fit_spectrum(...)</code> and <code>quantify(...)</code> optimized for hyper-spectra.</p><pre><code class="language-julia hljs">fit_spectra(
    hs::HyperSpectrum,
    ffp::FilterFitPacket{S, T};
    mode::Symbol = :Fast[|:Intermediate|:Full]
    zero = x -&gt; max(Base.zero(T), x),
    sigma = Base.zero(T)
)::Array{KRatios}</code></pre><p><code>:Fast</code> uses a highly optimized but less precise algorithm that works for up to  approximately 15 to 20 elements.  <code>:Intermediate</code> and <code>:Full</code> perform the slower weighted filtered least-square fit.  <code>:Intermediate</code> sets k-ratios less than zero to zero but doesn&#39;t refit, while <code>:Full</code> removes k-ratios that are less than zero  and refits.</p><p>To convert the <code>Array{KRatios}</code> from <code>fit_spectra</code> to <code>Array{Material}</code></p><pre><code class="language-julia hljs">NeXLMatrixCorrection.quantify(
    measured::AbstractVector{&lt;:KRatios};
    mc::Type{&lt;:MatrixCorrection} = XPP,
    fc::Type{&lt;:FluorescenceCorrection} = NullFluorescence,
    cc::Type{&lt;:CoatingCorrection} = NullCoating,
    kro::KRatioOptimizer = SimpleKRatioOptimizer(1.5),
    coating::Union{Nothing, Pair{CharXRay, &lt;:Material}}=nothing
)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spectrum/">« Spectrum Methods</a><a class="docs-footer-nextpage" href="../k412refs/">Fitting K412 (simple API) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 27 June 2023 12:21">Tuesday 27 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
