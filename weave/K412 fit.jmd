## Quantifying K412 using NeXLSpectrum and NeXLMatrixCorrection

Use the NeXLSpectrum to load, plot, fit and report the quantification of a set of K412 spectra.

Loading `NeXLSpectrum` also automatically makes `NeXLCore` and `NeXLUncertainties` available.

Loading the `Gadfly` library adds plotting support to `NeXLSpectrum`.

```julia
using NeXLSpectrum              # Provides spectrum reading and fitting tools
using NeXLMatrixCorrection      # Provides `quant` to convert k-ratios to mass fraction.
using Gadfly                    # Plotting
using DataFrames                # Tables
```
#### Read in the Spectra
```julia
path = "K412 spectra"
# Load a single spectrum
fe = readEMSA("$(path)/Fe std.msa")
# Create a detector model to match it
det = matching(fe, 132.0, 10)
# Now load all the spectra using this detector
unks = (i->readEMSA("$(path)/III-E K412[$i][4].msa",det,true)).(0:4)
al2o3 = readEMSA("$(path)/Al2O3 std.msa",det,true)
caf2 = readEMSA("$(path)/CaF2 std.msa",det,true)
fe = readEMSA("$(path)/Fe std.msa",det,true)
mgo = readEMSA("$(path)/MgO std.msa",det,true)
sio2 = readEMSA("$(path)/SiO2 std.msa",det,true)
# Add carbon coating
map(s->s[:Coating]=Film(pure(n"C"), 30.0e-7), unks)
map(s->s[:Coating]=Film(pure(n"C"), 10.0e-7), (al2o3, caf2, mgo, sio2))
asa(DataFrame, Spectrum[unks..., al2o3, caf2, fe, mgo, sio2])
```
Notice that the spectra all have 1) live-time (`:LiveTime`); 2) probe-current (`:ProbeCurrent`); 3) take-off angle
(`:TakeOffAngle`); 4) beam energy (`:BeamEnergy`); and detector (`:Detector`) properties defined.  These properties
are necessary for extracting the k-ratios and estimating the composition.
```julia
sio2[:LiveTime], sio2[:ProbeCurrent], sio2[:TakeOffAngle], sio2[:BeamEnergy], sio2[:Detector]
```
#### The Unknowns
```julia; fig_height=3; fig_width=10; fig_ext=".svg";
display(plot(unks..., klms=[n"O",n"Mg",n"Al",n"Si",n"Ca",n"Fe"], xmax=8.0e3))
```
#### The Reference Spectra
Build a convenient structure so it is easy to appreciate the necessary information and to splat it into
`filteredReference`.
```julia; fig_height=3; fig_width=10; fig_ext=".svg";
refs = (
  # spectrum, element, composition
  ( al2o3, n"Al", mat"Al2O3" ), #
  ( mgo,   n"Mg", mat"MgO" ),   #
  ( fe,    n"Fe", mat"Fe" ),    #
  ( sio2,  n"Si", mat"SiO2" ),  #
  ( sio2,  n"O",  mat"SiO2" ),  #
  ( caf2,  n"Ca", mat"CaF2" ), )
display(plot(al2o3, caf2, fe, mgo, sio2, klms=collect( ref[2] for ref in refs), xmax=8.0e3))
```

#### Pre-filter the Reference Spectra
```julia
# Build a top-hat filter
filt = buildfilter(NeXLSpectrum.GaussianFilter,det)
# Filter all the reference spectra
frs = collect(Iterators.flatten( filterreference(filt, ref..., withEsc=true) for ref in refs ))
# Now frs contains the filtered references necessary to fit the unknowns
```

#### Fit the Pre-Filtered References to the Unknowns
```julia
res= [ fit(unk,filt,frs,false) for unk in unks ]
asa(DataFrame, res)
```

Let's take a look at a residual spectrum by plotting one of the `FilterFitResult` objects.
```julia; fig_height=3; fig_width=10; fig_ext=".svg";
plot(res[1])
```

#### Quantify the k-ratios by Matrix Correction
```julia
quant = quantify.(res)
asa(DataFrame, quant)
```

Finally plot the results as mass fractions.
```julia; fig_height=3; fig_width=10; fig_ext=".svg";
plot(quant, known=unks[1][:Composition])
```

Plot the difference from the SRM value.
```julia; fig_height=3; fig_width=10; fig_ext=".svg";
plot(quant, known=unks[1][:Composition], delta=true)
```

Plot the difference from the mean value for each element.
```julia; fig_height=3; fig_width=10; fig_ext=".svg";
plot(quant, delta=true)
```
